/*
    ChibiOS - Copyright (C) 2006..2018 Giovanni Di Sirio.

    This file is part of ChibiOS.

    ChibiOS is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    ChibiOS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @startuml {rt_arch.png} "RT Core"
 * package OS {
 *   class ch_system_t <<(S,#FF7700) Singleton>> {
 *     # instance : os_instance_t[]
 *   }
 *   class os_instance_t {
 *     # rlist : ready_list_t
 *     # vtlist : virtual_timers_list_t
 *     # mainthread : thread_t
 *     # dbg : system_debug_t
 *     # trace_buffer : trace_buffer_t
 *     # tmc : tm_calibration_t
 *     # kernel_stats : kernel_stats_t
 *   }
 *   class various_classes {
 *     system_debug_t
 *     trace_buffer_t
 *     tm_calibration_t
 *     kernel_stats_t
 *   }
 *   class registry <<(S,#FF7700) Singleton>> {
 *     + chRegFirstThread()
 *     + chRegNextThread()
 *     + chRegFindThreadByName()
 *     + chRegFindThreadByPointer()
 *     + chRegFindThreadByWorkingArea()
 *   }
 * }
 * package Core {
 *   class scheduler <<(S,#FF7700) Singleton>> {
 *     + {static} chSchReadyI()
 *     + {static} chSchWakeupS()
 *     + {static} chSchGoSleepS()
 *     + {static} chSchGoSleepTimeoutS()
 *   }
 *   class system <<(S,#FF7700) Singleton>> {
 *     + {static} chSysLock()
 *     + {static} chSysUnlock()
 *     + {static} chSysLockFromISR()
 *     + {static} chSysUnlockFromISR()
 *     + {static} chSysSwitch()
 *   }
 *   class port <<(S,#FF7700) Singleton>> {
 *     + {static} port_lock()
 *     + {static} port_unlock()
 *     + {static} port_suspend()
 *     + {static} port_enable()
 *     + {static} port_disable()
 *     + {static} port_switch()
 *     + {static} port_timer_get_time()
 *   }
 * }
 * package Threads {
 *   class thread_list_element_t {
 *     # next : thread_t *
 *   }
 *   class thread_queue_element_t {
 *     # prev : thread_t *
 *   }
 *   class thread_header_t {
 *     # prio : tprio_t
 *     # ctx : port_context
 *     # newer : thread_t *
 *     # older : thread_t *
 *   }
 *   class thread_t {
 *     + {static} chThdCreate()
 *     + {static} chThdSleep()
 *     + {static} chThdSleepUntil()
 *   }
 *   class ready_list_t {
 *     # current : thread_t *
 *   }
 * }
 * package VirtualTimers {
 *   class virtual_timer_header_t {
 *     # next : virtual_timer_header_t *
 *     # prev : virtual_timer_header_t *
 *     # delta: sysinterval_t
 *   }
 *   class virtual_timer_t {
 *     # func : vtfunc_t
 *     # par : void *
 *     + chVTObjectInit()
 *     + chVTSet()
 *     + chVTReset()
 *   }
 *   class virtual_timers_list_t {
 *     # systime : systime_t
 *     # lasttime : systime_t
 *   }
 * }
 *
 *
 * virtual_timer_header_t <|-- virtual_timer_t
 * virtual_timer_header_t <|-- virtual_timers_list_t
 * virtual_timer_t ..> system : use
 * virtual_timer_t ..> port : use
 * virtual_timers_list_t o-- "0..*" virtual_timer_t : active timers
 *
 * thread_list_element_t <|-r- thread_queue_element_t
 * thread_queue_element_t <|-- thread_header_t
 * thread_header_t <|-- thread_t
 * thread_header_t <|-- ready_list_t
 * thread_t .l.> scheduler : use
 * thread_t ..> system : use
 * thread_t ..> port : use
 *
 * scheduler ..> system : use
 * system .l.> port : use
 *
 * various_classes "1" --* os_instance_t : optional support\nclasses
 *
 * ch_system_t *-- "1..*" os_instance_t : configured\ncores
 * os_instance_t *-- "1" ready_list_t
 * os_instance_t *-- "1" virtual_timers_list_t
 * os_instance_t *-- "1" thread_t : main\nthread
 * os_instance_t <-- thread_t : current\ninstance
 * os_instance_t <-- scheduler : current\ninstance
 * os_instance_t <-r- registry : current\ninstance
 *
 * ready_list_t o-- "1..*" thread_t : ready\nthreads
 * ready_list_t o-- "1..*" thread_t : alive\nthreads
 * ready_list_t o-- "1" thread_t : current\nthread
 * @enduml
 *
 * @startuml {rt_arch.png} "RT Synchronization"
 * class CoreAPI <<(S,#FF7700) Singleton>> {
 * }
 * package Synchronization {
 *   class semaphore_t {
 *     # cnt : cnt_t
 *     + chSemObjectInit()
 *     + chSemWait()
 *     + chSemWaitTimeout()
 *     + chSemSignal()
 *     + chSemReset()
 *   }
 *   class mutex_t {
 *     # owner : thread_t *
 *     # next : mutex_t *
 *     # cnt : cnt_t
 *     + chMtxObjectInit()
 *     + chMtxLock()
 *     + chMtxTryLock()
 *     + chMtxUnlock()
 *     + chMtxUnlockAll()
 *   }
 *   class condition_variable_t {
 *     + chCondObjectInit()
 *     + chCondSignal()
 *     + chCondBroadcast()
 *     + chCondWait()
 *     + chCondWaitTimeout()
 *   }
 * }
 * package Communication {
 *   class events {
 *     + chEvtObjectInit()
 *     + chEvtRegister()
 *     + chEvtBroadcastFlags()
 *     + {static} chEvtSignal()
 *     + {static} chEvtWaitOne()
 *     + {static} chEvtWaitAny()
 *     + {static} chEvtWaitAll()
 *     + {static} chEvtDispatch()
 *   }
 *   class messages {
 *     + {static} chMsgWait()
 *     + {static} chMsgGet()
 *     + chMsgRelease()
 *     + chMsgSend()
 *   }
 * }
 *
 * thread_queue_element_t <|-- semaphore_t
 * thread_queue_element_t <|-- mutex_t
 * thread_queue_element_t <|-- condition_variable_t
 *
 * thread_t -- messages
 * thread_t -- events
 * thread_t o-- "0..1" mutex_t: waiting on
 *
 * semaphore_t o-- "1..*" thread_t : waiting\nthreads
 * semaphore_t ..> CoreAPI : use
 *
 * condition_variable_t --> thread_t : current
 * condition_variable_t ..> CoreAPI : use
 *
 * mutex_t o-- "1..*" thread_t : waiting
 * mutex_t o-- "0..1" thread_t : owner
 * mutex_t o-- "0..1" mutex_t : next owned
 * mutex_t "0..*" --o thread_t : owned
 * mutex_t ..> CoreAPI : use
 *
 * events ..> CoreAPI : use
 *
 * messages ..> CoreAPI : use
 *
 * @enduml
 *
 */
