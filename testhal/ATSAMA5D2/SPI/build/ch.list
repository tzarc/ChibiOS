
build/ch.elf:     file format elf32-littlearm


Disassembly of section startup:

00200000 <_start>:
/*
 * System entry points.
 */
                .global _start
_start:
                ldr     pc, _reset
  200000:	e59ff018 	ldr	pc, [pc, #24]	; 200020 <_reset>
                ldr     pc, _undefined
  200004:	e59ff018 	ldr	pc, [pc, #24]	; 200024 <_undefined>
                ldr     pc, _swi
  200008:	e59ff018 	ldr	pc, [pc, #24]	; 200028 <_swi>
                ldr     pc, _prefetch
  20000c:	e59ff018 	ldr	pc, [pc, #24]	; 20002c <_prefetch>
                ldr     pc, _abort
  200010:	e59ff018 	ldr	pc, [pc, #24]	; 200030 <_abort>
                nop
  200014:	e320f000 	nop	{0}
                ldr     pc, _irq
  200018:	e59ff018 	ldr	pc, [pc, #24]	; 200038 <_irq>
                ldr     pc, _fiq
  20001c:	e59ff010 	ldr	pc, [pc, #16]	; 200034 <_fiq>

00200020 <_reset>:
  200020:	00200040 	.word	0x00200040

00200024 <_undefined>:
  200024:	0020003c 	.word	0x0020003c

00200028 <_swi>:
  200028:	0020003c 	.word	0x0020003c

0020002c <_prefetch>:
  20002c:	0020003c 	.word	0x0020003c

00200030 <_abort>:
  200030:	0020003c 	.word	0x0020003c

00200034 <_fiq>:
  200034:	0020029c 	.word	0x0020029c

00200038 <_irq>:
  200038:	0020003c 	.word	0x0020003c

0020003c <Abort_Handler>:
Fiq_Handler:
                .weak   Irq_Handler
Irq_Handler:
                .weak   _unhandled_exception
_unhandled_exception:
                b       _unhandled_exception
  20003c:	eafffffe 	b	20003c <Abort_Handler>

00200040 <Boot_Handler>:
				.global Boot_Handler
Boot_Handler:
				/*
				 * Set VBAR to system vectors table
				 */
                ldr		r0, =_start
  200040:	e59f0058 	ldr	r0, [pc, #88]	; 2000a0 <Boot_Handler+0x60>
                mcr 	p15, 0, r0, c12, c0, 0
  200044:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
                /*
                 * Do not redirect secure interrupts to AIC
                 */
				ldr		r0, =AIC_REDIR_KEY
  200048:	e59f0054 	ldr	r0, [pc, #84]	; 2000a4 <Boot_Handler+0x64>
				ldr             r1, =SFR_SN1
  20004c:	e59f1054 	ldr	r1, [pc, #84]	; 2000a8 <Boot_Handler+0x68>
				ldr		r1, [r1]
  200050:	e5911000 	ldr	r1, [r1]
				eor		r0, r0, r1
  200054:	e0200001 	eor	r0, r0, r1
				bic		r0, r0, #0x1
  200058:	e3c00001 	bic	r0, r0, #1
				ldr		r1, =SFR_AICREDIR
  20005c:	e59f1048 	ldr	r1, [pc, #72]	; 2000ac <Boot_Handler+0x6c>
				str		r0, [r1]
  200060:	e5810000 	str	r0, [r1]
                /*
                 * Reset SCTLR Settings
                 */
                mrc     p15, 0, r0, c1, c0, 0       // Read CP15 System Control register
  200064:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
                bic     r0, r0, #(0x1 << 12)        // Clear I bit 12 to disable I Cache
  200068:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
                bic     r0, r0, #(0x1 <<  2)        // Clear C bit  2 to disable D Cache
  20006c:	e3c00004 	bic	r0, r0, #4
                bic     r0, r0, #0x1                // Clear M bit  0 to disable MMU
  200070:	e3c00001 	bic	r0, r0, #1
                bic     r0, r0, #(0x1 << 11)        // Clear Z bit 11 to disable branch prediction
  200074:	e3c00b02 	bic	r0, r0, #2048	; 0x800
                bic     r0, r0, #(0x1 << 13)        // Clear V bit 13 to disable hivecs
  200078:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
                mcr     p15, 0, r0, c1, c0, 0       // Write value back to CP15 System Control register
  20007c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
                isb
  200080:	f57ff06f 	isb	sy
                /*
                 * Turn off L2Cache
                 */
                bic     r0, r0, #0x1
  200084:	e3c00001 	bic	r0, r0, #1
                ldr     r1, =L2CC_CR
  200088:	e59f1020 	ldr	r1, [pc, #32]	; 2000b0 <Boot_Handler+0x70>
                str     r0, [r1]
  20008c:	e5810000 	str	r0, [r1]
                /*
                 * Configure the L2 cache to be used as an internal SRAM
                 */
                bic     r0, r0, #0x1
  200090:	e3c00001 	bic	r0, r0, #1
                ldr     r1, =SFR_L2CC_HRAMC
  200094:	e59f1018 	ldr	r1, [pc, #24]	; 2000b4 <Boot_Handler+0x74>
                str     r0, [r1]
  200098:	e5810000 	str	r0, [r1]
                b       Reset_Handler
  20009c:	ea00000b 	b	2000d0 <Reset_Handler>
				.global Boot_Handler
Boot_Handler:
				/*
				 * Set VBAR to system vectors table
				 */
                ldr		r0, =_start
  2000a0:	00200000 	.word	0x00200000
                mcr 	p15, 0, r0, c12, c0, 0
                /*
                 * Do not redirect secure interrupts to AIC
                 */
				ldr		r0, =AIC_REDIR_KEY
  2000a4:	b6d81c4c 	.word	0xb6d81c4c
				ldr             r1, =SFR_SN1
  2000a8:	f8030050 	.word	0xf8030050
				ldr		r1, [r1]
				eor		r0, r0, r1
				bic		r0, r0, #0x1
				ldr		r1, =SFR_AICREDIR
  2000ac:	f8030054 	.word	0xf8030054
                isb
                /*
                 * Turn off L2Cache
                 */
                bic     r0, r0, #0x1
                ldr     r1, =L2CC_CR
  2000b0:	00a00100 	.word	0x00a00100
                str     r0, [r1]
                /*
                 * Configure the L2 cache to be used as an internal SRAM
                 */
                bic     r0, r0, #0x1
                ldr     r1, =SFR_L2CC_HRAMC
  2000b4:	f8030058 	.word	0xf8030058
	...
 * Default boot handler. Jump to Reset_Handler.
 */
                .section .boot, "ax"
                .weak	Boot_Handler
Boot_Handler:
                b       Reset_Handler
  2000c0:	ea000002 	b	2000d0 <Reset_Handler>

Disassembly of section .text:

002000d0 <Reset_Handler>:
                .global Reset_Handler
Reset_Handler:
                /*
                 * Stack pointers initialization.
                 */
                ldr     r0, =__stacks_end__
  2000d0:	e59f0098 	ldr	r0, [pc, #152]	; 200170 <bssloop+0x18>
                /* Undefined */
                msr     CPSR_c, #MODE_UND | I_BIT | F_BIT
  2000d4:	e321f0db 	msr	CPSR_c, #219	; 0xdb
                mov     sp, r0
  2000d8:	e1a0d000 	mov	sp, r0
                ldr     r1, =__und_stack_size__
  2000dc:	e59f1090 	ldr	r1, [pc, #144]	; 200174 <bssloop+0x1c>
                sub     r0, r0, r1
  2000e0:	e0400001 	sub	r0, r0, r1
                /* Abort */
                msr     CPSR_c, #MODE_ABT | I_BIT | F_BIT
  2000e4:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
                mov     sp, r0
  2000e8:	e1a0d000 	mov	sp, r0
                ldr     r1, =__abt_stack_size__
  2000ec:	e59f1084 	ldr	r1, [pc, #132]	; 200178 <bssloop+0x20>
                sub     r0, r0, r1
  2000f0:	e0400001 	sub	r0, r0, r1
                /* FIQ */
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2000f4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                mov     sp, r0
  2000f8:	e1a0d000 	mov	sp, r0
                ldr     r1, =__fiq_stack_size__
  2000fc:	e59f1078 	ldr	r1, [pc, #120]	; 20017c <bssloop+0x24>
                sub     r0, r0, r1
  200100:	e0400001 	sub	r0, r0, r1
                /* IRQ */
                msr     CPSR_c, #MODE_IRQ | I_BIT | F_BIT
  200104:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
                mov     sp, r0
  200108:	e1a0d000 	mov	sp, r0
                ldr     r1, =__irq_stack_size__
  20010c:	e59f106c 	ldr	r1, [pc, #108]	; 200180 <bssloop+0x28>
                sub     r0, r0, r1
  200110:	e0400001 	sub	r0, r0, r1
                /* Supervisor */
                msr     CPSR_c, #MODE_SVC | I_BIT | F_BIT
  200114:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
                mov     sp, r0
  200118:	e1a0d000 	mov	sp, r0
                ldr     r1, =__svc_stack_size__
  20011c:	e59f1060 	ldr	r1, [pc, #96]	; 200184 <bssloop+0x2c>
                sub     r0, r0, r1
  200120:	e0400001 	sub	r0, r0, r1
                /* System */
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  200124:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                mov     sp, r0
  200128:	e1a0d000 	mov	sp, r0
//                sub     r0, r0, r1
                /*
                 * Early initialization.
                 */
#if !defined(THUMB_NO_INTERWORKING)
                bl      __early_init
  20012c:	eb00041b 	bl	2011a0 <__early_init>

                /*
                 * Data initialization.
                 * NOTE: It assumes that the DATA size is a multiple of 4.
                 */
                ldr     r1, =_textdata
  200130:	e59f1050 	ldr	r1, [pc, #80]	; 200188 <bssloop+0x30>
                ldr     r2, =_data
  200134:	e59f2050 	ldr	r2, [pc, #80]	; 20018c <bssloop+0x34>
                ldr     r3, =_edata
  200138:	e59f3050 	ldr	r3, [pc, #80]	; 200190 <bssloop+0x38>

0020013c <dataloop>:
dataloop:
                cmp     r2, r3
  20013c:	e1520003 	cmp	r2, r3
                ldrlo   r0, [r1], #4
  200140:	34910004 	ldrcc	r0, [r1], #4
                strlo   r0, [r2], #4
  200144:	34820004 	strcc	r0, [r2], #4
                blo     dataloop
  200148:	3afffffb 	bcc	20013c <dataloop>
                /*
                 * BSS initialization.
                 * NOTE: It assumes that the BSS size is a multiple of 4.
                 */
                mov     r0, #0
  20014c:	e3a00000 	mov	r0, #0
                ldr     r1, =_bss_start
  200150:	e59f103c 	ldr	r1, [pc, #60]	; 200194 <bssloop+0x3c>
                ldr     r2, =_bss_end
  200154:	e59f203c 	ldr	r2, [pc, #60]	; 200198 <bssloop+0x40>

00200158 <bssloop>:
bssloop:
                cmp     r1, r2
  200158:	e1510002 	cmp	r1, r2
                strlo   r0, [r1], #4
  20015c:	34810004 	strcc	r0, [r1], #4
                blo     bssloop
  200160:	3afffffc 	bcc	200158 <bssloop>
                /*
                 * Late initialization.
                 */
#if !defined(THUMB_NO_INTERWORKING)
                bl      __late_init
  200164:	eb000fe5 	bl	204100 <__late_init>
                bl      main
                ldr     r1, =__default_exit
                bx      r1
                .code   32
#else /* !defined(THUMB_NO_INTERWORKING) */
                bl      main
  200168:	eb000794 	bl	201fc0 <main>
                b       __default_exit
  20016c:	ea000fe7 	b	204110 <__default_exit>
                .global Reset_Handler
Reset_Handler:
                /*
                 * Stack pointers initialization.
                 */
                ldr     r0, =__stacks_end__
  200170:	00210858 	.word	0x00210858
                /* Undefined */
                msr     CPSR_c, #MODE_UND | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__und_stack_size__
  200174:	00000008 	.word	0x00000008
                sub     r0, r0, r1
                /* Abort */
                msr     CPSR_c, #MODE_ABT | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__abt_stack_size__
  200178:	00000008 	.word	0x00000008
                sub     r0, r0, r1
                /* FIQ */
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__fiq_stack_size__
  20017c:	00000040 	.word	0x00000040
                sub     r0, r0, r1
                /* IRQ */
                msr     CPSR_c, #MODE_IRQ | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__irq_stack_size__
  200180:	00000400 	.word	0x00000400
                sub     r0, r0, r1
                /* Supervisor */
                msr     CPSR_c, #MODE_SVC | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__svc_stack_size__
  200184:	00000008 	.word	0x00000008

                /*
                 * Data initialization.
                 * NOTE: It assumes that the DATA size is a multiple of 4.
                 */
                ldr     r1, =_textdata
  200188:	002055a0 	.word	0x002055a0
                ldr     r2, =_data
  20018c:	00210858 	.word	0x00210858
                ldr     r3, =_edata
  200190:	00210868 	.word	0x00210868
                /*
                 * BSS initialization.
                 * NOTE: It assumes that the BSS size is a multiple of 4.
                 */
                mov     r0, #0
                ldr     r1, =_bss_start
  200194:	00210868 	.word	0x00210868
                ldr     r2, =_bss_end
  200198:	00210f60 	.word	0x00210f60
  20019c:	00000000 	.word	0x00000000

002001a0 <_port_switch_arm>:
                .balign 16

                .code   32
                .global _port_switch_arm
_port_switch_arm:
                stmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  2001a0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
                str     sp, [r1, #12]
  2001a4:	e581d00c 	str	sp, [r1, #12]
                ldr     sp, [r0, #12]
  2001a8:	e590d00c 	ldr	sp, [r0, #12]
                ldmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  2001ac:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

002001b0 <Mon_Irq_Handler>:
                // secure context. The non secure IRQ handler has
                // the responsibility to return into secure state via a smc.
                //
                // The thread is interrupted in the same way that local FIQ.
                // The frame is created in the system stack of the current thread
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2001b0:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0-r3, r12, lr}
  2001b4:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  2001b8:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                mrs     r0, SPSR
  2001bc:	e14f0000 	mrs	r0, SPSR
                mov     r1, lr
  2001c0:	e1a0100e 	mov	r1, lr
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2001c4:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
  2001c8:	e92d0003 	push	{r0, r1}

                /* Save the s_ctx e recover the ns_ctx */

                // Re-establish the original conditions
                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
  2001cc:	e8bd0003 	pop	{r0, r1}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  2001d0:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                msr     SPSR_fsxc, r0
  2001d4:	e16ff000 	msr	SPSR_fsxc, r0
                mov     lr, r1
  2001d8:	e1a0e001 	mov	lr, r1
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2001dc:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                ldmfd   sp!, {r0-r3, r12, lr}
  2001e0:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  2001e4:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                stmfd   sp!, {lr}               // save lr into monitor stack
  2001e8:	e92d4000 	stmfd	sp!, {lr}
                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
  2001ec:	e3a0e005 	mov	lr, #5
                mrc     p15, 0, lr, c1, c1, 0
  2001f0:	ee11ef11 	mrc	15, 0, lr, cr1, cr1, {0}
                ldmfd   sp!, {lr}
  2001f4:	e8bd4000 	ldmfd	sp!, {lr}
                subs    pc, lr, #4              // return into non-secure world
  2001f8:	e25ef004 	subs	pc, lr, #4

002001fc <Mon_Fiq_Handler>:
                // Here the fiq is taken from non-secure state, via the FIQ vector
                // that is in the mon vector table.
                // Current mode is monitor (so current state is secure).
                // Note also that we never leave secure state while sec FIQ was disabled,
                // then it's always safe to process the FIQ here.
                stmfd   sp!, {lr}               // save lr into monitor stack
  2001fc:	e92d4000 	stmfd	sp!, {lr}
                ldr     lr, =MON_S_SCR          // set secure SCR before to switch to FIQ mode
  200200:	e3a0e002 	mov	lr, #2
                mrc     p15, 0, lr, c1, c1, 0
  200204:	ee11ef11 	mrc	15, 0, lr, cr1, cr1, {0}
                cpsid   if, #MODE_FIQ           // secure FIQ mode
  200208:	f10e00d1 	cpsid	if,#17
                stmfd   sp!, {r0-r3, r12}       // IRQ frame, save scratch registers
  20020c:	e92d100f 	push	{r0, r1, r2, r3, ip}
                ldr     r0, =ARM_IRQ_VECTOR_REG
  200210:	e59f0104 	ldr	r0, [pc, #260]	; 20031c <_zombies+0x4>
                ldr     r0, [r0]
  200214:	e5900000 	ldr	r0, [r0]
                ldr     lr, =_mon_fiq_ret_arm   // ISR return point.
  200218:	e59fe100 	ldr	lr, [pc, #256]	; 200320 <_zombies+0x8>
                bx      r0                      // Calling the ISR.
  20021c:	e12fff10 	bx	r0

00200220 <_mon_fiq_ret_arm>:
_mon_fiq_ret_arm:
                cmp     r0, #0
  200220:	e3500000 	cmp	r0, #0
                ldmfd   sp!, {r0-r3, r12}
  200224:	e8bd100f 	pop	{r0, r1, r2, r3, ip}
                cpsid   if, #MODE_MON
  200228:	f10e00d6 	cpsid	if,#22
                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
  20022c:	e3a0e005 	mov	lr, #5
                mrceq   p15, 0, lr, c1, c1, 0   // only if it will return
  200230:	0e11ef11 	mrceq	15, 0, lr, cr1, cr1, {0}
                ldmfd   sp!, {lr}
  200234:	e8bd4000 	ldmfd	sp!, {lr}
                subeqs  pc, lr, #4              // No reschedule, returns.
  200238:	025ef004 	subseq	pc, lr, #4

                // Now the frame is created in the system stack
                // relative to non secure context,
                // the IRQ and monitor stacks are empty,
                // the state is secure.
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  20023c:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0-r3, r12, lr}
  200240:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                mov		r0, sp
  200244:	e1a0000d 	mov	r0, sp
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  200248:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                stmfd	sp!, {r0}				// address of ns_ctx in mon stack
  20024c:	e92d0001 	stmfd	sp!, {r0}
                mrs     r0, SPSR
  200250:	e14f0000 	mrs	r0, SPSR
                mov     r1, lr
  200254:	e1a0100e 	mov	r1, lr
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  200258:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
  20025c:	e92d0003 	push	{r0, r1}
                mov		r0, sp
  200260:	e1a0000d 	mov	r0, sp

                // Context switch.
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
  200264:	eb00121d 	bl	204ae0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
#endif

                // Re-establish the IRQ conditions again.
                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
  200268:	e8bd0003 	pop	{r0, r1}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  20026c:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                msr     SPSR_fsxc, r0
  200270:	e16ff000 	msr	SPSR_fsxc, r0
                mov     lr, r1
  200274:	e1a0e001 	mov	lr, r1
                ldmfd	sp!, {r0}				// ns_ctx no longer exists, cleanup mon stack
  200278:	e8bd0001 	ldmfd	sp!, {r0}
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  20027c:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                ldmfd   sp!, {r0-r3, r12, lr}
  200280:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  200284:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                stmfd   sp!, {lr}               // save lr into mon stack
  200288:	e92d4000 	stmfd	sp!, {lr}
                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
  20028c:	e3a0e005 	mov	lr, #5
                mrc     p15, 0, lr, c1, c1, 0
  200290:	ee11ef11 	mrc	15, 0, lr, cr1, cr1, {0}
                ldmfd   sp!, {lr}
  200294:	e8bd4000 	ldmfd	sp!, {lr}
                subs    pc, lr, #4              // return into non-secure world
  200298:	e25ef004 	subs	pc, lr, #4

0020029c <Fiq_Handler>:
 *
 */
Fiq_Handler:
                // the fiq is taken locally from secure state
                // current mode is fiq
                stmfd   sp!, {r0-r3, r12, lr}   // save scratch registers and lr
  20029c:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                ldr     r0, =ARM_IRQ_VECTOR_REG
  2002a0:	e59f0074 	ldr	r0, [pc, #116]	; 20031c <_zombies+0x4>
                ldr     r0, [r0]
  2002a4:	e5900000 	ldr	r0, [r0]
                ldr     lr, =_fiq_ret_arm       // ISR return point.
  2002a8:	e59fe074 	ldr	lr, [pc, #116]	; 200324 <_zombies+0xc>
                bx      r0                      // Calling the ISR.
  2002ac:	e12fff10 	bx	r0

002002b0 <_fiq_ret_arm>:
_fiq_ret_arm:
                cmp     r0, #0
  2002b0:	e3500000 	cmp	r0, #0
                ldmfd   sp!, {r0-r3, r12, lr}
  2002b4:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                subeqs  pc, lr, #4              // No reschedule, returns.
  2002b8:	025ef004 	subseq	pc, lr, #4

                // Now the frame is created in the system stack of the current
                // thread, the IRQ stack is empty.
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2002bc:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0-r3, r12, lr}
  2002c0:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2002c4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                mrs     r0, SPSR
  2002c8:	e14f0000 	mrs	r0, SPSR
                mov     r1, lr
  2002cc:	e1a0100e 	mov	r1, lr
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2002d0:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
  2002d4:	e92d0003 	push	{r0, r1}

                // Context switch.
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
  2002d8:	eb001200 	bl	204ae0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
#endif

                // Re-establish the IRQ conditions again.
                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
  2002dc:	e8bd0003 	pop	{r0, r1}
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2002e0:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                msr     SPSR_fsxc, r0
  2002e4:	e16ff000 	msr	SPSR_fsxc, r0
                mov     lr, r1
  2002e8:	e1a0e001 	mov	lr, r1
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2002ec:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                ldmfd   sp!, {r0-r3, r12, lr}
  2002f0:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2002f4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                subs    pc, lr, #4
  2002f8:	e25ef004 	subs	pc, lr, #4
  2002fc:	e320f000 	nop	{0}

00200300 <_port_thread_start>:
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
#endif
				msr     CPSR_c, #MODE_SYS | I_BIT
  200300:	e321f09f 	msr	CPSR_c, #159	; 0x9f
                mov     r0, r5
  200304:	e1a00005 	mov	r0, r5
                mov     lr, pc
  200308:	e1a0e00f 	mov	lr, pc
                bx      r4
  20030c:	e12fff14 	bx	r4
#if defined(_CHIBIOS_RT_CONF_)
                mov     r0, #0              /* MSG_OK */
  200310:	e3a00000 	mov	r0, #0
                bl      chThdExit
  200314:	eb001351 	bl	205060 <chThdExit>

00200318 <_zombies>:
_zombies:       b       _zombies
  200318:	eafffffe 	b	200318 <_zombies>
                stmfd   sp!, {lr}               // save lr into monitor stack
                ldr     lr, =MON_S_SCR          // set secure SCR before to switch to FIQ mode
                mrc     p15, 0, lr, c1, c1, 0
                cpsid   if, #MODE_FIQ           // secure FIQ mode
                stmfd   sp!, {r0-r3, r12}       // IRQ frame, save scratch registers
                ldr     r0, =ARM_IRQ_VECTOR_REG
  20031c:	f803c010 	.word	0xf803c010
                ldr     r0, [r0]
                ldr     lr, =_mon_fiq_ret_arm   // ISR return point.
  200320:	00200220 	.word	0x00200220
                // the fiq is taken locally from secure state
                // current mode is fiq
                stmfd   sp!, {r0-r3, r12, lr}   // save scratch registers and lr
                ldr     r0, =ARM_IRQ_VECTOR_REG
                ldr     r0, [r0]
                ldr     lr, =_fiq_ret_arm       // ISR return point.
  200324:	002002b0 	.word	0x002002b0
	...

00200330 <__aeabi_uidiv>:
  200330:	e2512001 	subs	r2, r1, #1
  200334:	012fff1e 	bxeq	lr
  200338:	3a000074 	bcc	200510 <__aeabi_uidiv+0x1e0>
  20033c:	e1500001 	cmp	r0, r1
  200340:	9a00006b 	bls	2004f4 <__aeabi_uidiv+0x1c4>
  200344:	e1110002 	tst	r1, r2
  200348:	0a00006c 	beq	200500 <__aeabi_uidiv+0x1d0>
  20034c:	e16f3f10 	clz	r3, r0
  200350:	e16f2f11 	clz	r2, r1
  200354:	e0423003 	sub	r3, r2, r3
  200358:	e273301f 	rsbs	r3, r3, #31
  20035c:	10833083 	addne	r3, r3, r3, lsl #1
  200360:	e3a02000 	mov	r2, #0
  200364:	108ff103 	addne	pc, pc, r3, lsl #2
  200368:	e320f000 	nop	{0}
  20036c:	e1500f81 	cmp	r0, r1, lsl #31
  200370:	e0a22002 	adc	r2, r2, r2
  200374:	20400f81 	subcs	r0, r0, r1, lsl #31
  200378:	e1500f01 	cmp	r0, r1, lsl #30
  20037c:	e0a22002 	adc	r2, r2, r2
  200380:	20400f01 	subcs	r0, r0, r1, lsl #30
  200384:	e1500e81 	cmp	r0, r1, lsl #29
  200388:	e0a22002 	adc	r2, r2, r2
  20038c:	20400e81 	subcs	r0, r0, r1, lsl #29
  200390:	e1500e01 	cmp	r0, r1, lsl #28
  200394:	e0a22002 	adc	r2, r2, r2
  200398:	20400e01 	subcs	r0, r0, r1, lsl #28
  20039c:	e1500d81 	cmp	r0, r1, lsl #27
  2003a0:	e0a22002 	adc	r2, r2, r2
  2003a4:	20400d81 	subcs	r0, r0, r1, lsl #27
  2003a8:	e1500d01 	cmp	r0, r1, lsl #26
  2003ac:	e0a22002 	adc	r2, r2, r2
  2003b0:	20400d01 	subcs	r0, r0, r1, lsl #26
  2003b4:	e1500c81 	cmp	r0, r1, lsl #25
  2003b8:	e0a22002 	adc	r2, r2, r2
  2003bc:	20400c81 	subcs	r0, r0, r1, lsl #25
  2003c0:	e1500c01 	cmp	r0, r1, lsl #24
  2003c4:	e0a22002 	adc	r2, r2, r2
  2003c8:	20400c01 	subcs	r0, r0, r1, lsl #24
  2003cc:	e1500b81 	cmp	r0, r1, lsl #23
  2003d0:	e0a22002 	adc	r2, r2, r2
  2003d4:	20400b81 	subcs	r0, r0, r1, lsl #23
  2003d8:	e1500b01 	cmp	r0, r1, lsl #22
  2003dc:	e0a22002 	adc	r2, r2, r2
  2003e0:	20400b01 	subcs	r0, r0, r1, lsl #22
  2003e4:	e1500a81 	cmp	r0, r1, lsl #21
  2003e8:	e0a22002 	adc	r2, r2, r2
  2003ec:	20400a81 	subcs	r0, r0, r1, lsl #21
  2003f0:	e1500a01 	cmp	r0, r1, lsl #20
  2003f4:	e0a22002 	adc	r2, r2, r2
  2003f8:	20400a01 	subcs	r0, r0, r1, lsl #20
  2003fc:	e1500981 	cmp	r0, r1, lsl #19
  200400:	e0a22002 	adc	r2, r2, r2
  200404:	20400981 	subcs	r0, r0, r1, lsl #19
  200408:	e1500901 	cmp	r0, r1, lsl #18
  20040c:	e0a22002 	adc	r2, r2, r2
  200410:	20400901 	subcs	r0, r0, r1, lsl #18
  200414:	e1500881 	cmp	r0, r1, lsl #17
  200418:	e0a22002 	adc	r2, r2, r2
  20041c:	20400881 	subcs	r0, r0, r1, lsl #17
  200420:	e1500801 	cmp	r0, r1, lsl #16
  200424:	e0a22002 	adc	r2, r2, r2
  200428:	20400801 	subcs	r0, r0, r1, lsl #16
  20042c:	e1500781 	cmp	r0, r1, lsl #15
  200430:	e0a22002 	adc	r2, r2, r2
  200434:	20400781 	subcs	r0, r0, r1, lsl #15
  200438:	e1500701 	cmp	r0, r1, lsl #14
  20043c:	e0a22002 	adc	r2, r2, r2
  200440:	20400701 	subcs	r0, r0, r1, lsl #14
  200444:	e1500681 	cmp	r0, r1, lsl #13
  200448:	e0a22002 	adc	r2, r2, r2
  20044c:	20400681 	subcs	r0, r0, r1, lsl #13
  200450:	e1500601 	cmp	r0, r1, lsl #12
  200454:	e0a22002 	adc	r2, r2, r2
  200458:	20400601 	subcs	r0, r0, r1, lsl #12
  20045c:	e1500581 	cmp	r0, r1, lsl #11
  200460:	e0a22002 	adc	r2, r2, r2
  200464:	20400581 	subcs	r0, r0, r1, lsl #11
  200468:	e1500501 	cmp	r0, r1, lsl #10
  20046c:	e0a22002 	adc	r2, r2, r2
  200470:	20400501 	subcs	r0, r0, r1, lsl #10
  200474:	e1500481 	cmp	r0, r1, lsl #9
  200478:	e0a22002 	adc	r2, r2, r2
  20047c:	20400481 	subcs	r0, r0, r1, lsl #9
  200480:	e1500401 	cmp	r0, r1, lsl #8
  200484:	e0a22002 	adc	r2, r2, r2
  200488:	20400401 	subcs	r0, r0, r1, lsl #8
  20048c:	e1500381 	cmp	r0, r1, lsl #7
  200490:	e0a22002 	adc	r2, r2, r2
  200494:	20400381 	subcs	r0, r0, r1, lsl #7
  200498:	e1500301 	cmp	r0, r1, lsl #6
  20049c:	e0a22002 	adc	r2, r2, r2
  2004a0:	20400301 	subcs	r0, r0, r1, lsl #6
  2004a4:	e1500281 	cmp	r0, r1, lsl #5
  2004a8:	e0a22002 	adc	r2, r2, r2
  2004ac:	20400281 	subcs	r0, r0, r1, lsl #5
  2004b0:	e1500201 	cmp	r0, r1, lsl #4
  2004b4:	e0a22002 	adc	r2, r2, r2
  2004b8:	20400201 	subcs	r0, r0, r1, lsl #4
  2004bc:	e1500181 	cmp	r0, r1, lsl #3
  2004c0:	e0a22002 	adc	r2, r2, r2
  2004c4:	20400181 	subcs	r0, r0, r1, lsl #3
  2004c8:	e1500101 	cmp	r0, r1, lsl #2
  2004cc:	e0a22002 	adc	r2, r2, r2
  2004d0:	20400101 	subcs	r0, r0, r1, lsl #2
  2004d4:	e1500081 	cmp	r0, r1, lsl #1
  2004d8:	e0a22002 	adc	r2, r2, r2
  2004dc:	20400081 	subcs	r0, r0, r1, lsl #1
  2004e0:	e1500001 	cmp	r0, r1
  2004e4:	e0a22002 	adc	r2, r2, r2
  2004e8:	20400001 	subcs	r0, r0, r1
  2004ec:	e1a00002 	mov	r0, r2
  2004f0:	e12fff1e 	bx	lr
  2004f4:	03a00001 	moveq	r0, #1
  2004f8:	13a00000 	movne	r0, #0
  2004fc:	e12fff1e 	bx	lr
  200500:	e16f2f11 	clz	r2, r1
  200504:	e262201f 	rsb	r2, r2, #31
  200508:	e1a00230 	lsr	r0, r0, r2
  20050c:	e12fff1e 	bx	lr
  200510:	e3500000 	cmp	r0, #0
  200514:	13e00000 	mvnne	r0, #0
  200518:	ea000008 	b	200540 <__aeabi_idiv0>

0020051c <__aeabi_uidivmod>:
  20051c:	e3510000 	cmp	r1, #0
  200520:	0afffffa 	beq	200510 <__aeabi_uidiv+0x1e0>
  200524:	e92d4003 	push	{r0, r1, lr}
  200528:	ebffff80 	bl	200330 <__aeabi_uidiv>
  20052c:	e8bd4006 	pop	{r1, r2, lr}
  200530:	e0030092 	mul	r3, r2, r0
  200534:	e0411003 	sub	r1, r1, r3
  200538:	e12fff1e 	bx	lr
  20053c:	00000000 	andeq	r0, r0, r0

00200540 <__aeabi_idiv0>:
  200540:	e12fff1e 	bx	lr
	...

00200550 <spi_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
  200550:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200554:	e24dd00c 	sub	sp, sp, #12
  200558:	e58d0004 	str	r0, [sp, #4]
  20055c:	e58d1000 	str	r1, [sp]

  /* DMA errors handling.*/
  #if defined(SAMA_SPI_DMA_ERROR_HOOK)
  if ((flags & (XDMAC_CIS_RBEIS | XDMAC_CIS_ROIS)) != 0) {
  200560:	e59d3000 	ldr	r3, [sp]
  200564:	e2033050 	and	r3, r3, #80	; 0x50
  200568:	e3530000 	cmp	r3, #0
  20056c:	0a000002 	beq	20057c <spi_lld_serve_rx_interrupt+0x2c>
    SAMA_SPI_DMA_ERROR_HOOK(spip);
  200570:	e3050478 	movw	r0, #21624	; 0x5478
  200574:	e3400020 	movt	r0, #32
  200578:	eb000d5c 	bl	203af0 <osalSysHalt.lto_priv.23>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaChannelDisable(spip->dmatx);
  20057c:	e59d3004 	ldr	r3, [sp, #4]
  200580:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200584:	e5933000 	ldr	r3, [r3]
  200588:	e59d2004 	ldr	r2, [sp, #4]
  20058c:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  200590:	e5922000 	ldr	r2, [r2]
  200594:	e5921020 	ldr	r1, [r2, #32]
  200598:	e59d2004 	ldr	r2, [sp, #4]
  20059c:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  2005a0:	e5d22004 	ldrb	r2, [r2, #4]
  2005a4:	e1a00002 	mov	r0, r2
  2005a8:	e3a02001 	mov	r2, #1
  2005ac:	e1a02012 	lsl	r2, r2, r0
  2005b0:	e1812002 	orr	r2, r1, r2
  2005b4:	e5832020 	str	r2, [r3, #32]
  2005b8:	e59d3004 	ldr	r3, [sp, #4]
  2005bc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  2005c0:	e5933000 	ldr	r3, [r3]
  2005c4:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  2005c8:	e59d3004 	ldr	r3, [sp, #4]
  2005cc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  2005d0:	e5d33004 	ldrb	r3, [r3, #4]
  2005d4:	e1a01003 	mov	r1, r3
  2005d8:	e3a03001 	mov	r3, #1
  2005dc:	e1a03113 	lsl	r3, r3, r1
  2005e0:	e0033002 	and	r3, r3, r2
  2005e4:	e3530001 	cmp	r3, #1
  2005e8:	0afffff2 	beq	2005b8 <spi_lld_serve_rx_interrupt+0x68>
  2005ec:	e59d3004 	ldr	r3, [sp, #4]
  2005f0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  2005f4:	e5932000 	ldr	r2, [r3]
  2005f8:	e59d3004 	ldr	r3, [sp, #4]
  2005fc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200600:	e5d33004 	ldrb	r3, [r3, #4]
  200604:	e1a03303 	lsl	r3, r3, #6
  200608:	e0823003 	add	r3, r2, r3
  20060c:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
  dmaChannelDisable(spip->dmarx);
  200610:	e59d3004 	ldr	r3, [sp, #4]
  200614:	e5933020 	ldr	r3, [r3, #32]
  200618:	e5933000 	ldr	r3, [r3]
  20061c:	e59d2004 	ldr	r2, [sp, #4]
  200620:	e5922020 	ldr	r2, [r2, #32]
  200624:	e5922000 	ldr	r2, [r2]
  200628:	e5921020 	ldr	r1, [r2, #32]
  20062c:	e59d2004 	ldr	r2, [sp, #4]
  200630:	e5922020 	ldr	r2, [r2, #32]
  200634:	e5d22004 	ldrb	r2, [r2, #4]
  200638:	e1a00002 	mov	r0, r2
  20063c:	e3a02001 	mov	r2, #1
  200640:	e1a02012 	lsl	r2, r2, r0
  200644:	e1812002 	orr	r2, r1, r2
  200648:	e5832020 	str	r2, [r3, #32]
  20064c:	e59d3004 	ldr	r3, [sp, #4]
  200650:	e5933020 	ldr	r3, [r3, #32]
  200654:	e5933000 	ldr	r3, [r3]
  200658:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  20065c:	e59d3004 	ldr	r3, [sp, #4]
  200660:	e5933020 	ldr	r3, [r3, #32]
  200664:	e5d33004 	ldrb	r3, [r3, #4]
  200668:	e1a01003 	mov	r1, r3
  20066c:	e3a03001 	mov	r3, #1
  200670:	e1a03113 	lsl	r3, r3, r1
  200674:	e0033002 	and	r3, r3, r2
  200678:	e3530001 	cmp	r3, #1
  20067c:	0afffff2 	beq	20064c <spi_lld_serve_rx_interrupt+0xfc>
  200680:	e59d3004 	ldr	r3, [sp, #4]
  200684:	e5933020 	ldr	r3, [r3, #32]
  200688:	e5932000 	ldr	r2, [r3]
  20068c:	e59d3004 	ldr	r3, [sp, #4]
  200690:	e5933020 	ldr	r3, [r3, #32]
  200694:	e5d33004 	ldrb	r3, [r3, #4]
  200698:	e1a03303 	lsl	r3, r3, #6
  20069c:	e0823003 	add	r3, r2, r3
  2006a0:	e593305c 	ldr	r3, [r3, #92]	; 0x5c

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
  2006a4:	e59d3004 	ldr	r3, [sp, #4]
  2006a8:	e5933004 	ldr	r3, [r3, #4]
  2006ac:	e5933000 	ldr	r3, [r3]
  2006b0:	e3530000 	cmp	r3, #0
  2006b4:	0a00000f 	beq	2006f8 <spi_lld_serve_rx_interrupt+0x1a8>
  2006b8:	e59d3004 	ldr	r3, [sp, #4]
  2006bc:	e3a02004 	mov	r2, #4
  2006c0:	e5c32000 	strb	r2, [r3]
  2006c4:	e59d3004 	ldr	r3, [sp, #4]
  2006c8:	e5933004 	ldr	r3, [r3, #4]
  2006cc:	e5933000 	ldr	r3, [r3]
  2006d0:	e59d0004 	ldr	r0, [sp, #4]
  2006d4:	e12fff33 	blx	r3
  2006d8:	e59d3004 	ldr	r3, [sp, #4]
  2006dc:	e5d33000 	ldrb	r3, [r3]
  2006e0:	e3530004 	cmp	r3, #4
  2006e4:	1a000006 	bne	200704 <spi_lld_serve_rx_interrupt+0x1b4>
  2006e8:	e59d3004 	ldr	r3, [sp, #4]
  2006ec:	e3a02002 	mov	r2, #2
  2006f0:	e5c32000 	strb	r2, [r3]
  2006f4:	ea000002 	b	200704 <spi_lld_serve_rx_interrupt+0x1b4>
  2006f8:	e59d3004 	ldr	r3, [sp, #4]
  2006fc:	e3a02002 	mov	r2, #2
  200700:	e5c32000 	strb	r2, [r3]
  200704:	eb000d01 	bl	203b10 <osalSysLockFromISR.lto_priv.10>
  200708:	e59d3004 	ldr	r3, [sp, #4]
  20070c:	e2833008 	add	r3, r3, #8
  200710:	e3a01000 	mov	r1, #0
  200714:	e1a00003 	mov	r0, r3
  200718:	eb000d04 	bl	203b30 <osalThreadResumeI.lto_priv.22>
  20071c:	eb000cff 	bl	203b20 <osalSysUnlockFromISR.lto_priv.8>
}
  200720:	e28dd00c 	add	sp, sp, #12
  200724:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00200730 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
  200730:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200734:	e24dd00c 	sub	sp, sp, #12
  200738:	e58d0004 	str	r0, [sp, #4]
  20073c:	e58d1000 	str	r1, [sp]

  /* DMA errors handling.*/

#if defined(SAMA_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (XDMAC_CIS_WBEIS | XDMAC_CIS_ROIS)) != 0) {
  200740:	e59d3000 	ldr	r3, [sp]
  200744:	e2033060 	and	r3, r3, #96	; 0x60
  200748:	e3530000 	cmp	r3, #0
  20074c:	0a000002 	beq	20075c <spi_lld_serve_tx_interrupt+0x2c>
    SAMA_SPI_DMA_ERROR_HOOK(spip);
  200750:	e3050478 	movw	r0, #21624	; 0x5478
  200754:	e3400020 	movt	r0, #32
  200758:	eb000ce4 	bl	203af0 <osalSysHalt.lto_priv.23>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
  20075c:	e28dd00c 	add	sp, sp, #12
  200760:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00200770 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
  200770:	e92d4010 	push	{r4, lr}
                    XDMAC_CC_PERID(PERID_SPI0_TX);
#endif /* SAMA_SPI_USE_SPI0 */

#if SAMA_SPI_USE_SPI1
  /* Driver initialization.*/
  spiObjectInit(&SPID1);
  200774:	e3000bd8 	movw	r0, #3032	; 0xbd8
  200778:	e3400021 	movt	r0, #33	; 0x21
  20077c:	eb00092b 	bl	202c30 <spiObjectInit>
  SPID1.spi       = SPI1;
  200780:	e3003bd8 	movw	r3, #3032	; 0xbd8
  200784:	e3403021 	movt	r3, #33	; 0x21
  200788:	e3a0233f 	mov	r2, #-67108864	; 0xfc000000
  20078c:	e583201c 	str	r2, [r3, #28]
  SPID1.dmarx     = NULL;
  200790:	e3003bd8 	movw	r3, #3032	; 0xbd8
  200794:	e3403021 	movt	r3, #33	; 0x21
  200798:	e3a02000 	mov	r2, #0
  20079c:	e5832020 	str	r2, [r3, #32]
  SPID1.dmatx     = NULL;
  2007a0:	e3003bd8 	movw	r3, #3032	; 0xbd8
  2007a4:	e3403021 	movt	r3, #33	; 0x21
  2007a8:	e3a02000 	mov	r2, #0
  2007ac:	e5832024 	str	r2, [r3, #36]	; 0x24
  SPID1.rxdmamode = XDMAC_CC_TYPE_PER_TRAN |
  2007b0:	e3002bd8 	movw	r2, #3032	; 0xbd8
  2007b4:	e3402021 	movt	r2, #33	; 0x21
  2007b8:	e3023001 	movw	r3, #8193	; 0x2001
  2007bc:	e3403904 	movt	r3, #2308	; 0x904
  2007c0:	e5823028 	str	r3, [r2, #40]	; 0x28
                    XDMAC_CC_SIF_AHB_IF1 |
                    XDMAC_CC_DIF_AHB_IF0 |
                    XDMAC_CC_SAM_FIXED_AM |
                    XDMAC_CC_DAM_INCREMENTED_AM |
                    XDMAC_CC_PERID(PERID_SPI1_RX);
  SPID1.txdmamode = XDMAC_CC_TYPE_PER_TRAN |
  2007c4:	e3002bd8 	movw	r2, #3032	; 0xbd8
  2007c8:	e3402021 	movt	r2, #33	; 0x21
  2007cc:	e3043011 	movw	r3, #16401	; 0x4011
  2007d0:	e3403801 	movt	r3, #2049	; 0x801
  2007d4:	e582302c 	str	r3, [r2, #44]	; 0x2c
                     XDMAC_CC_DIF_AHB_IF1 |
                     XDMAC_CC_SAM_INCREMENTED_AM |
                     XDMAC_CC_DAM_FIXED_AM |
                     XDMAC_CC_PERID(PERID_FLEXCOM4_TX);
#endif /* SAMA_SPI_USE_FLEXCOM4 */
}
  2007d8:	e8bd8010 	pop	{r4, pc}
  2007dc:	00000000 	andeq	r0, r0, r0

002007e0 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
  2007e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2007e4:	e24dd00c 	sub	sp, sp, #12
  2007e8:	e58d0004 	str	r0, [sp, #4]

  /* Configures the peripheral.*/

  if (spip->state == SPI_STOP) {
  2007ec:	e59d3004 	ldr	r3, [sp, #4]
  2007f0:	e5d33000 	ldrb	r3, [r3]
  2007f4:	e3530001 	cmp	r3, #1
  2007f8:	1a000025 	bne	200894 <spi_lld_start+0xb4>
    /* Enable SPI0 clock */
      pmcEnableSPI0();
    }
#endif /* SAMA_SPI_USE_SPI0 */
#if SAMA_SPI_USE_SPI1
    if (&SPID1 == spip) {
  2007fc:	e59d2004 	ldr	r2, [sp, #4]
  200800:	e3003bd8 	movw	r3, #3032	; 0xbd8
  200804:	e3403021 	movt	r3, #33	; 0x21
  200808:	e1520003 	cmp	r2, r3
  20080c:	1a000020 	bne	200894 <spi_lld_start+0xb4>
      spip->dmarx = dmaChannelAllocate(SAMA_SPI_SPI1_DMA_IRQ_PRIORITY,
  200810:	e59d2004 	ldr	r2, [sp, #4]
  200814:	e3001550 	movw	r1, #1360	; 0x550
  200818:	e3401020 	movt	r1, #32
  20081c:	e3a00004 	mov	r0, #4
  200820:	eb000c0a 	bl	203850 <dmaChannelAllocate>
  200824:	e1a02000 	mov	r2, r0
  200828:	e59d3004 	ldr	r3, [sp, #4]
  20082c:	e5832020 	str	r2, [r3, #32]
                                       (sama_dmaisr_t)spi_lld_serve_rx_interrupt,
                                       (void *)spip);
      osalDbgAssert(spip->dmarx != NULL, "no channel allocated");

      spip->dmatx = dmaChannelAllocate(SAMA_SPI_SPI1_DMA_IRQ_PRIORITY,
  200830:	e59d2004 	ldr	r2, [sp, #4]
  200834:	e3001730 	movw	r1, #1840	; 0x730
  200838:	e3401020 	movt	r1, #32
  20083c:	e3a00004 	mov	r0, #4
  200840:	eb000c02 	bl	203850 <dmaChannelAllocate>
  200844:	e1a02000 	mov	r2, r0
  200848:	e59d3004 	ldr	r3, [sp, #4]
  20084c:	e5832024 	str	r2, [r3, #36]	; 0x24
                                       (sama_dmaisr_t)spi_lld_serve_tx_interrupt,
                                       (void *)spip);
      osalDbgAssert(spip->dmatx != NULL, "no channel allocated");
    /* Enable SPI1 clock */
      pmcEnableSPI1();
  200850:	e3a03901 	mov	r3, #16384	; 0x4000
  200854:	e34f3001 	movt	r3, #61441	; 0xf001
  200858:	e3a02c43 	mov	r2, #17152	; 0x4300
  20085c:	e345204d 	movt	r2, #20557	; 0x504d
  200860:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  200864:	e3a03901 	mov	r3, #16384	; 0x4000
  200868:	e34f3001 	movt	r3, #61441	; 0xf001
  20086c:	e3a02901 	mov	r2, #16384	; 0x4000
  200870:	e34f2001 	movt	r2, #61441	; 0xf001
  200874:	e5922100 	ldr	r2, [r2, #256]	; 0x100
  200878:	e3822004 	orr	r2, r2, #4
  20087c:	e5832100 	str	r2, [r3, #256]	; 0x100
  200880:	e3a03901 	mov	r3, #16384	; 0x4000
  200884:	e34f3001 	movt	r3, #61441	; 0xf001
  200888:	e3042301 	movw	r2, #17153	; 0x4301
  20088c:	e345204d 	movt	r2, #20557	; 0x504d
  200890:	e58320e4 	str	r2, [r3, #228]	; 0xe4
    }
#endif /* SAMA_SPI_USE_FLEXCOM4 */
  }

  /* Set mode */
  dmaChannelSetMode(spip->dmarx, spip->rxdmamode);
  200894:	e59d3004 	ldr	r3, [sp, #4]
  200898:	e5933020 	ldr	r3, [r3, #32]
  20089c:	e5931000 	ldr	r1, [r3]
  2008a0:	e59d3004 	ldr	r3, [sp, #4]
  2008a4:	e5933020 	ldr	r3, [r3, #32]
  2008a8:	e5d33004 	ldrb	r3, [r3, #4]
  2008ac:	e1a00003 	mov	r0, r3
  2008b0:	e59d3004 	ldr	r3, [sp, #4]
  2008b4:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  2008b8:	e1a03300 	lsl	r3, r0, #6
  2008bc:	e0813003 	add	r3, r1, r3
  2008c0:	e5832078 	str	r2, [r3, #120]	; 0x78
  dmaChannelSetMode(spip->dmatx, spip->txdmamode);
  2008c4:	e59d3004 	ldr	r3, [sp, #4]
  2008c8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  2008cc:	e5931000 	ldr	r1, [r3]
  2008d0:	e59d3004 	ldr	r3, [sp, #4]
  2008d4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  2008d8:	e5d33004 	ldrb	r3, [r3, #4]
  2008dc:	e1a00003 	mov	r0, r3
  2008e0:	e59d3004 	ldr	r3, [sp, #4]
  2008e4:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
  2008e8:	e1a03300 	lsl	r3, r0, #6
  2008ec:	e0813003 	add	r3, r1, r3
  2008f0:	e5832078 	str	r2, [r3, #120]	; 0x78

  /* Disable write protection */
  spiDisableWP(spip->spi);
  2008f4:	e59d3004 	ldr	r3, [sp, #4]
  2008f8:	e593201c 	ldr	r2, [r3, #28]
  2008fc:	e3a03c49 	mov	r3, #18688	; 0x4900
  200900:	e3453350 	movt	r3, #21328	; 0x5350
  200904:	e58230e4 	str	r3, [r2, #228]	; 0xe4

  /* Execute a software reset of the SPI twice */
  spip->spi->SPI_CR = SPI_CR_SWRST;
  200908:	e59d3004 	ldr	r3, [sp, #4]
  20090c:	e593301c 	ldr	r3, [r3, #28]
  200910:	e3a02080 	mov	r2, #128	; 0x80
  200914:	e5832000 	str	r2, [r3]
  spip->spi->SPI_CR = SPI_CR_SWRST;
  200918:	e59d3004 	ldr	r3, [sp, #4]
  20091c:	e593301c 	ldr	r3, [r3, #28]
  200920:	e3a02080 	mov	r2, #128	; 0x80
  200924:	e5832000 	str	r2, [r3]

  /* SPI configuration */
  spip->spi->SPI_MR = SPI_MR_MSTR | spip->config->mr;
  200928:	e59d3004 	ldr	r3, [sp, #4]
  20092c:	e593301c 	ldr	r3, [r3, #28]
  200930:	e59d2004 	ldr	r2, [sp, #4]
  200934:	e5922004 	ldr	r2, [r2, #4]
  200938:	e5922008 	ldr	r2, [r2, #8]
  20093c:	e3822001 	orr	r2, r2, #1
  200940:	e5832004 	str	r2, [r3, #4]
  spip->spi->SPI_MR &= ~SPI_MR_PCS_Msk;
  200944:	e59d3004 	ldr	r3, [sp, #4]
  200948:	e593301c 	ldr	r3, [r3, #28]
  20094c:	e59d2004 	ldr	r2, [sp, #4]
  200950:	e592201c 	ldr	r2, [r2, #28]
  200954:	e5922004 	ldr	r2, [r2, #4]
  200958:	e3c2280f 	bic	r2, r2, #983040	; 0xf0000
  20095c:	e5832004 	str	r2, [r3, #4]
  spip->spi->SPI_MR |=  SPI_PCS(spip->config->npcs);
  200960:	e59d3004 	ldr	r3, [sp, #4]
  200964:	e593301c 	ldr	r3, [r3, #28]
  200968:	e59d2004 	ldr	r2, [sp, #4]
  20096c:	e592201c 	ldr	r2, [r2, #28]
  200970:	e5921004 	ldr	r1, [r2, #4]
  200974:	e59d2004 	ldr	r2, [sp, #4]
  200978:	e5922004 	ldr	r2, [r2, #4]
  20097c:	e1d220b4 	ldrh	r2, [r2, #4]
  200980:	e1a00002 	mov	r0, r2
  200984:	e3a02001 	mov	r2, #1
  200988:	e1a02012 	lsl	r2, r2, r0
  20098c:	e1e02002 	mvn	r2, r2
  200990:	e1a02802 	lsl	r2, r2, #16
  200994:	e202280f 	and	r2, r2, #983040	; 0xf0000
  200998:	e1812002 	orr	r2, r1, r2
  20099c:	e5832004 	str	r2, [r3, #4]
  spip->spi->SPI_CSR[spip->config->npcs] = spip->config->csr;
  2009a0:	e59d3004 	ldr	r3, [sp, #4]
  2009a4:	e593301c 	ldr	r3, [r3, #28]
  2009a8:	e59d2004 	ldr	r2, [sp, #4]
  2009ac:	e5922004 	ldr	r2, [r2, #4]
  2009b0:	e1d220b4 	ldrh	r2, [r2, #4]
  2009b4:	e1a00002 	mov	r0, r2
  2009b8:	e59d2004 	ldr	r2, [sp, #4]
  2009bc:	e5922004 	ldr	r2, [r2, #4]
  2009c0:	e592100c 	ldr	r1, [r2, #12]
  2009c4:	e280200c 	add	r2, r0, #12
  2009c8:	e7831102 	str	r1, [r3, r2, lsl #2]

  /* if SPI_CSRx_BITS > 8, dma is set to 16 bits  */
  if (((spip->spi->SPI_CSR[spip->config->npcs] >> 4) & 0xF) > 0) {
  2009cc:	e59d3004 	ldr	r3, [sp, #4]
  2009d0:	e593301c 	ldr	r3, [r3, #28]
  2009d4:	e59d2004 	ldr	r2, [sp, #4]
  2009d8:	e5922004 	ldr	r2, [r2, #4]
  2009dc:	e1d220b4 	ldrh	r2, [r2, #4]
  2009e0:	e282200c 	add	r2, r2, #12
  2009e4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  2009e8:	e1a03223 	lsr	r3, r3, #4
  2009ec:	e203300f 	and	r3, r3, #15
  2009f0:	e3530000 	cmp	r3, #0
  2009f4:	0a000019 	beq	200a60 <spi_lld_start+0x280>
    dmaChannelSetMode(spip->dmatx, spip->txdmamode | XDMAC_CC_DWIDTH_HALFWORD);
  2009f8:	e59d3004 	ldr	r3, [sp, #4]
  2009fc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200a00:	e5931000 	ldr	r1, [r3]
  200a04:	e59d3004 	ldr	r3, [sp, #4]
  200a08:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200a0c:	e5d33004 	ldrb	r3, [r3, #4]
  200a10:	e1a00003 	mov	r0, r3
  200a14:	e59d3004 	ldr	r3, [sp, #4]
  200a18:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  200a1c:	e3832b02 	orr	r2, r3, #2048	; 0x800
  200a20:	e1a03300 	lsl	r3, r0, #6
  200a24:	e0813003 	add	r3, r1, r3
  200a28:	e5832078 	str	r2, [r3, #120]	; 0x78
    dmaChannelSetMode(spip->dmarx, spip->rxdmamode | XDMAC_CC_DWIDTH_HALFWORD);
  200a2c:	e59d3004 	ldr	r3, [sp, #4]
  200a30:	e5933020 	ldr	r3, [r3, #32]
  200a34:	e5931000 	ldr	r1, [r3]
  200a38:	e59d3004 	ldr	r3, [sp, #4]
  200a3c:	e5933020 	ldr	r3, [r3, #32]
  200a40:	e5d33004 	ldrb	r3, [r3, #4]
  200a44:	e1a00003 	mov	r0, r3
  200a48:	e59d3004 	ldr	r3, [sp, #4]
  200a4c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  200a50:	e3832b02 	orr	r2, r3, #2048	; 0x800
  200a54:	e1a03300 	lsl	r3, r0, #6
  200a58:	e0813003 	add	r3, r1, r3
  200a5c:	e5832078 	str	r2, [r3, #120]	; 0x78
  }

  /* Enable SPI */
  spip->spi->SPI_CR |= SPI_CR_SPIEN;
  200a60:	e59d3004 	ldr	r3, [sp, #4]
  200a64:	e593301c 	ldr	r3, [r3, #28]
  200a68:	e59d2004 	ldr	r2, [sp, #4]
  200a6c:	e592201c 	ldr	r2, [r2, #28]
  200a70:	e5922000 	ldr	r2, [r2]
  200a74:	e3822001 	orr	r2, r2, #1
  200a78:	e5832000 	str	r2, [r3]
  /* Enable write protection.  */
  spiEnableWP(spip->spi);
  200a7c:	e59d3004 	ldr	r3, [sp, #4]
  200a80:	e593201c 	ldr	r2, [r3, #28]
  200a84:	e3043901 	movw	r3, #18689	; 0x4901
  200a88:	e3453350 	movt	r3, #21328	; 0x5350
  200a8c:	e58230e4 	str	r3, [r2, #228]	; 0xe4
}
  200a90:	e28dd00c 	add	sp, sp, #12
  200a94:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00200aa0 <spi_lld_exchange>:
 * @param[out]rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
  200aa0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200aa4:	e24dd014 	sub	sp, sp, #20
  200aa8:	e58d000c 	str	r0, [sp, #12]
  200aac:	e58d1008 	str	r1, [sp, #8]
  200ab0:	e58d2004 	str	r2, [sp, #4]
  200ab4:	e58d3000 	str	r3, [sp]

  /* Writing channel */
  dmaChannelSetSource(spip->dmatx, txbuf);
  200ab8:	e59d300c 	ldr	r3, [sp, #12]
  200abc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200ac0:	e5931000 	ldr	r1, [r3]
  200ac4:	e59d300c 	ldr	r3, [sp, #12]
  200ac8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200acc:	e5d33004 	ldrb	r3, [r3, #4]
  200ad0:	e59d2004 	ldr	r2, [sp, #4]
  200ad4:	e1a03303 	lsl	r3, r3, #6
  200ad8:	e0813003 	add	r3, r1, r3
  200adc:	e5832060 	str	r2, [r3, #96]	; 0x60
  dmaChannelSetDestination(spip->dmatx, &spip->spi->SPI_TDR);
  200ae0:	e59d300c 	ldr	r3, [sp, #12]
  200ae4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200ae8:	e5932000 	ldr	r2, [r3]
  200aec:	e59d300c 	ldr	r3, [sp, #12]
  200af0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200af4:	e5d33004 	ldrb	r3, [r3, #4]
  200af8:	e1a00003 	mov	r0, r3
  200afc:	e59d300c 	ldr	r3, [sp, #12]
  200b00:	e593301c 	ldr	r3, [r3, #28]
  200b04:	e283300c 	add	r3, r3, #12
  200b08:	e1a01003 	mov	r1, r3
  200b0c:	e1a03300 	lsl	r3, r0, #6
  200b10:	e0823003 	add	r3, r2, r3
  200b14:	e5831064 	str	r1, [r3, #100]	; 0x64
  dmaChannelSetTransactionSize(spip->dmatx, n);
  200b18:	e59d300c 	ldr	r3, [sp, #12]
  200b1c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200b20:	e59d1008 	ldr	r1, [sp, #8]
  200b24:	e1a00003 	mov	r0, r3
  200b28:	eb000afc 	bl	203720 <dmaChannelSetTransactionSize>

  /* Reading channel */
  dmaChannelSetSource(spip->dmarx, &spip->spi->SPI_RDR);
  200b2c:	e59d300c 	ldr	r3, [sp, #12]
  200b30:	e5933020 	ldr	r3, [r3, #32]
  200b34:	e5932000 	ldr	r2, [r3]
  200b38:	e59d300c 	ldr	r3, [sp, #12]
  200b3c:	e5933020 	ldr	r3, [r3, #32]
  200b40:	e5d33004 	ldrb	r3, [r3, #4]
  200b44:	e1a00003 	mov	r0, r3
  200b48:	e59d300c 	ldr	r3, [sp, #12]
  200b4c:	e593301c 	ldr	r3, [r3, #28]
  200b50:	e2833008 	add	r3, r3, #8
  200b54:	e1a01003 	mov	r1, r3
  200b58:	e1a03300 	lsl	r3, r0, #6
  200b5c:	e0823003 	add	r3, r2, r3
  200b60:	e5831060 	str	r1, [r3, #96]	; 0x60
  dmaChannelSetDestination(spip->dmarx, rxbuf);
  200b64:	e59d300c 	ldr	r3, [sp, #12]
  200b68:	e5933020 	ldr	r3, [r3, #32]
  200b6c:	e5931000 	ldr	r1, [r3]
  200b70:	e59d300c 	ldr	r3, [sp, #12]
  200b74:	e5933020 	ldr	r3, [r3, #32]
  200b78:	e5d33004 	ldrb	r3, [r3, #4]
  200b7c:	e59d2000 	ldr	r2, [sp]
  200b80:	e1a03303 	lsl	r3, r3, #6
  200b84:	e0813003 	add	r3, r1, r3
  200b88:	e5832064 	str	r2, [r3, #100]	; 0x64
  dmaChannelSetTransactionSize(spip->dmarx, n);
  200b8c:	e59d300c 	ldr	r3, [sp, #12]
  200b90:	e5933020 	ldr	r3, [r3, #32]
  200b94:	e59d1008 	ldr	r1, [sp, #8]
  200b98:	e1a00003 	mov	r0, r3
  200b9c:	eb000adf 	bl	203720 <dmaChannelSetTransactionSize>

  dmaChannelEnable(spip->dmarx);
  200ba0:	e59d300c 	ldr	r3, [sp, #12]
  200ba4:	e5933020 	ldr	r3, [r3, #32]
  200ba8:	e5933000 	ldr	r3, [r3]
  200bac:	e59d200c 	ldr	r2, [sp, #12]
  200bb0:	e5922020 	ldr	r2, [r2, #32]
  200bb4:	e5922000 	ldr	r2, [r2]
  200bb8:	e592101c 	ldr	r1, [r2, #28]
  200bbc:	e59d200c 	ldr	r2, [sp, #12]
  200bc0:	e5922020 	ldr	r2, [r2, #32]
  200bc4:	e5d22004 	ldrb	r2, [r2, #4]
  200bc8:	e1a00002 	mov	r0, r2
  200bcc:	e3a02001 	mov	r2, #1
  200bd0:	e1a02012 	lsl	r2, r2, r0
  200bd4:	e1812002 	orr	r2, r1, r2
  200bd8:	e583201c 	str	r2, [r3, #28]
  dmaChannelEnable(spip->dmatx);
  200bdc:	e59d300c 	ldr	r3, [sp, #12]
  200be0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  200be4:	e5933000 	ldr	r3, [r3]
  200be8:	e59d200c 	ldr	r2, [sp, #12]
  200bec:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  200bf0:	e5922000 	ldr	r2, [r2]
  200bf4:	e592101c 	ldr	r1, [r2, #28]
  200bf8:	e59d200c 	ldr	r2, [sp, #12]
  200bfc:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  200c00:	e5d22004 	ldrb	r2, [r2, #4]
  200c04:	e1a00002 	mov	r0, r2
  200c08:	e3a02001 	mov	r2, #1
  200c0c:	e1a02012 	lsl	r2, r2, r0
  200c10:	e1812002 	orr	r2, r1, r2
  200c14:	e583201c 	str	r2, [r3, #28]
}
  200c18:	e28dd014 	add	sp, sp, #20
  200c1c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00200c20 <port_lock_from_isr.lto_priv.6>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  200c20:	e12fff1e 	bx	lr
	...

00200c30 <port_unlock_from_isr.lto_priv.4>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  200c30:	e12fff1e 	bx	lr
	...

00200c40 <chSysLockFromISR.lto_priv.2>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  200c40:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  200c44:	ebfffff5 	bl	200c20 <port_lock_from_isr.lto_priv.6>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  200c48:	e8bd8010 	pop	{r4, pc}
  200c4c:	00000000 	andeq	r0, r0, r0

00200c50 <chSysUnlockFromISR.lto_priv.0>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  200c50:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  200c54:	ebfffff5 	bl	200c30 <port_unlock_from_isr.lto_priv.4>
}
  200c58:	e8bd8010 	pop	{r4, pc}
  200c5c:	00000000 	andeq	r0, r0, r0

00200c60 <osalSysLockFromISR.lto_priv.11>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
  200c60:	e92d4010 	push	{r4, lr}

  chSysLockFromISR();
  200c64:	ebfffff5 	bl	200c40 <chSysLockFromISR.lto_priv.2>
}
  200c68:	e8bd8010 	pop	{r4, pc}
  200c6c:	00000000 	andeq	r0, r0, r0

00200c70 <osalSysUnlockFromISR.lto_priv.9>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
  200c70:	e92d4010 	push	{r4, lr}

  chSysUnlockFromISR();
  200c74:	ebfffff5 	bl	200c50 <chSysUnlockFromISR.lto_priv.0>
}
  200c78:	e8bd8010 	pop	{r4, pc}
  200c7c:	00000000 	andeq	r0, r0, r0

00200c80 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
  200c80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200c84:	e24dd00c 	sub	sp, sp, #12
  200c88:	e58d0004 	str	r0, [sp, #4]
  200c8c:	e58d1000 	str	r1, [sp]

  chEvtBroadcastFlagsI(esp, flags);
  200c90:	e59d1000 	ldr	r1, [sp]
  200c94:	e59d0004 	ldr	r0, [sp, #4]
  200c98:	eb0011a0 	bl	205320 <chEvtBroadcastFlagsI>
}
  200c9c:	e28dd00c 	add	sp, sp, #12
  200ca0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00200cb0 <uart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void uart_init(SerialDriver *sdp, const SerialConfig *config) {
  200cb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200cb4:	e24dd014 	sub	sp, sp, #20
  200cb8:	e58d0004 	str	r0, [sp, #4]
  200cbc:	e58d1000 	str	r1, [sp]
#if SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM
  if (sdp->uart != NULL)
#endif /* SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM */
#if SAMA_SERIAL_USE_UART
  {
    Uart *u = sdp->uart;
  200cc0:	e59d3004 	ldr	r3, [sp, #4]
  200cc4:	e5933054 	ldr	r3, [r3, #84]	; 0x54
  200cc8:	e58d300c 	str	r3, [sp, #12]

    /* Disabling write protection */
    sdDisableWP(u);
  200ccc:	e59d200c 	ldr	r2, [sp, #12]
  200cd0:	e3a03c52 	mov	r3, #20992	; 0x5200
  200cd4:	e3453541 	movt	r3, #21825	; 0x5541
  200cd8:	e58230e4 	str	r3, [r2, #228]	; 0xe4
    /* Baud rate setting.*/
    u->UART_BRGR = UART_BRGR_CD(sdp->clock / (16 * config->speed));
  200cdc:	e59d3004 	ldr	r3, [sp, #4]
  200ce0:	e5932060 	ldr	r2, [r3, #96]	; 0x60
  200ce4:	e59d3000 	ldr	r3, [sp]
  200ce8:	e5933000 	ldr	r3, [r3]
  200cec:	e1a03203 	lsl	r3, r3, #4
  200cf0:	e1a01003 	mov	r1, r3
  200cf4:	e1a00002 	mov	r0, r2
  200cf8:	ebfffd8c 	bl	200330 <__aeabi_uidiv>
  200cfc:	e1a03000 	mov	r3, r0
  200d00:	e6ff2073 	uxth	r2, r3
  200d04:	e59d300c 	ldr	r3, [sp, #12]
  200d08:	e5832020 	str	r2, [r3, #32]

    u->UART_CR = config->cr;
  200d0c:	e59d3000 	ldr	r3, [sp]
  200d10:	e5932004 	ldr	r2, [r3, #4]
  200d14:	e59d300c 	ldr	r3, [sp, #12]
  200d18:	e5832000 	str	r2, [r3]
    u->UART_MR = config->mr;
  200d1c:	e59d3000 	ldr	r3, [sp]
  200d20:	e5932008 	ldr	r2, [r3, #8]
  200d24:	e59d300c 	ldr	r3, [sp, #12]
  200d28:	e5832004 	str	r2, [r3, #4]
    u->UART_IER = UART_IER_RXRDY;
  200d2c:	e59d300c 	ldr	r3, [sp, #12]
  200d30:	e3a02001 	mov	r2, #1
  200d34:	e5832008 	str	r2, [r3, #8]

    /* Clearing error status bit */
    u->UART_CR |= UART_CR_RSTSTA;
  200d38:	e59d300c 	ldr	r3, [sp, #12]
  200d3c:	e5933000 	ldr	r3, [r3]
  200d40:	e3832c01 	orr	r2, r3, #256	; 0x100
  200d44:	e59d300c 	ldr	r3, [sp, #12]
  200d48:	e5832000 	str	r2, [r3]
    /* Enabling Tx and Rx */
    u->UART_CR |= UART_CR_RXEN | UART_CR_TXEN;
  200d4c:	e59d300c 	ldr	r3, [sp, #12]
  200d50:	e5933000 	ldr	r3, [r3]
  200d54:	e3832050 	orr	r2, r3, #80	; 0x50
  200d58:	e59d300c 	ldr	r3, [sp, #12]
  200d5c:	e5832000 	str	r2, [r3]
    /* Enabling write protection */
    sdEnableWP(u);
  200d60:	e59d200c 	ldr	r2, [sp, #12]
  200d64:	e3053201 	movw	r3, #20993	; 0x5201
  200d68:	e3453541 	movt	r3, #21825	; 0x5541
  200d6c:	e58230e4 	str	r3, [r2, #228]	; 0xe4
#if SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM
  else {
    osalDbgAssert(FALSE, "invalid state");
  }
#endif /* SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM */
}
  200d70:	e28dd014 	add	sp, sp, #20
  200d74:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00200d80 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  200d80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200d84:	e24dd014 	sub	sp, sp, #20
  200d88:	e58d0004 	str	r0, [sp, #4]
  200d8c:	e58d1000 	str	r1, [sp]
  eventflags_t sts = 0;
  200d90:	e3a03000 	mov	r3, #0
  200d94:	e58d300c 	str	r3, [sp, #12]

  if (isr & (UART_SR_OVRE | US_CSR_OVRE))
  200d98:	e59d3000 	ldr	r3, [sp]
  200d9c:	e2033020 	and	r3, r3, #32
  200da0:	e3530000 	cmp	r3, #0
  200da4:	0a000002 	beq	200db4 <set_error+0x34>
    sts |= SD_OVERRUN_ERROR;
  200da8:	e59d300c 	ldr	r3, [sp, #12]
  200dac:	e3833080 	orr	r3, r3, #128	; 0x80
  200db0:	e58d300c 	str	r3, [sp, #12]
  if (isr & (UART_SR_PARE | US_CSR_PARE))
  200db4:	e59d3000 	ldr	r3, [sp]
  200db8:	e2033080 	and	r3, r3, #128	; 0x80
  200dbc:	e3530000 	cmp	r3, #0
  200dc0:	0a000002 	beq	200dd0 <set_error+0x50>
    sts |= SD_PARITY_ERROR;
  200dc4:	e59d300c 	ldr	r3, [sp, #12]
  200dc8:	e3833020 	orr	r3, r3, #32
  200dcc:	e58d300c 	str	r3, [sp, #12]
  if (isr & (UART_SR_FRAME | US_CSR_FRAME))
  200dd0:	e59d3000 	ldr	r3, [sp]
  200dd4:	e2033040 	and	r3, r3, #64	; 0x40
  200dd8:	e3530000 	cmp	r3, #0
  200ddc:	0a000002 	beq	200dec <set_error+0x6c>
    sts |= UART_SR_FRAME;
  200de0:	e59d300c 	ldr	r3, [sp, #12]
  200de4:	e3833040 	orr	r3, r3, #64	; 0x40
  200de8:	e58d300c 	str	r3, [sp, #12]
  osalSysLockFromISR();
  200dec:	ebffff9b 	bl	200c60 <osalSysLockFromISR.lto_priv.11>
  chnAddFlagsI(sdp, sts);
  200df0:	e59d3004 	ldr	r3, [sp, #4]
  200df4:	e2833004 	add	r3, r3, #4
  200df8:	e59d100c 	ldr	r1, [sp, #12]
  200dfc:	e1a00003 	mov	r0, r3
  200e00:	ebffff9e 	bl	200c80 <osalEventBroadcastFlagsI>
  osalSysUnlockFromISR();
  200e04:	ebffff99 	bl	200c70 <osalSysUnlockFromISR.lto_priv.9>
}
  200e08:	e28dd014 	add	sp, sp, #20
  200e0c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00200e10 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the UART
 */
static void serve_interrupt(SerialDriver *sdp) {
  200e10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200e14:	e24dd01c 	sub	sp, sp, #28
  200e18:	e58d0004 	str	r0, [sp, #4]
  Uart *u = sdp->uart;
  200e1c:	e59d3004 	ldr	r3, [sp, #4]
  200e20:	e5933054 	ldr	r3, [r3, #84]	; 0x54
  200e24:	e58d3014 	str	r3, [sp, #20]
  uint32_t imr = u->UART_IMR;
  200e28:	e59d3014 	ldr	r3, [sp, #20]
  200e2c:	e5933010 	ldr	r3, [r3, #16]
  200e30:	e58d3010 	str	r3, [sp, #16]
  uint32_t sr;

  /* Reading and clearing status.*/
  sr = u->UART_SR;
  200e34:	e59d3014 	ldr	r3, [sp, #20]
  200e38:	e5933014 	ldr	r3, [r3, #20]
  200e3c:	e58d300c 	str	r3, [sp, #12]
  u->UART_CR |= UART_CR_RSTSTA;
  200e40:	e59d3014 	ldr	r3, [sp, #20]
  200e44:	e5933000 	ldr	r3, [r3]
  200e48:	e3832c01 	orr	r2, r3, #256	; 0x100
  200e4c:	e59d3014 	ldr	r3, [sp, #20]
  200e50:	e5832000 	str	r2, [r3]

  /* Error condition detection.*/
  if (sr & (UART_SR_OVRE | UART_SR_FRAME  | UART_SR_PARE)){
  200e54:	e59d300c 	ldr	r3, [sp, #12]
  200e58:	e20330e0 	and	r3, r3, #224	; 0xe0
  200e5c:	e3530000 	cmp	r3, #0
  200e60:	0a000002 	beq	200e70 <serve_interrupt+0x60>
    set_error(sdp, sr);
  200e64:	e59d100c 	ldr	r1, [sp, #12]
  200e68:	e59d0004 	ldr	r0, [sp, #4]
  200e6c:	ebffffc3 	bl	200d80 <set_error>
  }

  /* Data available.*/
  if (sr & UART_SR_RXRDY) {
  200e70:	e59d300c 	ldr	r3, [sp, #12]
  200e74:	e2033001 	and	r3, r3, #1
  200e78:	e3530000 	cmp	r3, #0
  200e7c:	0a000007 	beq	200ea0 <serve_interrupt+0x90>
    osalSysLockFromISR();
  200e80:	ebffff76 	bl	200c60 <osalSysLockFromISR.lto_priv.11>
    sdIncomingDataI(sdp, (uint8_t)u->UART_RHR);
  200e84:	e59d3014 	ldr	r3, [sp, #20]
  200e88:	e5933018 	ldr	r3, [r3, #24]
  200e8c:	e6ef3073 	uxtb	r3, r3
  200e90:	e1a01003 	mov	r1, r3
  200e94:	e59d0004 	ldr	r0, [sp, #4]
  200e98:	eb000714 	bl	202af0 <sdIncomingDataI>
    osalSysUnlockFromISR();
  200e9c:	ebffff73 	bl	200c70 <osalSysUnlockFromISR.lto_priv.9>
  }

  /* Transmission buffer empty.*/
  if ((imr & UART_IMR_TXRDY) && (sr & UART_SR_TXRDY)) {
  200ea0:	e59d3010 	ldr	r3, [sp, #16]
  200ea4:	e2033002 	and	r3, r3, #2
  200ea8:	e3530000 	cmp	r3, #0
  200eac:	0a00001e 	beq	200f2c <serve_interrupt+0x11c>
  200eb0:	e59d300c 	ldr	r3, [sp, #12]
  200eb4:	e2033002 	and	r3, r3, #2
  200eb8:	e3530000 	cmp	r3, #0
  200ebc:	0a00001a 	beq	200f2c <serve_interrupt+0x11c>
    msg_t b;
    osalSysLockFromISR();
  200ec0:	ebffff66 	bl	200c60 <osalSysLockFromISR.lto_priv.11>
    b = oqGetI(&sdp->oqueue);
  200ec4:	e59d3004 	ldr	r3, [sp, #4]
  200ec8:	e2833030 	add	r3, r3, #48	; 0x30
  200ecc:	e1a00003 	mov	r0, r3
  200ed0:	eb000586 	bl	2024f0 <oqGetI>
  200ed4:	e58d0008 	str	r0, [sp, #8]
    if (b < MSG_OK) {
  200ed8:	e59d3008 	ldr	r3, [sp, #8]
  200edc:	e3530000 	cmp	r3, #0
  200ee0:	aa00000d 	bge	200f1c <serve_interrupt+0x10c>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  200ee4:	e59d3004 	ldr	r3, [sp, #4]
  200ee8:	e2833004 	add	r3, r3, #4
  200eec:	e3a01008 	mov	r1, #8
  200ef0:	e1a00003 	mov	r0, r3
  200ef4:	ebffff61 	bl	200c80 <osalEventBroadcastFlagsI>
      u->UART_IDR |= UART_IDR_TXRDY;
  200ef8:	e59d3014 	ldr	r3, [sp, #20]
  200efc:	e593300c 	ldr	r3, [r3, #12]
  200f00:	e3832002 	orr	r2, r3, #2
  200f04:	e59d3014 	ldr	r3, [sp, #20]
  200f08:	e583200c 	str	r2, [r3, #12]
      u->UART_IER = UART_IER_TXEMPTY;
  200f0c:	e59d3014 	ldr	r3, [sp, #20]
  200f10:	e3a02c02 	mov	r2, #512	; 0x200
  200f14:	e5832008 	str	r2, [r3, #8]
  200f18:	ea000002 	b	200f28 <serve_interrupt+0x118>
    }
    else
      u->UART_THR = b;
  200f1c:	e59d2008 	ldr	r2, [sp, #8]
  200f20:	e59d3014 	ldr	r3, [sp, #20]
  200f24:	e583201c 	str	r2, [r3, #28]
    osalSysUnlockFromISR();
  200f28:	ebffff50 	bl	200c70 <osalSysUnlockFromISR.lto_priv.9>
  }

  /* Physical transmission end.*/
  if ((imr & UART_IMR_TXEMPTY) && (sr & (UART_SR_TXRDY | UART_SR_TXEMPTY))) {
  200f2c:	e59d3010 	ldr	r3, [sp, #16]
  200f30:	e2033c02 	and	r3, r3, #512	; 0x200
  200f34:	e3530000 	cmp	r3, #0
  200f38:	0a000021 	beq	200fc4 <serve_interrupt+0x1b4>
  200f3c:	e59d200c 	ldr	r2, [sp, #12]
  200f40:	e3003202 	movw	r3, #514	; 0x202
  200f44:	e0033002 	and	r3, r3, r2
  200f48:	e3530000 	cmp	r3, #0
  200f4c:	0a00001c 	beq	200fc4 <serve_interrupt+0x1b4>
    osalSysLockFromISR();
  200f50:	ebffff42 	bl	200c60 <osalSysLockFromISR.lto_priv.11>
    if (oqIsEmptyI(&sdp->oqueue))
  200f54:	e59d3004 	ldr	r3, [sp, #4]
  200f58:	e5932044 	ldr	r2, [r3, #68]	; 0x44
  200f5c:	e59d3004 	ldr	r3, [sp, #4]
  200f60:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  200f64:	e1520003 	cmp	r2, r3
  200f68:	1a000005 	bne	200f84 <serve_interrupt+0x174>
  200f6c:	e59d3004 	ldr	r3, [sp, #4]
  200f70:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  200f74:	e3530000 	cmp	r3, #0
  200f78:	0a000001 	beq	200f84 <serve_interrupt+0x174>
  200f7c:	e3a03001 	mov	r3, #1
  200f80:	ea000000 	b	200f88 <serve_interrupt+0x178>
  200f84:	e3a03000 	mov	r3, #0
  200f88:	e2033001 	and	r3, r3, #1
  200f8c:	e3530000 	cmp	r3, #0
  200f90:	0a000004 	beq	200fa8 <serve_interrupt+0x198>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
  200f94:	e59d3004 	ldr	r3, [sp, #4]
  200f98:	e2833004 	add	r3, r3, #4
  200f9c:	e3a01010 	mov	r1, #16
  200fa0:	e1a00003 	mov	r0, r3
  200fa4:	ebffff35 	bl	200c80 <osalEventBroadcastFlagsI>
    u->UART_IDR |= UART_IDR_TXRDY | UART_IDR_TXEMPTY;
  200fa8:	e59d3014 	ldr	r3, [sp, #20]
  200fac:	e593300c 	ldr	r3, [r3, #12]
  200fb0:	e3833c02 	orr	r3, r3, #512	; 0x200
  200fb4:	e3833002 	orr	r3, r3, #2
  200fb8:	e59d2014 	ldr	r2, [sp, #20]
  200fbc:	e582300c 	str	r3, [r2, #12]
    osalSysUnlockFromISR();
  200fc0:	ebffff2a 	bl	200c70 <osalSysUnlockFromISR.lto_priv.9>
  }
}
  200fc4:	e28dd01c 	add	sp, sp, #28
  200fc8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  200fcc:	00000000 	andeq	r0, r0, r0

00200fd0 <notify0>:
  }
}
#endif

#if SAMA_SERIAL_USE_UART0 || defined(__DOXYGEN__)
static void notify0(io_queue_t *qp) {
  200fd0:	e24dd008 	sub	sp, sp, #8
  200fd4:	e58d0004 	str	r0, [sp, #4]

  (void)qp;
  UART0->UART_IER |= UART_IER_TXRDY;
  200fd8:	e3a03903 	mov	r3, #49152	; 0xc000
  200fdc:	e34f3801 	movt	r3, #63489	; 0xf801
  200fe0:	e3a02903 	mov	r2, #49152	; 0xc000
  200fe4:	e34f2801 	movt	r2, #63489	; 0xf801
  200fe8:	e5922008 	ldr	r2, [r2, #8]
  200fec:	e3822002 	orr	r2, r2, #2
  200ff0:	e5832008 	str	r2, [r3, #8]
}
  200ff4:	e28dd008 	add	sp, sp, #8
  200ff8:	e12fff1e 	bx	lr
  200ffc:	00000000 	andeq	r0, r0, r0

00201000 <SAMA_UART0_HANDLER>:
/**
 * @brief   UART0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SAMA_UART0_HANDLER) {
  201000:	e92d4010 	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD0);
  201004:	e3000c08 	movw	r0, #3080	; 0xc08
  201008:	e3400021 	movt	r0, #33	; 0x21
  20100c:	ebffff7f 	bl	200e10 <serve_interrupt>
  aicAckInt();
  201010:	e3a03903 	mov	r3, #49152	; 0xc000
  201014:	e34f3803 	movt	r3, #63491	; 0xf803
  201018:	e3a02001 	mov	r2, #1
  20101c:	e5832038 	str	r2, [r3, #56]	; 0x38
  OSAL_IRQ_EPILOGUE();
  201020:	eb000e9a 	bl	204a90 <chSchIsPreemptionRequired>
  201024:	e1a03000 	mov	r3, r0
}
  201028:	e1a00003 	mov	r0, r3
  20102c:	e8bd8010 	pop	{r4, pc}

00201030 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
  201030:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201034:	e24dd00c 	sub	sp, sp, #12

#if SAMA_SERIAL_USE_UART0
  sdObjectInit(&SD0);
  201038:	e3000c08 	movw	r0, #3080	; 0xc08
  20103c:	e3400021 	movt	r0, #33	; 0x21
  201040:	eb00068a 	bl	202a70 <sdObjectInit>
  iqObjectInit(&SD0.iqueue, sd_in_buf0, sizeof sd_in_buf0, NULL, &SD0);
  201044:	e3003c08 	movw	r3, #3080	; 0xc08
  201048:	e3403021 	movt	r3, #33	; 0x21
  20104c:	e58d3000 	str	r3, [sp]
  201050:	e3a03000 	mov	r3, #0
  201054:	e3a02010 	mov	r2, #16
  201058:	e3001c6c 	movw	r1, #3180	; 0xc6c
  20105c:	e3401021 	movt	r1, #33	; 0x21
  201060:	e3000c14 	movw	r0, #3092	; 0xc14
  201064:	e3400021 	movt	r0, #33	; 0x21
  201068:	eb000b28 	bl	203d10 <iqObjectInit>
  oqObjectInit(&SD0.oqueue, sd_out_buf0, sizeof sd_out_buf0, notify0, &SD0);
  20106c:	e3003c08 	movw	r3, #3080	; 0xc08
  201070:	e3403021 	movt	r3, #33	; 0x21
  201074:	e58d3000 	str	r3, [sp]
  201078:	e3003fd0 	movw	r3, #4048	; 0xfd0
  20107c:	e3403020 	movt	r3, #32
  201080:	e3a02010 	mov	r2, #16
  201084:	e3001c7c 	movw	r1, #3196	; 0xc7c
  201088:	e3401021 	movt	r1, #33	; 0x21
  20108c:	e3000c38 	movw	r0, #3128	; 0xc38
  201090:	e3400021 	movt	r0, #33	; 0x21
  201094:	eb0004b5 	bl	202370 <oqObjectInit>
  SD0.uart = UART0;
  201098:	e3002c08 	movw	r2, #3080	; 0xc08
  20109c:	e3402021 	movt	r2, #33	; 0x21
  2010a0:	e3a03903 	mov	r3, #49152	; 0xc000
  2010a4:	e34f3801 	movt	r3, #63489	; 0xf801
  2010a8:	e5823054 	str	r3, [r2, #84]	; 0x54
  SD0.clock = SAMA_UART0CLK;
  2010ac:	e3002c08 	movw	r2, #3080	; 0xc08
  2010b0:	e3402021 	movt	r2, #33	; 0x21
  2010b4:	e3073ac0 	movw	r3, #31424	; 0x7ac0
  2010b8:	e34034f2 	movt	r3, #1266	; 0x4f2
  2010bc:	e5823060 	str	r3, [r2, #96]	; 0x60

  aicSetSourcePriority(ID_UART0, SAMA_SERIAL_UART0_IRQ_PRIORITY);
  2010c0:	e3a01004 	mov	r1, #4
  2010c4:	e3a00018 	mov	r0, #24
  2010c8:	eb000884 	bl	2032e0 <aicSetSourcePriority>
  aicSetSourceHandler(ID_UART0, SAMA_UART0_HANDLER);
  2010cc:	e3011000 	movw	r1, #4096	; 0x1000
  2010d0:	e3401020 	movt	r1, #32
  2010d4:	e3a00018 	mov	r0, #24
  2010d8:	eb0008a0 	bl	203360 <aicSetSourceHandler>
  aicEnableInt(ID_UART0);
  2010dc:	e3a00018 	mov	r0, #24
  2010e0:	eb0008b6 	bl	2033c0 <aicEnableInt>

  aicSetSourcePriority(ID_USART4, SAMA_SERIAL_FLEXCOM4_IRQ_PRIORITY);
  aicSetSourceHandler(ID_USART4, SAMA_SERIAL_FLEXCOM4_HANDLER);
  aicEnableInt(ID_USART4);
#endif
}
  2010e4:	e28dd00c 	add	sp, sp, #12
  2010e8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2010ec:	00000000 	andeq	r0, r0, r0

002010f0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
  2010f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2010f4:	e24dd00c 	sub	sp, sp, #12
  2010f8:	e58d0004 	str	r0, [sp, #4]
  2010fc:	e58d1000 	str	r1, [sp]

  if (config == NULL) {
  201100:	e59d3000 	ldr	r3, [sp]
  201104:	e3530000 	cmp	r3, #0
  201108:	1a000002 	bne	201118 <sd_lld_start+0x28>

    config = &default_config;
  20110c:	e3053550 	movw	r3, #21840	; 0x5550
  201110:	e3403020 	movt	r3, #32
  201114:	e58d3000 	str	r3, [sp]
  }
  if (sdp->state == SD_STOP) {
  201118:	e59d3004 	ldr	r3, [sp, #4]
  20111c:	e5d33008 	ldrb	r3, [r3, #8]
  201120:	e3530001 	cmp	r3, #1
  201124:	1a000015 	bne	201180 <sd_lld_start+0x90>
#if SAMA_SERIAL_USE_UART0
    if (&SD0 == sdp) {
  201128:	e59d2004 	ldr	r2, [sp, #4]
  20112c:	e3003c08 	movw	r3, #3080	; 0xc08
  201130:	e3403021 	movt	r3, #33	; 0x21
  201134:	e1520003 	cmp	r2, r3
  201138:	1a000010 	bne	201180 <sd_lld_start+0x90>
      pmcEnableUART0();
  20113c:	e3a03901 	mov	r3, #16384	; 0x4000
  201140:	e34f3001 	movt	r3, #61441	; 0xf001
  201144:	e3a02c43 	mov	r2, #17152	; 0x4300
  201148:	e345204d 	movt	r2, #20557	; 0x504d
  20114c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  201150:	e3a03901 	mov	r3, #16384	; 0x4000
  201154:	e34f3001 	movt	r3, #61441	; 0xf001
  201158:	e3a02901 	mov	r2, #16384	; 0x4000
  20115c:	e34f2001 	movt	r2, #61441	; 0xf001
  201160:	e5922010 	ldr	r2, [r2, #16]
  201164:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
  201168:	e5832010 	str	r2, [r3, #16]
  20116c:	e3a03901 	mov	r3, #16384	; 0x4000
  201170:	e34f3001 	movt	r3, #61441	; 0xf001
  201174:	e3042301 	movw	r2, #17153	; 0x4301
  201178:	e345204d 	movt	r2, #20557	; 0x504d
  20117c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
    if (&FSD4 == sdp) {
      pmcEnableFLEXCOM4();
    }
#endif
  }
  uart_init(sdp, config);
  201180:	e59d1000 	ldr	r1, [sp]
  201184:	e59d0004 	ldr	r0, [sp, #4]
  201188:	ebfffec8 	bl	200cb0 <uart_init>
}
  20118c:	e28dd00c 	add	sp, sp, #12
  201190:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002011a0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
  2011a0:	e92d4010 	push	{r4, lr}

  sama_clock_init();
  2011a4:	eb00070d 	bl	202de0 <sama_clock_init>
}
  2011a8:	e8bd8010 	pop	{r4, pc}
  2011ac:	00000000 	andeq	r0, r0, r0

002011b0 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 */
void boardInit(void) {
  2011b0:	e24dd008 	sub	sp, sp, #8
  unsigned i;

#if SAMA_HAL_IS_SECURE
  /* Disabling PMC write protection. */
  pmcDisableWP();
  2011b4:	e3a03901 	mov	r3, #16384	; 0x4000
  2011b8:	e34f3001 	movt	r3, #61441	; 0xf001
  2011bc:	e3a02c43 	mov	r2, #17152	; 0x4300
  2011c0:	e345204d 	movt	r2, #20557	; 0x504d
  2011c4:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling port clock. */
  pmcEnablePIO();
  2011c8:	e3a03901 	mov	r3, #16384	; 0x4000
  2011cc:	e34f3001 	movt	r3, #61441	; 0xf001
  2011d0:	e3a02c43 	mov	r2, #17152	; 0x4300
  2011d4:	e345204d 	movt	r2, #20557	; 0x504d
  2011d8:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  2011dc:	e3a03901 	mov	r3, #16384	; 0x4000
  2011e0:	e34f3001 	movt	r3, #61441	; 0xf001
  2011e4:	e3a02901 	mov	r2, #16384	; 0x4000
  2011e8:	e34f2001 	movt	r2, #61441	; 0xf001
  2011ec:	e5922010 	ldr	r2, [r2, #16]
  2011f0:	e3822701 	orr	r2, r2, #262144	; 0x40000
  2011f4:	e5832010 	str	r2, [r3, #16]
  2011f8:	e3a03901 	mov	r3, #16384	; 0x4000
  2011fc:	e34f3001 	movt	r3, #61441	; 0xf001
  201200:	e3042301 	movw	r2, #17153	; 0x4301
  201204:	e345204d 	movt	r2, #20557	; 0x504d
  201208:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling write protection.  */
  pmcEnableWP();
  20120c:	e3a03901 	mov	r3, #16384	; 0x4000
  201210:	e34f3001 	movt	r3, #61441	; 0xf001
  201214:	e3042301 	movw	r2, #17153	; 0x4301
  201218:	e345204d 	movt	r2, #20557	; 0x504d
  20121c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
#endif /* SAMA_HAL_IS_SECURE */

  /* Configuring all PIO A pads with default configuration.  */
#if SAMA_HAS_PIOA
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  201220:	e3a03902 	mov	r3, #32768	; 0x8000
  201224:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201228:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20122c:	e1a02003 	mov	r2, r3
  201230:	e3a03000 	mov	r3, #0
  201234:	e5823034 	str	r3, [r2, #52]	; 0x34
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  201238:	e3a03902 	mov	r3, #32768	; 0x8000
  20123c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201240:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201244:	e1a02003 	mov	r2, r3
  201248:	e3e03000 	mvn	r3, #0
  20124c:	e5823030 	str	r3, [r2, #48]	; 0x30
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  201250:	e3a03902 	mov	r3, #32768	; 0x8000
  201254:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201258:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20125c:	e1a02003 	mov	r2, r3
  201260:	e3e03000 	mvn	r3, #0
  201264:	e5823000 	str	r3, [r2]
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  201268:	e3a03902 	mov	r3, #32768	; 0x8000
  20126c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201270:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201274:	e1a02003 	mov	r2, r3
  201278:	e3a03c82 	mov	r3, #33280	; 0x8200
  20127c:	e5823004 	str	r3, [r2, #4]
#endif /* SAMA_HAS_PIOA */

  /* Configuring all PIO B pads with default configuration.  */
#if SAMA_HAS_PIOB
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  201280:	e3a03902 	mov	r3, #32768	; 0x8000
  201284:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201288:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20128c:	e1a02003 	mov	r2, r3
  201290:	e3a03000 	mov	r3, #0
  201294:	e5823074 	str	r3, [r2, #116]	; 0x74
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  201298:	e3a03902 	mov	r3, #32768	; 0x8000
  20129c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2012a0:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2012a4:	e1a02003 	mov	r2, r3
  2012a8:	e3e03000 	mvn	r3, #0
  2012ac:	e5823070 	str	r3, [r2, #112]	; 0x70
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  2012b0:	e3a03902 	mov	r3, #32768	; 0x8000
  2012b4:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2012b8:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2012bc:	e1a02003 	mov	r2, r3
  2012c0:	e3e03000 	mvn	r3, #0
  2012c4:	e5823040 	str	r3, [r2, #64]	; 0x40
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  2012c8:	e3a03902 	mov	r3, #32768	; 0x8000
  2012cc:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2012d0:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2012d4:	e1a02003 	mov	r2, r3
  2012d8:	e3a03c82 	mov	r3, #33280	; 0x8200
  2012dc:	e5823044 	str	r3, [r2, #68]	; 0x44
#endif /* SAMA_HAS_PIOB */

  /* Configuring all PIO C pads with default configuration.  */
#if SAMA_HAS_PIOC
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  2012e0:	e3a03902 	mov	r3, #32768	; 0x8000
  2012e4:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2012e8:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2012ec:	e1a02003 	mov	r2, r3
  2012f0:	e3a03000 	mov	r3, #0
  2012f4:	e58230b4 	str	r3, [r2, #180]	; 0xb4
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  2012f8:	e3a03902 	mov	r3, #32768	; 0x8000
  2012fc:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201300:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201304:	e1a02003 	mov	r2, r3
  201308:	e3e03000 	mvn	r3, #0
  20130c:	e58230b0 	str	r3, [r2, #176]	; 0xb0
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  201310:	e3a03902 	mov	r3, #32768	; 0x8000
  201314:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201318:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20131c:	e1a02003 	mov	r2, r3
  201320:	e3e03000 	mvn	r3, #0
  201324:	e5823080 	str	r3, [r2, #128]	; 0x80
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  201328:	e3a03902 	mov	r3, #32768	; 0x8000
  20132c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201330:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201334:	e1a02003 	mov	r2, r3
  201338:	e3a03c82 	mov	r3, #33280	; 0x8200
  20133c:	e5823084 	str	r3, [r2, #132]	; 0x84
#endif /* SAMA_HAS_PIOC */

  /* Configuring all PIO D pads with default configuration.  */
#if SAMA_HAS_PIOD
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  201340:	e3a03902 	mov	r3, #32768	; 0x8000
  201344:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201348:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20134c:	e1a02003 	mov	r2, r3
  201350:	e3a03000 	mov	r3, #0
  201354:	e58230f4 	str	r3, [r2, #244]	; 0xf4
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  201358:	e3a03902 	mov	r3, #32768	; 0x8000
  20135c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201360:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201364:	e1a02003 	mov	r2, r3
  201368:	e3e03000 	mvn	r3, #0
  20136c:	e58230f0 	str	r3, [r2, #240]	; 0xf0
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  201370:	e3a03902 	mov	r3, #32768	; 0x8000
  201374:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201378:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20137c:	e1a02003 	mov	r2, r3
  201380:	e3e03000 	mvn	r3, #0
  201384:	e58230c0 	str	r3, [r2, #192]	; 0xc0
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  201388:	e3a03902 	mov	r3, #32768	; 0x8000
  20138c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201390:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201394:	e1a02003 	mov	r2, r3
  201398:	e3a03c82 	mov	r3, #33280	; 0x8200
  20139c:	e58230c4 	str	r3, [r2, #196]	; 0xc4
#endif /* SAMA_HAS_PIOD */

  /* Initialize PIO registers for defined pads.*/
  i = 0;
  2013a0:	e3a03000 	mov	r3, #0
  2013a4:	e58d3004 	str	r3, [sp, #4]
  2013a8:	ea00005c 	b	201520 <boardInit+0x370>
  while (sama_inits[i].pio_id != -1) {
#if SAMA_HAL_IS_SECURE
    _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_SIOSR = sama_inits[i].pio_msk;
  2013ac:	e3a02902 	mov	r2, #32768	; 0x8000
  2013b0:	e34f2c03 	movt	r2, #64515	; 0xfc03
  2013b4:	e3053560 	movw	r3, #21856	; 0x5560
  2013b8:	e3403020 	movt	r3, #32
  2013bc:	e59d1004 	ldr	r1, [sp, #4]
  2013c0:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  2013c4:	e3051560 	movw	r1, #21856	; 0x5560
  2013c8:	e3401020 	movt	r1, #32
  2013cc:	e59d3004 	ldr	r3, [sp, #4]
  2013d0:	e1a03203 	lsl	r3, r3, #4
  2013d4:	e0813003 	add	r3, r1, r3
  2013d8:	e5931004 	ldr	r1, [r3, #4]
  2013dc:	e1a03300 	lsl	r3, r0, #6
  2013e0:	e0823003 	add	r3, r2, r3
  2013e4:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2013e8:	e2833034 	add	r3, r3, #52	; 0x34
  2013ec:	e5831000 	str	r1, [r3]
    _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_MSKR = sama_inits[i].pio_msk;
  2013f0:	e3a02902 	mov	r2, #32768	; 0x8000
  2013f4:	e34f2c03 	movt	r2, #64515	; 0xfc03
  2013f8:	e3053560 	movw	r3, #21856	; 0x5560
  2013fc:	e3403020 	movt	r3, #32
  201400:	e59d1004 	ldr	r1, [sp, #4]
  201404:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  201408:	e3051560 	movw	r1, #21856	; 0x5560
  20140c:	e3401020 	movt	r1, #32
  201410:	e59d3004 	ldr	r3, [sp, #4]
  201414:	e1a03203 	lsl	r3, r3, #4
  201418:	e0813003 	add	r3, r1, r3
  20141c:	e5931004 	ldr	r1, [r3, #4]
  201420:	e2803040 	add	r3, r0, #64	; 0x40
  201424:	e7821303 	str	r1, [r2, r3, lsl #6]
    _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_CFGR = sama_inits[i].pio_cfg;
  201428:	e3a02902 	mov	r2, #32768	; 0x8000
  20142c:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201430:	e3053560 	movw	r3, #21856	; 0x5560
  201434:	e3403020 	movt	r3, #32
  201438:	e59d1004 	ldr	r1, [sp, #4]
  20143c:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  201440:	e3051560 	movw	r1, #21856	; 0x5560
  201444:	e3401020 	movt	r1, #32
  201448:	e59d3004 	ldr	r3, [sp, #4]
  20144c:	e1a03203 	lsl	r3, r3, #4
  201450:	e0813003 	add	r3, r1, r3
  201454:	e5931008 	ldr	r1, [r3, #8]
  201458:	e2803040 	add	r3, r0, #64	; 0x40
  20145c:	e1a03303 	lsl	r3, r3, #6
  201460:	e0823003 	add	r3, r2, r3
  201464:	e5831004 	str	r1, [r3, #4]
    if(sama_inits[i].pio_ods == SAMA_PIO_HIGH) {
  201468:	e3052560 	movw	r2, #21856	; 0x5560
  20146c:	e3402020 	movt	r2, #32
  201470:	e59d3004 	ldr	r3, [sp, #4]
  201474:	e1a03203 	lsl	r3, r3, #4
  201478:	e0823003 	add	r3, r2, r3
  20147c:	e593300c 	ldr	r3, [r3, #12]
  201480:	e3530001 	cmp	r3, #1
  201484:	1a000011 	bne	2014d0 <boardInit+0x320>
      _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_SODR = sama_inits[i].pio_msk;
  201488:	e3a02902 	mov	r2, #32768	; 0x8000
  20148c:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201490:	e3053560 	movw	r3, #21856	; 0x5560
  201494:	e3403020 	movt	r3, #32
  201498:	e59d1004 	ldr	r1, [sp, #4]
  20149c:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  2014a0:	e3051560 	movw	r1, #21856	; 0x5560
  2014a4:	e3401020 	movt	r1, #32
  2014a8:	e59d3004 	ldr	r3, [sp, #4]
  2014ac:	e1a03203 	lsl	r3, r3, #4
  2014b0:	e0813003 	add	r3, r1, r3
  2014b4:	e5931004 	ldr	r1, [r3, #4]
  2014b8:	e1a03300 	lsl	r3, r0, #6
  2014bc:	e0823003 	add	r3, r2, r3
  2014c0:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2014c4:	e2833010 	add	r3, r3, #16
  2014c8:	e5831000 	str	r1, [r3]
  2014cc:	ea000010 	b	201514 <boardInit+0x364>
    }
    else {
      _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_CODR = sama_inits[i].pio_msk;
  2014d0:	e3a02902 	mov	r2, #32768	; 0x8000
  2014d4:	e34f2c03 	movt	r2, #64515	; 0xfc03
  2014d8:	e3053560 	movw	r3, #21856	; 0x5560
  2014dc:	e3403020 	movt	r3, #32
  2014e0:	e59d1004 	ldr	r1, [sp, #4]
  2014e4:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  2014e8:	e3051560 	movw	r1, #21856	; 0x5560
  2014ec:	e3401020 	movt	r1, #32
  2014f0:	e59d3004 	ldr	r3, [sp, #4]
  2014f4:	e1a03203 	lsl	r3, r3, #4
  2014f8:	e0813003 	add	r3, r1, r3
  2014fc:	e5931004 	ldr	r1, [r3, #4]
  201500:	e1a03300 	lsl	r3, r0, #6
  201504:	e0823003 	add	r3, r2, r3
  201508:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20150c:	e2833014 	add	r3, r3, #20
  201510:	e5831000 	str	r1, [r3]
    }
    else {
      _PIOA->PIO_IO_GROUP[sama_inits[i].pio_id].PIO_CODR = sama_inits[i].pio_msk;
    }
#endif /* SAMA_HAL_IS_SECURE */
    i++;
  201514:	e59d3004 	ldr	r3, [sp, #4]
  201518:	e2833001 	add	r3, r3, #1
  20151c:	e58d3004 	str	r3, [sp, #4]
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
#endif /* SAMA_HAS_PIOD */

  /* Initialize PIO registers for defined pads.*/
  i = 0;
  while (sama_inits[i].pio_id != -1) {
  201520:	e3053560 	movw	r3, #21856	; 0x5560
  201524:	e3403020 	movt	r3, #32
  201528:	e59d2004 	ldr	r2, [sp, #4]
  20152c:	e7933202 	ldr	r3, [r3, r2, lsl #4]
  201530:	e3730001 	cmn	r3, #1
  201534:	1affff9c 	bne	2013ac <boardInit+0x1fc>
      _PIOA->PIO_IO_GROUP[sama_inits[i].pio_id].PIO_CODR = sama_inits[i].pio_msk;
    }
#endif /* SAMA_HAL_IS_SECURE */
    i++;
  }
}
  201538:	e28dd008 	add	sp, sp, #8
  20153c:	e12fff1e 	bx	lr

00201540 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
  201540:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201544:	e24dd024 	sub	sp, sp, #36	; 0x24
  201548:	e58d000c 	str	r0, [sp, #12]
  20154c:	e58d1008 	str	r1, [sp, #8]
  201550:	e58d2004 	str	r2, [sp, #4]
  201554:	e58d3000 	str	r3, [sp]
  int i;
  char *q;
  long l, ll;

  l = num;
  201558:	e59d3008 	ldr	r3, [sp, #8]
  20155c:	e58d3014 	str	r3, [sp, #20]
  if (divisor == 0) {
  201560:	e59d3000 	ldr	r3, [sp]
  201564:	e3530000 	cmp	r3, #0
  201568:	1a000002 	bne	201578 <long_to_string_with_divisor+0x38>
    ll = num;
  20156c:	e59d3008 	ldr	r3, [sp, #8]
  201570:	e58d3010 	str	r3, [sp, #16]
  201574:	ea000001 	b	201580 <long_to_string_with_divisor+0x40>
  } else {
    ll = divisor;
  201578:	e59d3000 	ldr	r3, [sp]
  20157c:	e58d3010 	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
  201580:	e59d300c 	ldr	r3, [sp, #12]
  201584:	e283300b 	add	r3, r3, #11
  201588:	e58d3018 	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
  20158c:	e59d3014 	ldr	r3, [sp, #20]
  201590:	e59d1004 	ldr	r1, [sp, #4]
  201594:	e1a00003 	mov	r0, r3
  201598:	ebfffbdf 	bl	20051c <__aeabi_uidivmod>
  20159c:	e1a03001 	mov	r3, r1
  2015a0:	e58d301c 	str	r3, [sp, #28]
    i += '0';
  2015a4:	e59d301c 	ldr	r3, [sp, #28]
  2015a8:	e2833030 	add	r3, r3, #48	; 0x30
  2015ac:	e58d301c 	str	r3, [sp, #28]
    if (i > '9')
  2015b0:	e59d301c 	ldr	r3, [sp, #28]
  2015b4:	e3530039 	cmp	r3, #57	; 0x39
  2015b8:	da000002 	ble	2015c8 <long_to_string_with_divisor+0x88>
      i += 'A' - '0' - 10;
  2015bc:	e59d301c 	ldr	r3, [sp, #28]
  2015c0:	e2833007 	add	r3, r3, #7
  2015c4:	e58d301c 	str	r3, [sp, #28]
    *--q = i;
  2015c8:	e59d3018 	ldr	r3, [sp, #24]
  2015cc:	e2433001 	sub	r3, r3, #1
  2015d0:	e58d3018 	str	r3, [sp, #24]
  2015d4:	e59d301c 	ldr	r3, [sp, #28]
  2015d8:	e6ef2073 	uxtb	r2, r3
  2015dc:	e59d3018 	ldr	r3, [sp, #24]
  2015e0:	e5c32000 	strb	r2, [r3]
    l /= radix;
  2015e4:	e59d3014 	ldr	r3, [sp, #20]
  2015e8:	e59d1004 	ldr	r1, [sp, #4]
  2015ec:	e1a00003 	mov	r0, r3
  2015f0:	ebfffb4e 	bl	200330 <__aeabi_uidiv>
  2015f4:	e1a03000 	mov	r3, r0
  2015f8:	e58d3014 	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
  2015fc:	e59d3010 	ldr	r3, [sp, #16]
  201600:	e59d1004 	ldr	r1, [sp, #4]
  201604:	e1a00003 	mov	r0, r3
  201608:	ebfffb48 	bl	200330 <__aeabi_uidiv>
  20160c:	e1a03000 	mov	r3, r0
  201610:	e58d3010 	str	r3, [sp, #16]
  201614:	e59d3010 	ldr	r3, [sp, #16]
  201618:	e3530000 	cmp	r3, #0
  20161c:	1affffda 	bne	20158c <long_to_string_with_divisor+0x4c>

  i = (int)(p + MAX_FILLER - q);
  201620:	e59d300c 	ldr	r3, [sp, #12]
  201624:	e283300b 	add	r3, r3, #11
  201628:	e1a02003 	mov	r2, r3
  20162c:	e59d3018 	ldr	r3, [sp, #24]
  201630:	e0633002 	rsb	r3, r3, r2
  201634:	e58d301c 	str	r3, [sp, #28]
  do
    *p++ = *q++;
  201638:	e59d300c 	ldr	r3, [sp, #12]
  20163c:	e2832001 	add	r2, r3, #1
  201640:	e58d200c 	str	r2, [sp, #12]
  201644:	e59d2018 	ldr	r2, [sp, #24]
  201648:	e2821001 	add	r1, r2, #1
  20164c:	e58d1018 	str	r1, [sp, #24]
  201650:	e5d22000 	ldrb	r2, [r2]
  201654:	e5c32000 	strb	r2, [r3]
  while (--i);
  201658:	e59d301c 	ldr	r3, [sp, #28]
  20165c:	e2433001 	sub	r3, r3, #1
  201660:	e58d301c 	str	r3, [sp, #28]
  201664:	e59d301c 	ldr	r3, [sp, #28]
  201668:	e3530000 	cmp	r3, #0
  20166c:	1afffff1 	bne	201638 <long_to_string_with_divisor+0xf8>

  return p;
  201670:	e59d300c 	ldr	r3, [sp, #12]
}
  201674:	e1a00003 	mov	r0, r3
  201678:	e28dd024 	add	sp, sp, #36	; 0x24
  20167c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00201680 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
  201680:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201684:	e24dd014 	sub	sp, sp, #20
  201688:	e58d000c 	str	r0, [sp, #12]
  20168c:	e58d1008 	str	r1, [sp, #8]
  201690:	e58d2004 	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
  201694:	e3a03000 	mov	r3, #0
  201698:	e59d2004 	ldr	r2, [sp, #4]
  20169c:	e59d1008 	ldr	r1, [sp, #8]
  2016a0:	e59d000c 	ldr	r0, [sp, #12]
  2016a4:	ebffffa5 	bl	201540 <long_to_string_with_divisor>
  2016a8:	e1a03000 	mov	r3, r0
}
  2016ac:	e1a00003 	mov	r0, r3
  2016b0:	e28dd014 	add	sp, sp, #20
  2016b4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002016c0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  2016c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2016c4:	e24dd044 	sub	sp, sp, #68	; 0x44
  2016c8:	e58d000c 	str	r0, [sp, #12]
  2016cc:	e58d1008 	str	r1, [sp, #8]
  2016d0:	e58d2004 	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
  2016d4:	e3a03000 	mov	r3, #0
  2016d8:	e58d3024 	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
  2016dc:	e59d3008 	ldr	r3, [sp, #8]
  2016e0:	e2832001 	add	r2, r3, #1
  2016e4:	e58d2008 	str	r2, [sp, #8]
  2016e8:	e5d33000 	ldrb	r3, [r3]
  2016ec:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
    if (c == 0)
  2016f0:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2016f4:	e3530000 	cmp	r3, #0
  2016f8:	1a000001 	bne	201704 <chvprintf+0x44>
      return n;
  2016fc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  201700:	ea00019c 	b	201d78 <chvprintf+0x6b8>
    if (c != '%') {
  201704:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201708:	e3530025 	cmp	r3, #37	; 0x25
  20170c:	0a00000a 	beq	20173c <chvprintf+0x7c>
      streamPut(chp, (uint8_t)c);
  201710:	e59d300c 	ldr	r3, [sp, #12]
  201714:	e5933000 	ldr	r3, [r3]
  201718:	e5933008 	ldr	r3, [r3, #8]
  20171c:	e5dd2037 	ldrb	r2, [sp, #55]	; 0x37
  201720:	e1a01002 	mov	r1, r2
  201724:	e59d000c 	ldr	r0, [sp, #12]
  201728:	e12fff33 	blx	r3
      n++;
  20172c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  201730:	e2833001 	add	r3, r3, #1
  201734:	e58d3024 	str	r3, [sp, #36]	; 0x24
  201738:	eaffffe7 	b	2016dc <chvprintf+0x1c>
      continue;
    }
    p = tmpbuf;
  20173c:	e28d3010 	add	r3, sp, #16
  201740:	e58d303c 	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
  201744:	e28d3010 	add	r3, sp, #16
  201748:	e58d3038 	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
  20174c:	e3a03000 	mov	r3, #0
  201750:	e5cd3022 	strb	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
  201754:	e59d3008 	ldr	r3, [sp, #8]
  201758:	e5d33000 	ldrb	r3, [r3]
  20175c:	e353002d 	cmp	r3, #45	; 0x2d
  201760:	1a000004 	bne	201778 <chvprintf+0xb8>
      fmt++;
  201764:	e59d3008 	ldr	r3, [sp, #8]
  201768:	e2833001 	add	r3, r3, #1
  20176c:	e58d3008 	str	r3, [sp, #8]
      left_align = TRUE;
  201770:	e3a03001 	mov	r3, #1
  201774:	e5cd3022 	strb	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
  201778:	e3a03020 	mov	r3, #32
  20177c:	e5cd3036 	strb	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
  201780:	e59d3008 	ldr	r3, [sp, #8]
  201784:	e5d33000 	ldrb	r3, [r3]
  201788:	e3530030 	cmp	r3, #48	; 0x30
  20178c:	1a000004 	bne	2017a4 <chvprintf+0xe4>
      fmt++;
  201790:	e59d3008 	ldr	r3, [sp, #8]
  201794:	e2833001 	add	r3, r3, #1
  201798:	e58d3008 	str	r3, [sp, #8]
      filler = '0';
  20179c:	e3a03030 	mov	r3, #48	; 0x30
  2017a0:	e5cd3036 	strb	r3, [sp, #54]	; 0x36
    }
    width = 0;
  2017a4:	e3a03000 	mov	r3, #0
  2017a8:	e58d3028 	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
  2017ac:	e59d3008 	ldr	r3, [sp, #8]
  2017b0:	e2832001 	add	r2, r3, #1
  2017b4:	e58d2008 	str	r2, [sp, #8]
  2017b8:	e5d33000 	ldrb	r3, [r3]
  2017bc:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
  2017c0:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2017c4:	e353002f 	cmp	r3, #47	; 0x2f
  2017c8:	9a000006 	bls	2017e8 <chvprintf+0x128>
  2017cc:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2017d0:	e3530039 	cmp	r3, #57	; 0x39
  2017d4:	8a000003 	bhi	2017e8 <chvprintf+0x128>
        c -= '0';
  2017d8:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2017dc:	e2433030 	sub	r3, r3, #48	; 0x30
  2017e0:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
  2017e4:	ea000007 	b	201808 <chvprintf+0x148>
      else if (c == '*')
  2017e8:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2017ec:	e353002a 	cmp	r3, #42	; 0x2a
  2017f0:	1a00000b 	bne	201824 <chvprintf+0x164>
        c = va_arg(ap, int);
  2017f4:	e59d3004 	ldr	r3, [sp, #4]
  2017f8:	e2832004 	add	r2, r3, #4
  2017fc:	e58d2004 	str	r2, [sp, #4]
  201800:	e5933000 	ldr	r3, [r3]
  201804:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
  201808:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  20180c:	e3a0200a 	mov	r2, #10
  201810:	e0020392 	mul	r2, r2, r3
  201814:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201818:	e0823003 	add	r3, r2, r3
  20181c:	e58d3028 	str	r3, [sp, #40]	; 0x28
  201820:	eaffffe1 	b	2017ac <chvprintf+0xec>
    }
    precision = 0;
  201824:	e3a03000 	mov	r3, #0
  201828:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
  20182c:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201830:	e353002e 	cmp	r3, #46	; 0x2e
  201834:	1a00001f 	bne	2018b8 <chvprintf+0x1f8>
      while (TRUE) {
        c = *fmt++;
  201838:	e59d3008 	ldr	r3, [sp, #8]
  20183c:	e2832001 	add	r2, r3, #1
  201840:	e58d2008 	str	r2, [sp, #8]
  201844:	e5d33000 	ldrb	r3, [r3]
  201848:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
  20184c:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201850:	e353002f 	cmp	r3, #47	; 0x2f
  201854:	9a000006 	bls	201874 <chvprintf+0x1b4>
  201858:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  20185c:	e3530039 	cmp	r3, #57	; 0x39
  201860:	8a000003 	bhi	201874 <chvprintf+0x1b4>
          c -= '0';
  201864:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201868:	e2433030 	sub	r3, r3, #48	; 0x30
  20186c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
  201870:	ea000007 	b	201894 <chvprintf+0x1d4>
        else if (c == '*')
  201874:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201878:	e353002a 	cmp	r3, #42	; 0x2a
  20187c:	1a00000d 	bne	2018b8 <chvprintf+0x1f8>
          c = va_arg(ap, int);
  201880:	e59d3004 	ldr	r3, [sp, #4]
  201884:	e2832004 	add	r2, r3, #4
  201888:	e58d2004 	str	r2, [sp, #4]
  20188c:	e5933000 	ldr	r3, [r3]
  201890:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
        else
          break;
        precision *= 10;
  201894:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  201898:	e3a0200a 	mov	r2, #10
  20189c:	e0030392 	mul	r3, r2, r3
  2018a0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
        precision += c;
  2018a4:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2018a8:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
  2018ac:	e0823003 	add	r3, r2, r3
  2018b0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  2018b4:	eaffffdf 	b	201838 <chvprintf+0x178>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
  2018b8:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2018bc:	e353006c 	cmp	r3, #108	; 0x6c
  2018c0:	0a000002 	beq	2018d0 <chvprintf+0x210>
  2018c4:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  2018c8:	e353004c 	cmp	r3, #76	; 0x4c
  2018cc:	1a00000b 	bne	201900 <chvprintf+0x240>
      is_long = TRUE;
  2018d0:	e3a03001 	mov	r3, #1
  2018d4:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
      if (*fmt)
  2018d8:	e59d3008 	ldr	r3, [sp, #8]
  2018dc:	e5d33000 	ldrb	r3, [r3]
  2018e0:	e3530000 	cmp	r3, #0
  2018e4:	0a000013 	beq	201938 <chvprintf+0x278>
        c = *fmt++;
  2018e8:	e59d3008 	ldr	r3, [sp, #8]
  2018ec:	e2832001 	add	r2, r3, #1
  2018f0:	e58d2008 	str	r2, [sp, #8]
  2018f4:	e5d33000 	ldrb	r3, [r3]
  2018f8:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
  2018fc:	ea00000e 	b	20193c <chvprintf+0x27c>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
  201900:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201904:	e3530040 	cmp	r3, #64	; 0x40
  201908:	9a000004 	bls	201920 <chvprintf+0x260>
  20190c:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201910:	e353005a 	cmp	r3, #90	; 0x5a
  201914:	8a000001 	bhi	201920 <chvprintf+0x260>
  201918:	e3a03001 	mov	r3, #1
  20191c:	ea000000 	b	201924 <chvprintf+0x264>
  201920:	e3a03000 	mov	r3, #0
  201924:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
  201928:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
  20192c:	e2033001 	and	r3, r3, #1
  201930:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
  201934:	ea000000 	b	20193c <chvprintf+0x27c>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
  201938:	e1a00000 	nop			; (mov r0, r0)
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
  20193c:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201940:	e2433044 	sub	r3, r3, #68	; 0x44
  201944:	e3530034 	cmp	r3, #52	; 0x34
  201948:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  20194c:	ea00009f 	b	201bd0 <chvprintf+0x510>
  201950:	00201ae0 	.word	0x00201ae0
  201954:	00201bd0 	.word	0x00201bd0
  201958:	00201bd0 	.word	0x00201bd0
  20195c:	00201bd0 	.word	0x00201bd0
  201960:	00201bd0 	.word	0x00201bd0
  201964:	00201ae0 	.word	0x00201ae0
  201968:	00201bd0 	.word	0x00201bd0
  20196c:	00201bd0 	.word	0x00201bd0
  201970:	00201bd0 	.word	0x00201bd0
  201974:	00201bd0 	.word	0x00201bd0
  201978:	00201bd0 	.word	0x00201bd0
  20197c:	00201b74 	.word	0x00201b74
  201980:	00201bd0 	.word	0x00201bd0
  201984:	00201bd0 	.word	0x00201bd0
  201988:	00201bd0 	.word	0x00201bd0
  20198c:	00201bd0 	.word	0x00201bd0
  201990:	00201bd0 	.word	0x00201bd0
  201994:	00201b68 	.word	0x00201b68
  201998:	00201bd0 	.word	0x00201bd0
  20199c:	00201bd0 	.word	0x00201bd0
  2019a0:	00201b5c 	.word	0x00201b5c
  2019a4:	00201bd0 	.word	0x00201bd0
  2019a8:	00201bd0 	.word	0x00201bd0
  2019ac:	00201bd0 	.word	0x00201bd0
  2019b0:	00201bd0 	.word	0x00201bd0
  2019b4:	00201bd0 	.word	0x00201bd0
  2019b8:	00201bd0 	.word	0x00201bd0
  2019bc:	00201bd0 	.word	0x00201bd0
  2019c0:	00201bd0 	.word	0x00201bd0
  2019c4:	00201bd0 	.word	0x00201bd0
  2019c8:	00201bd0 	.word	0x00201bd0
  2019cc:	00201a24 	.word	0x00201a24
  2019d0:	00201ae0 	.word	0x00201ae0
  2019d4:	00201bd0 	.word	0x00201bd0
  2019d8:	00201bd0 	.word	0x00201bd0
  2019dc:	00201bd0 	.word	0x00201bd0
  2019e0:	00201bd0 	.word	0x00201bd0
  2019e4:	00201ae0 	.word	0x00201ae0
  2019e8:	00201bd0 	.word	0x00201bd0
  2019ec:	00201bd0 	.word	0x00201bd0
  2019f0:	00201bd0 	.word	0x00201bd0
  2019f4:	00201bd0 	.word	0x00201bd0
  2019f8:	00201bd0 	.word	0x00201bd0
  2019fc:	00201b74 	.word	0x00201b74
  201a00:	00201bd0 	.word	0x00201bd0
  201a04:	00201bd0 	.word	0x00201bd0
  201a08:	00201bd0 	.word	0x00201bd0
  201a0c:	00201a54 	.word	0x00201a54
  201a10:	00201bd0 	.word	0x00201bd0
  201a14:	00201b68 	.word	0x00201b68
  201a18:	00201bd0 	.word	0x00201bd0
  201a1c:	00201bd0 	.word	0x00201bd0
  201a20:	00201b5c 	.word	0x00201b5c
    case 'c':
      filler = ' ';
  201a24:	e3a03020 	mov	r3, #32
  201a28:	e5cd3036 	strb	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
  201a2c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
  201a30:	e2832001 	add	r2, r3, #1
  201a34:	e58d203c 	str	r2, [sp, #60]	; 0x3c
  201a38:	e59d2004 	ldr	r2, [sp, #4]
  201a3c:	e2821004 	add	r1, r2, #4
  201a40:	e58d1004 	str	r1, [sp, #4]
  201a44:	e5922000 	ldr	r2, [r2]
  201a48:	e6ef2072 	uxtb	r2, r2
  201a4c:	e5c32000 	strb	r2, [r3]
  201a50:	ea000063 	b	201be4 <chvprintf+0x524>
      break;
    case 's':
      filler = ' ';
  201a54:	e3a03020 	mov	r3, #32
  201a58:	e5cd3036 	strb	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
  201a5c:	e59d3004 	ldr	r3, [sp, #4]
  201a60:	e2832004 	add	r2, r3, #4
  201a64:	e58d2004 	str	r2, [sp, #4]
  201a68:	e5933000 	ldr	r3, [r3]
  201a6c:	e58d3038 	str	r3, [sp, #56]	; 0x38
  201a70:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
  201a74:	e3530000 	cmp	r3, #0
  201a78:	1a000002 	bne	201a88 <chvprintf+0x3c8>
        s = "(null)";
  201a7c:	e3053484 	movw	r3, #21636	; 0x5484
  201a80:	e3403020 	movt	r3, #32
  201a84:	e58d3038 	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
  201a88:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  201a8c:	e3530000 	cmp	r3, #0
  201a90:	1a000001 	bne	201a9c <chvprintf+0x3dc>
        precision = 32767;
  201a94:	e3073fff 	movw	r3, #32767	; 0x7fff
  201a98:	e58d302c 	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
  201a9c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
  201aa0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
  201aa4:	ea000002 	b	201ab4 <chvprintf+0x3f4>
  201aa8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
  201aac:	e2833001 	add	r3, r3, #1
  201ab0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
  201ab4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
  201ab8:	e5d33000 	ldrb	r3, [r3]
  201abc:	e3530000 	cmp	r3, #0
  201ac0:	0a000047 	beq	201be4 <chvprintf+0x524>
  201ac4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  201ac8:	e2433001 	sub	r3, r3, #1
  201acc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  201ad0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  201ad4:	e3530000 	cmp	r3, #0
  201ad8:	aafffff2 	bge	201aa8 <chvprintf+0x3e8>
  201adc:	ea000040 	b	201be4 <chvprintf+0x524>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
  201ae0:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
  201ae4:	e3530000 	cmp	r3, #0
  201ae8:	0a000005 	beq	201b04 <chvprintf+0x444>
        l = va_arg(ap, long);
  201aec:	e59d3004 	ldr	r3, [sp, #4]
  201af0:	e2832004 	add	r2, r3, #4
  201af4:	e58d2004 	str	r2, [sp, #4]
  201af8:	e5933000 	ldr	r3, [r3]
  201afc:	e58d301c 	str	r3, [sp, #28]
  201b00:	ea000004 	b	201b18 <chvprintf+0x458>
      else
        l = va_arg(ap, int);
  201b04:	e59d3004 	ldr	r3, [sp, #4]
  201b08:	e2832004 	add	r2, r3, #4
  201b0c:	e58d2004 	str	r2, [sp, #4]
  201b10:	e5933000 	ldr	r3, [r3]
  201b14:	e58d301c 	str	r3, [sp, #28]
      if (l < 0) {
  201b18:	e59d301c 	ldr	r3, [sp, #28]
  201b1c:	e3530000 	cmp	r3, #0
  201b20:	aa000007 	bge	201b44 <chvprintf+0x484>
        *p++ = '-';
  201b24:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
  201b28:	e2832001 	add	r2, r3, #1
  201b2c:	e58d203c 	str	r2, [sp, #60]	; 0x3c
  201b30:	e3a0202d 	mov	r2, #45	; 0x2d
  201b34:	e5c32000 	strb	r2, [r3]
        l = -l;
  201b38:	e59d301c 	ldr	r3, [sp, #28]
  201b3c:	e2633000 	rsb	r3, r3, #0
  201b40:	e58d301c 	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
  201b44:	e3a0200a 	mov	r2, #10
  201b48:	e59d101c 	ldr	r1, [sp, #28]
  201b4c:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
  201b50:	ebfffeca 	bl	201680 <ch_ltoa>
  201b54:	e58d003c 	str	r0, [sp, #60]	; 0x3c
  201b58:	ea000021 	b	201be4 <chvprintf+0x524>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
  201b5c:	e3a03010 	mov	r3, #16
  201b60:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
  201b64:	ea000004 	b	201b7c <chvprintf+0x4bc>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
  201b68:	e3a0300a 	mov	r3, #10
  201b6c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
  201b70:	ea000001 	b	201b7c <chvprintf+0x4bc>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
  201b74:	e3a03008 	mov	r3, #8
  201b78:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
  201b7c:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
  201b80:	e3530000 	cmp	r3, #0
  201b84:	0a000005 	beq	201ba0 <chvprintf+0x4e0>
        l = va_arg(ap, unsigned long);
  201b88:	e59d3004 	ldr	r3, [sp, #4]
  201b8c:	e2832004 	add	r2, r3, #4
  201b90:	e58d2004 	str	r2, [sp, #4]
  201b94:	e5933000 	ldr	r3, [r3]
  201b98:	e58d301c 	str	r3, [sp, #28]
  201b9c:	ea000004 	b	201bb4 <chvprintf+0x4f4>
      else
        l = va_arg(ap, unsigned int);
  201ba0:	e59d3004 	ldr	r3, [sp, #4]
  201ba4:	e2832004 	add	r2, r3, #4
  201ba8:	e58d2004 	str	r2, [sp, #4]
  201bac:	e5933000 	ldr	r3, [r3]
  201bb0:	e58d301c 	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
  201bb4:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
  201bb8:	e1a02003 	mov	r2, r3
  201bbc:	e59d101c 	ldr	r1, [sp, #28]
  201bc0:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
  201bc4:	ebfffead 	bl	201680 <ch_ltoa>
  201bc8:	e58d003c 	str	r0, [sp, #60]	; 0x3c
  201bcc:	ea000004 	b	201be4 <chvprintf+0x524>
      break;
    default:
      *p++ = c;
  201bd0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
  201bd4:	e2832001 	add	r2, r3, #1
  201bd8:	e58d203c 	str	r2, [sp, #60]	; 0x3c
  201bdc:	e5dd2037 	ldrb	r2, [sp, #55]	; 0x37
  201be0:	e5c32000 	strb	r2, [r3]
      break;
    }
    i = (int)(p - s);
  201be4:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
  201be8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
  201bec:	e0633002 	rsb	r3, r3, r2
  201bf0:	e58d3030 	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
  201bf4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
  201bf8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  201bfc:	e0633002 	rsb	r3, r3, r2
  201c00:	e58d3028 	str	r3, [sp, #40]	; 0x28
  201c04:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  201c08:	e3530000 	cmp	r3, #0
  201c0c:	aa000001 	bge	201c18 <chvprintf+0x558>
      width = 0;
  201c10:	e3a03000 	mov	r3, #0
  201c14:	e58d3028 	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
  201c18:	e5dd3022 	ldrb	r3, [sp, #34]	; 0x22
  201c1c:	e2233001 	eor	r3, r3, #1
  201c20:	e6ef3073 	uxtb	r3, r3
  201c24:	e3530000 	cmp	r3, #0
  201c28:	0a000002 	beq	201c38 <chvprintf+0x578>
      width = -width;
  201c2c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  201c30:	e2633000 	rsb	r3, r3, #0
  201c34:	e58d3028 	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
  201c38:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  201c3c:	e3530000 	cmp	r3, #0
  201c40:	aa000034 	bge	201d18 <chvprintf+0x658>
      if (*s == '-' && filler == '0') {
  201c44:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
  201c48:	e5d33000 	ldrb	r3, [r3]
  201c4c:	e353002d 	cmp	r3, #45	; 0x2d
  201c50:	1a000012 	bne	201ca0 <chvprintf+0x5e0>
  201c54:	e5dd3036 	ldrb	r3, [sp, #54]	; 0x36
  201c58:	e3530030 	cmp	r3, #48	; 0x30
  201c5c:	1a00000f 	bne	201ca0 <chvprintf+0x5e0>
        streamPut(chp, (uint8_t)*s++);
  201c60:	e59d300c 	ldr	r3, [sp, #12]
  201c64:	e5933000 	ldr	r3, [r3]
  201c68:	e5932008 	ldr	r2, [r3, #8]
  201c6c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
  201c70:	e2831001 	add	r1, r3, #1
  201c74:	e58d1038 	str	r1, [sp, #56]	; 0x38
  201c78:	e5d33000 	ldrb	r3, [r3]
  201c7c:	e1a01003 	mov	r1, r3
  201c80:	e59d000c 	ldr	r0, [sp, #12]
  201c84:	e12fff32 	blx	r2
        n++;
  201c88:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  201c8c:	e2833001 	add	r3, r3, #1
  201c90:	e58d3024 	str	r3, [sp, #36]	; 0x24
        i--;
  201c94:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  201c98:	e2433001 	sub	r3, r3, #1
  201c9c:	e58d3030 	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
  201ca0:	e59d300c 	ldr	r3, [sp, #12]
  201ca4:	e5933000 	ldr	r3, [r3]
  201ca8:	e5933008 	ldr	r3, [r3, #8]
  201cac:	e5dd2036 	ldrb	r2, [sp, #54]	; 0x36
  201cb0:	e1a01002 	mov	r1, r2
  201cb4:	e59d000c 	ldr	r0, [sp, #12]
  201cb8:	e12fff33 	blx	r3
        n++;
  201cbc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  201cc0:	e2833001 	add	r3, r3, #1
  201cc4:	e58d3024 	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
  201cc8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  201ccc:	e2833001 	add	r3, r3, #1
  201cd0:	e58d3028 	str	r3, [sp, #40]	; 0x28
  201cd4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  201cd8:	e3530000 	cmp	r3, #0
  201cdc:	1affffef 	bne	201ca0 <chvprintf+0x5e0>
  201ce0:	ea00000c 	b	201d18 <chvprintf+0x658>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
  201ce4:	e59d300c 	ldr	r3, [sp, #12]
  201ce8:	e5933000 	ldr	r3, [r3]
  201cec:	e5932008 	ldr	r2, [r3, #8]
  201cf0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
  201cf4:	e2831001 	add	r1, r3, #1
  201cf8:	e58d1038 	str	r1, [sp, #56]	; 0x38
  201cfc:	e5d33000 	ldrb	r3, [r3]
  201d00:	e1a01003 	mov	r1, r3
  201d04:	e59d000c 	ldr	r0, [sp, #12]
  201d08:	e12fff32 	blx	r2
      n++;
  201d0c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  201d10:	e2833001 	add	r3, r3, #1
  201d14:	e58d3024 	str	r3, [sp, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
  201d18:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  201d1c:	e2433001 	sub	r3, r3, #1
  201d20:	e58d3030 	str	r3, [sp, #48]	; 0x30
  201d24:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  201d28:	e3530000 	cmp	r3, #0
  201d2c:	aaffffec 	bge	201ce4 <chvprintf+0x624>
  201d30:	ea00000c 	b	201d68 <chvprintf+0x6a8>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
  201d34:	e59d300c 	ldr	r3, [sp, #12]
  201d38:	e5933000 	ldr	r3, [r3]
  201d3c:	e5933008 	ldr	r3, [r3, #8]
  201d40:	e5dd2036 	ldrb	r2, [sp, #54]	; 0x36
  201d44:	e1a01002 	mov	r1, r2
  201d48:	e59d000c 	ldr	r0, [sp, #12]
  201d4c:	e12fff33 	blx	r3
      n++;
  201d50:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  201d54:	e2833001 	add	r3, r3, #1
  201d58:	e58d3024 	str	r3, [sp, #36]	; 0x24
      width--;
  201d5c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  201d60:	e2433001 	sub	r3, r3, #1
  201d64:	e58d3028 	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
  201d68:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  201d6c:	e3530000 	cmp	r3, #0
  201d70:	1affffef 	bne	201d34 <chvprintf+0x674>
  201d74:	eafffe58 	b	2016dc <chvprintf+0x1c>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
  201d78:	e1a00003 	mov	r0, r3
  201d7c:	e28dd044 	add	sp, sp, #68	; 0x44
  201d80:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00201d90 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  201d90:	e92d000e 	push	{r1, r2, r3}
  201d94:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201d98:	e24dd010 	sub	sp, sp, #16
  201d9c:	e58d0004 	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  201da0:	e28d3018 	add	r3, sp, #24
  201da4:	e58d3008 	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
  201da8:	e59d2008 	ldr	r2, [sp, #8]
  201dac:	e59d1014 	ldr	r1, [sp, #20]
  201db0:	e59d0004 	ldr	r0, [sp, #4]
  201db4:	ebfffe41 	bl	2016c0 <chvprintf>
  201db8:	e58d000c 	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
  201dbc:	e59d300c 	ldr	r3, [sp, #12]
}
  201dc0:	e1a00003 	mov	r0, r3
  201dc4:	e28dd010 	add	sp, sp, #16
  201dc8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  201dcc:	e28dd00c 	add	sp, sp, #12
  201dd0:	e12fff1e 	bx	lr
	...

00201de0 <port_lock_from_isr.lto_priv.7>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  201de0:	e12fff1e 	bx	lr
	...

00201df0 <port_unlock_from_isr.lto_priv.5>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  201df0:	e12fff1e 	bx	lr
	...

00201e00 <chSysLockFromISR.lto_priv.3>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  201e00:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  201e04:	ebfffff5 	bl	201de0 <port_lock_from_isr.lto_priv.7>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  201e08:	e8bd8010 	pop	{r4, pc}
  201e0c:	00000000 	andeq	r0, r0, r0

00201e10 <chSysUnlockFromISR.lto_priv.1>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  201e10:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  201e14:	ebfffff5 	bl	201df0 <port_unlock_from_isr.lto_priv.5>
}
  201e18:	e8bd8010 	pop	{r4, pc}
  201e1c:	00000000 	andeq	r0, r0, r0

00201e20 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
  201e20:	e24dd008 	sub	sp, sp, #8
  201e24:	e58d0004 	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->func != NULL);
  201e28:	e59d3004 	ldr	r3, [sp, #4]
  201e2c:	e593300c 	ldr	r3, [r3, #12]
  201e30:	e3530000 	cmp	r3, #0
  201e34:	13a03001 	movne	r3, #1
  201e38:	03a03000 	moveq	r3, #0
  201e3c:	e6ef3073 	uxtb	r3, r3
}
  201e40:	e1a00003 	mov	r0, r3
  201e44:	e28dd008 	add	sp, sp, #8
  201e48:	e12fff1e 	bx	lr
  201e4c:	00000000 	andeq	r0, r0, r0

00201e50 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
  201e50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201e54:	e24dd00c 	sub	sp, sp, #12
  201e58:	e58d0004 	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
  201e5c:	e59d0004 	ldr	r0, [sp, #4]
  201e60:	ebffffee 	bl	201e20 <chVTIsArmedI>
  201e64:	e1a03000 	mov	r3, r0
  201e68:	e3530000 	cmp	r3, #0
  201e6c:	0a000001 	beq	201e78 <chVTResetI+0x28>
    chVTDoResetI(vtp);
  201e70:	e59d0004 	ldr	r0, [sp, #4]
  201e74:	eb00099d 	bl	2044f0 <chVTDoResetI>
  }
}
  201e78:	e28dd00c 	add	sp, sp, #12
  201e7c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00201e80 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
  201e80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201e84:	e24dd014 	sub	sp, sp, #20
  201e88:	e58d000c 	str	r0, [sp, #12]
  201e8c:	e58d1008 	str	r1, [sp, #8]
  201e90:	e58d2004 	str	r2, [sp, #4]
  201e94:	e58d3000 	str	r3, [sp]

  chVTResetI(vtp);
  201e98:	e59d000c 	ldr	r0, [sp, #12]
  201e9c:	ebffffeb 	bl	201e50 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
  201ea0:	e59d3000 	ldr	r3, [sp]
  201ea4:	e59d2004 	ldr	r2, [sp, #4]
  201ea8:	e59d1008 	ldr	r1, [sp, #8]
  201eac:	e59d000c 	ldr	r0, [sp, #12]
  201eb0:	eb00094e 	bl	2043f0 <chVTDoSetI>
}
  201eb4:	e28dd014 	add	sp, sp, #20
  201eb8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  201ebc:	00000000 	andeq	r0, r0, r0

00201ec0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
  201ec0:	e24dd008 	sub	sp, sp, #8
  201ec4:	e58d0004 	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
  201ec8:	e3003938 	movw	r3, #2360	; 0x938
  201ecc:	e3403021 	movt	r3, #33	; 0x21
  201ed0:	e5933018 	ldr	r3, [r3, #24]
  201ed4:	e59d2004 	ldr	r2, [sp, #4]
  201ed8:	e5832018 	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
  201edc:	e28dd008 	add	sp, sp, #8
  201ee0:	e12fff1e 	bx	lr
	...

00201ef0 <led3off>:

static virtual_timer_t vt3;
static char txbuf[BUFFER_SIZE] = "0123456789ABCDEF";
static char rxbuf[BUFFER_SIZE];

static void led3off(void *p) {
  201ef0:	e24dd008 	sub	sp, sp, #8
  201ef4:	e58d0004 	str	r0, [sp, #4]

  (void)p;
  palSetLine(LINE_LED_RED);
  201ef8:	e3093040 	movw	r3, #36928	; 0x9040
  201efc:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201f00:	e3a02040 	mov	r2, #64	; 0x40
  201f04:	e5832010 	str	r2, [r3, #16]
}
  201f08:	e28dd008 	add	sp, sp, #8
  201f0c:	e12fff1e 	bx	lr

00201f10 <rxend>:

/*
 * This callback is invoked when a receive buffer has been completely written.
 */
static void rxend(SPIDriver *spip) {
  201f10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201f14:	e24dd00c 	sub	sp, sp, #12
  201f18:	e58d0004 	str	r0, [sp, #4]

  (void)spip;

  palClearLine(LINE_LED_RED);
  201f1c:	e3093040 	movw	r3, #36928	; 0x9040
  201f20:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201f24:	e3a02040 	mov	r2, #64	; 0x40
  201f28:	e5832014 	str	r2, [r3, #20]
  chSysLockFromISR();
  201f2c:	ebffffb3 	bl	201e00 <chSysLockFromISR.lto_priv.3>
  chVTResetI(&vt3);
  201f30:	e3000c8c 	movw	r0, #3212	; 0xc8c
  201f34:	e3400021 	movt	r0, #33	; 0x21
  201f38:	ebffffc4 	bl	201e50 <chVTResetI>
  chVTSetI(&vt3, MS2ST(200), led3off, NULL);
  201f3c:	e3a03000 	mov	r3, #0
  201f40:	e3012ef0 	movw	r2, #7920	; 0x1ef0
  201f44:	e3402020 	movt	r2, #32
  201f48:	e3a010c8 	mov	r1, #200	; 0xc8
  201f4c:	e3000c8c 	movw	r0, #3212	; 0xc8c
  201f50:	e3400021 	movt	r0, #33	; 0x21
  201f54:	ebffffc9 	bl	201e80 <chVTSetI>
  chSysUnlockFromISR();
  201f58:	ebffffac 	bl	201e10 <chSysUnlockFromISR.lto_priv.1>
}
  201f5c:	e28dd00c 	add	sp, sp, #12
  201f60:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00201f70 <Thread1>:

/*
 * LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 512);
static THD_FUNCTION(Thread1, arg) {
  201f70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201f74:	e24dd00c 	sub	sp, sp, #12
  201f78:	e58d0004 	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
  201f7c:	e305048c 	movw	r0, #21644	; 0x548c
  201f80:	e3400020 	movt	r0, #32
  201f84:	ebffffcd 	bl	201ec0 <chRegSetThreadName>

  while (true) {
    palToggleLine(LINE_LED_BLUE);
  201f88:	e3093040 	movw	r3, #36928	; 0x9040
  201f8c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201f90:	e3e02000 	mvn	r2, #0
  201f94:	e5832000 	str	r2, [r3]
  201f98:	e3093040 	movw	r3, #36928	; 0x9040
  201f9c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201fa0:	e3092040 	movw	r2, #36928	; 0x9040
  201fa4:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201fa8:	e5922018 	ldr	r2, [r2, #24]
  201fac:	e2222001 	eor	r2, r2, #1
  201fb0:	e5832018 	str	r2, [r3, #24]
    chThdSleepMilliseconds(500);
  201fb4:	e3a00f7d 	mov	r0, #500	; 0x1f4
  201fb8:	eb000c60 	bl	205140 <chThdSleep>
  201fbc:	eafffff1 	b	201f88 <Thread1+0x18>

00201fc0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
  201fc0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201fc4:	e24dd00c 	sub	sp, sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
  201fc8:	eb0006e8 	bl	203b70 <halInit>
  chSysInit();
  201fcc:	eb0008bb 	bl	2042c0 <chSysInit>

  /*
   * Activates the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
  201fd0:	e3a01000 	mov	r1, #0
  201fd4:	e3000c08 	movw	r0, #3080	; 0xc08
  201fd8:	e3400021 	movt	r0, #33	; 0x21
  201fdc:	eb0002b3 	bl	202ab0 <sdStart>
  spiStart(&SPID1, &mst_spicfg);       /* Setup transfer parameters.       */
  201fe0:	e3051590 	movw	r1, #21904	; 0x5590
  201fe4:	e3401020 	movt	r1, #32
  201fe8:	e3000bd8 	movw	r0, #3032	; 0xbd8
  201fec:	e3400021 	movt	r0, #33	; 0x21
  201ff0:	eb000322 	bl	202c80 <spiStart>

  /* Redirecting  UART0 RX on PB26 and UART0 TX on PB 27. */
  palSetGroupMode(PIOB, PAL_PORT_BIT(26) | PAL_PORT_BIT(27), 0U,
  201ff4:	e3a0210e 	mov	r2, #-2147483645	; 0x80000003
  201ff8:	e3a01303 	mov	r1, #201326592	; 0xc000000
  201ffc:	e3090040 	movw	r0, #36928	; 0x9040
  202000:	e34f0c03 	movt	r0, #64515	; 0xfc03
  202004:	eb000689 	bl	203a30 <_pal_lld_setgroupmode>
                  PAL_SAMA_FUNC_PERIPH_C | PAL_MODE_SECURE);

  /* Redirecting  SPI1 pins. */
  palSetGroupMode(PIOD, PAL_PORT_BIT(25) | PAL_PORT_BIT(26) |
  202008:	e3a02106 	mov	r2, #-2147483647	; 0x80000001
  20200c:	e3a0141e 	mov	r1, #503316480	; 0x1e000000
  202010:	e30900c0 	movw	r0, #37056	; 0x90c0
  202014:	e34f0c03 	movt	r0, #64515	; 0xfc03
  202018:	eb000684 	bl	203a30 <_pal_lld_setgroupmode>
                  PAL_PORT_BIT(27) | PAL_PORT_BIT(28) , 0U,
                  PAL_SAMA_FUNC_PERIPH_A | PAL_MODE_SECURE);

  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO , Thread1, NULL);
  20201c:	e3a03000 	mov	r3, #0
  202020:	e58d3000 	str	r3, [sp]
  202024:	e3013f70 	movw	r3, #8048	; 0x1f70
  202028:	e3403020 	movt	r3, #32
  20202c:	e3a02080 	mov	r2, #128	; 0x80
  202030:	e3a01e2b 	mov	r1, #688	; 0x2b0
  202034:	e3000cb0 	movw	r0, #3248	; 0xcb0
  202038:	e3400021 	movt	r0, #33	; 0x21
  20203c:	eb000bd7 	bl	204fa0 <chThdCreateStatic>

  while (true) {
    if(!palReadPad(PIOB, PIOB_USER_PB)) {
  202040:	e3093040 	movw	r3, #36928	; 0x9040
  202044:	e34f3c03 	movt	r3, #64515	; 0xfc03
  202048:	e5933008 	ldr	r3, [r3, #8]
  20204c:	e1a034a3 	lsr	r3, r3, #9
  202050:	e2033001 	and	r3, r3, #1
  202054:	e3530000 	cmp	r3, #0
  202058:	1a00001b 	bne	2020cc <main+0x10c>
      spiExchange(&SPID1, BUFFER_SIZE, &txbuf, &rxbuf);
  20205c:	e3003ca0 	movw	r3, #3232	; 0xca0
  202060:	e3403021 	movt	r3, #33	; 0x21
  202064:	e3002858 	movw	r2, #2136	; 0x858
  202068:	e3402021 	movt	r2, #33	; 0x21
  20206c:	e3a01010 	mov	r1, #16
  202070:	e3000bd8 	movw	r0, #3032	; 0xbd8
  202074:	e3400021 	movt	r0, #33	; 0x21
  202078:	eb000310 	bl	202cc0 <spiExchange>
      if (!memcmp(txbuf, rxbuf, BUFFER_SIZE)){
  20207c:	e3a02010 	mov	r2, #16
  202080:	e3001ca0 	movw	r1, #3232	; 0xca0
  202084:	e3401021 	movt	r1, #33	; 0x21
  202088:	e3000858 	movw	r0, #2136	; 0x858
  20208c:	e3400021 	movt	r0, #33	; 0x21
  202090:	eb000cca 	bl	2053c0 <memcmp>
  202094:	e1a03000 	mov	r3, r0
  202098:	e3530000 	cmp	r3, #0
  20209c:	1a000005 	bne	2020b8 <main+0xf8>
        chprintf((BaseSequentialStream*)&SD0, "Transfer complete\n\r");
  2020a0:	e3051494 	movw	r1, #21652	; 0x5494
  2020a4:	e3401020 	movt	r1, #32
  2020a8:	e3000c08 	movw	r0, #3080	; 0xc08
  2020ac:	e3400021 	movt	r0, #33	; 0x21
  2020b0:	ebffff36 	bl	201d90 <chprintf>
  2020b4:	ea000004 	b	2020cc <main+0x10c>
      }
      else {
        chprintf((BaseSequentialStream*)&SD0, "ERROR: Buffers are not the same!\n\r");
  2020b8:	e30514a8 	movw	r1, #21672	; 0x54a8
  2020bc:	e3401020 	movt	r1, #32
  2020c0:	e3000c08 	movw	r0, #3080	; 0xc08
  2020c4:	e3400021 	movt	r0, #33	; 0x21
  2020c8:	ebffff30 	bl	201d90 <chprintf>
      }
    }
    chThdSleepMilliseconds(500);
  2020cc:	e3a00f7d 	mov	r0, #500	; 0x1f4
  2020d0:	eb000c1a 	bl	205140 <chThdSleep>
  2020d4:	eaffffd9 	b	202040 <main+0x80>
	...

002020e0 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
  2020e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2020e4:	e24dd014 	sub	sp, sp, #20
  2020e8:	e58d0004 	str	r0, [sp, #4]
  2020ec:	e58d1000 	str	r1, [sp]
  uint8_t b;

  osalSysLock();
  2020f0:	eb0006d6 	bl	203c50 <osalSysLock.lto_priv.35>
  2020f4:	ea00000a 	b	202124 <iqGetTimeout+0x44>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
  2020f8:	e59d3004 	ldr	r3, [sp, #4]
  2020fc:	e59d1000 	ldr	r1, [sp]
  202100:	e1a00003 	mov	r0, r3
  202104:	eb0006e9 	bl	203cb0 <osalThreadEnqueueTimeoutS.lto_priv.47>
  202108:	e58d000c 	str	r0, [sp, #12]
    if (msg < MSG_OK) {
  20210c:	e59d300c 	ldr	r3, [sp, #12]
  202110:	e3530000 	cmp	r3, #0
  202114:	aa000002 	bge	202124 <iqGetTimeout+0x44>
      osalSysUnlock();
  202118:	eb0006d0 	bl	203c60 <osalSysUnlock.lto_priv.32>
      return msg;
  20211c:	e59d300c 	ldr	r3, [sp, #12]
  202120:	ea000023 	b	2021b4 <iqGetTimeout+0xd4>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
  202124:	e59d3004 	ldr	r3, [sp, #4]
  202128:	e5933008 	ldr	r3, [r3, #8]
  20212c:	e3530000 	cmp	r3, #0
  202130:	0afffff0 	beq	2020f8 <iqGetTimeout+0x18>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  202134:	e59d3004 	ldr	r3, [sp, #4]
  202138:	e5933008 	ldr	r3, [r3, #8]
  20213c:	e2432001 	sub	r2, r3, #1
  202140:	e59d3004 	ldr	r3, [sp, #4]
  202144:	e5832008 	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
  202148:	e59d3004 	ldr	r3, [sp, #4]
  20214c:	e5933018 	ldr	r3, [r3, #24]
  202150:	e2831001 	add	r1, r3, #1
  202154:	e59d2004 	ldr	r2, [sp, #4]
  202158:	e5821018 	str	r1, [r2, #24]
  20215c:	e5d33000 	ldrb	r3, [r3]
  202160:	e5cd300b 	strb	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
  202164:	e59d3004 	ldr	r3, [sp, #4]
  202168:	e5932018 	ldr	r2, [r3, #24]
  20216c:	e59d3004 	ldr	r3, [sp, #4]
  202170:	e5933010 	ldr	r3, [r3, #16]
  202174:	e1520003 	cmp	r2, r3
  202178:	3a000003 	bcc	20218c <iqGetTimeout+0xac>
    iqp->q_rdptr = iqp->q_buffer;
  20217c:	e59d3004 	ldr	r3, [sp, #4]
  202180:	e593200c 	ldr	r2, [r3, #12]
  202184:	e59d3004 	ldr	r3, [sp, #4]
  202188:	e5832018 	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
  20218c:	e59d3004 	ldr	r3, [sp, #4]
  202190:	e593301c 	ldr	r3, [r3, #28]
  202194:	e3530000 	cmp	r3, #0
  202198:	0a000003 	beq	2021ac <iqGetTimeout+0xcc>
    iqp->q_notify(iqp);
  20219c:	e59d3004 	ldr	r3, [sp, #4]
  2021a0:	e593301c 	ldr	r3, [r3, #28]
  2021a4:	e59d0004 	ldr	r0, [sp, #4]
  2021a8:	e12fff33 	blx	r3
  }

  osalSysUnlock();
  2021ac:	eb0006ab 	bl	203c60 <osalSysUnlock.lto_priv.32>

  return (msg_t)b;
  2021b0:	e5dd300b 	ldrb	r3, [sp, #11]
}
  2021b4:	e1a00003 	mov	r0, r3
  2021b8:	e28dd014 	add	sp, sp, #20
  2021bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

002021c0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  2021c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2021c4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
  2021c8:	e58d000c 	str	r0, [sp, #12]
  2021cc:	e58d1008 	str	r1, [sp, #8]
  2021d0:	e58d2004 	str	r2, [sp, #4]
  2021d4:	e58d3000 	str	r3, [sp]
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  2021d8:	e59d300c 	ldr	r3, [sp, #12]
  2021dc:	e593301c 	ldr	r3, [r3, #28]
  2021e0:	e58d301c 	str	r3, [sp, #28]
  size_t r = 0;
  2021e4:	e3a03000 	mov	r3, #0
  2021e8:	e58d3024 	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
  2021ec:	eb000697 	bl	203c50 <osalSysLock.lto_priv.35>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
  2021f0:	eb00069e 	bl	203c70 <osalOsGetSystemTimeX.lto_priv.48>
  2021f4:	e1a02000 	mov	r2, r0
  2021f8:	e59d3000 	ldr	r3, [sp]
  2021fc:	e0823003 	add	r3, r2, r3
  202200:	e58d3018 	str	r3, [sp, #24]
  202204:	ea000022 	b	202294 <iqReadTimeout+0xd4>
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202208:	e59d3000 	ldr	r3, [sp]
  20220c:	e3730001 	cmn	r3, #1
  202210:	0a000002 	beq	202220 <iqReadTimeout+0x60>
  202214:	e59d3000 	ldr	r3, [sp]
  202218:	e3530000 	cmp	r3, #0
  20221c:	1a000005 	bne	202238 <iqReadTimeout+0x78>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
  202220:	e59d300c 	ldr	r3, [sp, #12]
  202224:	e59d1000 	ldr	r1, [sp]
  202228:	e1a00003 	mov	r0, r3
  20222c:	eb00069f 	bl	203cb0 <osalThreadEnqueueTimeoutS.lto_priv.47>
  202230:	e58d0020 	str	r0, [sp, #32]
  202234:	ea000010 	b	20227c <iqReadTimeout+0xbc>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
  202238:	eb00068c 	bl	203c70 <osalOsGetSystemTimeX.lto_priv.48>
  20223c:	e1a02000 	mov	r2, r0
  202240:	e59d3018 	ldr	r3, [sp, #24]
  202244:	e0623003 	rsb	r3, r2, r3
  202248:	e58d3014 	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
  20224c:	e59d2014 	ldr	r2, [sp, #20]
  202250:	e59d3000 	ldr	r3, [sp]
  202254:	e1520003 	cmp	r2, r3
  202258:	9a000002 	bls	202268 <iqReadTimeout+0xa8>
          osalSysUnlock();
  20225c:	eb00067f 	bl	203c60 <osalSysUnlock.lto_priv.32>
          return r;
  202260:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202264:	ea00003b 	b	202358 <iqReadTimeout+0x198>
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
  202268:	e59d300c 	ldr	r3, [sp, #12]
  20226c:	e59d1014 	ldr	r1, [sp, #20]
  202270:	e1a00003 	mov	r0, r3
  202274:	eb00068d 	bl	203cb0 <osalThreadEnqueueTimeoutS.lto_priv.47>
  202278:	e58d0020 	str	r0, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  20227c:	e59d3020 	ldr	r3, [sp, #32]
  202280:	e3530000 	cmp	r3, #0
  202284:	0a000002 	beq	202294 <iqReadTimeout+0xd4>
        osalSysUnlock();
  202288:	eb000674 	bl	203c60 <osalSysUnlock.lto_priv.32>
        return r;
  20228c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202290:	ea000030 	b	202358 <iqReadTimeout+0x198>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
  202294:	e59d300c 	ldr	r3, [sp, #12]
  202298:	e5933008 	ldr	r3, [r3, #8]
  20229c:	e3530000 	cmp	r3, #0
  2022a0:	0affffd8 	beq	202208 <iqReadTimeout+0x48>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
  2022a4:	e59d300c 	ldr	r3, [sp, #12]
  2022a8:	e5933008 	ldr	r3, [r3, #8]
  2022ac:	e2432001 	sub	r2, r3, #1
  2022b0:	e59d300c 	ldr	r3, [sp, #12]
  2022b4:	e5832008 	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
  2022b8:	e59d3008 	ldr	r3, [sp, #8]
  2022bc:	e2832001 	add	r2, r3, #1
  2022c0:	e58d2008 	str	r2, [sp, #8]
  2022c4:	e59d200c 	ldr	r2, [sp, #12]
  2022c8:	e5922018 	ldr	r2, [r2, #24]
  2022cc:	e2820001 	add	r0, r2, #1
  2022d0:	e59d100c 	ldr	r1, [sp, #12]
  2022d4:	e5810018 	str	r0, [r1, #24]
  2022d8:	e5d22000 	ldrb	r2, [r2]
  2022dc:	e5c32000 	strb	r2, [r3]
    if (iqp->q_rdptr >= iqp->q_top) {
  2022e0:	e59d300c 	ldr	r3, [sp, #12]
  2022e4:	e5932018 	ldr	r2, [r3, #24]
  2022e8:	e59d300c 	ldr	r3, [sp, #12]
  2022ec:	e5933010 	ldr	r3, [r3, #16]
  2022f0:	e1520003 	cmp	r2, r3
  2022f4:	3a000003 	bcc	202308 <iqReadTimeout+0x148>
      iqp->q_rdptr = iqp->q_buffer;
  2022f8:	e59d300c 	ldr	r3, [sp, #12]
  2022fc:	e593200c 	ldr	r2, [r3, #12]
  202300:	e59d300c 	ldr	r3, [sp, #12]
  202304:	e5832018 	str	r2, [r3, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
  202308:	e59d301c 	ldr	r3, [sp, #28]
  20230c:	e3530000 	cmp	r3, #0
  202310:	0a000002 	beq	202320 <iqReadTimeout+0x160>
      nfy(iqp);
  202314:	e59d301c 	ldr	r3, [sp, #28]
  202318:	e59d000c 	ldr	r0, [sp, #12]
  20231c:	e12fff33 	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
  202320:	eb00064e 	bl	203c60 <osalSysUnlock.lto_priv.32>

    r++;
  202324:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202328:	e2833001 	add	r3, r3, #1
  20232c:	e58d3024 	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
  202330:	e59d3004 	ldr	r3, [sp, #4]
  202334:	e2433001 	sub	r3, r3, #1
  202338:	e58d3004 	str	r3, [sp, #4]
  20233c:	e59d3004 	ldr	r3, [sp, #4]
  202340:	e3530000 	cmp	r3, #0
  202344:	1a000001 	bne	202350 <iqReadTimeout+0x190>
      return r;
  202348:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  20234c:	ea000001 	b	202358 <iqReadTimeout+0x198>
    }

    osalSysLock();
  202350:	eb00063e 	bl	203c50 <osalSysLock.lto_priv.35>
  202354:	eaffffce 	b	202294 <iqReadTimeout+0xd4>
  }
}
  202358:	e1a00003 	mov	r0, r3
  20235c:	e28dd02c 	add	sp, sp, #44	; 0x2c
  202360:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202370 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
  202370:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202374:	e24dd014 	sub	sp, sp, #20
  202378:	e58d000c 	str	r0, [sp, #12]
  20237c:	e58d1008 	str	r1, [sp, #8]
  202380:	e58d2004 	str	r2, [sp, #4]
  202384:	e58d3000 	str	r3, [sp]

  osalThreadQueueObjectInit(&oqp->q_waiting);
  202388:	e59d300c 	ldr	r3, [sp, #12]
  20238c:	e1a00003 	mov	r0, r3
  202390:	eb00063e 	bl	203c90 <osalThreadQueueObjectInit.lto_priv.51>
  oqp->q_counter = size;
  202394:	e59d300c 	ldr	r3, [sp, #12]
  202398:	e59d2004 	ldr	r2, [sp, #4]
  20239c:	e5832008 	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
  2023a0:	e59d300c 	ldr	r3, [sp, #12]
  2023a4:	e59d2008 	ldr	r2, [sp, #8]
  2023a8:	e583200c 	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
  2023ac:	e59d300c 	ldr	r3, [sp, #12]
  2023b0:	e59d2008 	ldr	r2, [sp, #8]
  2023b4:	e5832018 	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
  2023b8:	e59d300c 	ldr	r3, [sp, #12]
  2023bc:	e59d2008 	ldr	r2, [sp, #8]
  2023c0:	e5832014 	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
  2023c4:	e59d2008 	ldr	r2, [sp, #8]
  2023c8:	e59d3004 	ldr	r3, [sp, #4]
  2023cc:	e0822003 	add	r2, r2, r3
  2023d0:	e59d300c 	ldr	r3, [sp, #12]
  2023d4:	e5832010 	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
  2023d8:	e59d300c 	ldr	r3, [sp, #12]
  2023dc:	e59d2000 	ldr	r2, [sp]
  2023e0:	e583201c 	str	r2, [r3, #28]
  oqp->q_link    = link;
  2023e4:	e59d300c 	ldr	r3, [sp, #12]
  2023e8:	e59d2018 	ldr	r2, [sp, #24]
  2023ec:	e5832020 	str	r2, [r3, #32]
}
  2023f0:	e28dd014 	add	sp, sp, #20
  2023f4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202400 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
  202400:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202404:	e24dd01c 	sub	sp, sp, #28
  202408:	e58d000c 	str	r0, [sp, #12]
  20240c:	e1a03001 	mov	r3, r1
  202410:	e58d2004 	str	r2, [sp, #4]
  202414:	e5cd300b 	strb	r3, [sp, #11]

  osalSysLock();
  202418:	eb00060c 	bl	203c50 <osalSysLock.lto_priv.35>
  20241c:	ea00000a 	b	20244c <oqPutTimeout+0x4c>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
  202420:	e59d300c 	ldr	r3, [sp, #12]
  202424:	e59d1004 	ldr	r1, [sp, #4]
  202428:	e1a00003 	mov	r0, r3
  20242c:	eb00061f 	bl	203cb0 <osalThreadEnqueueTimeoutS.lto_priv.47>
  202430:	e58d0014 	str	r0, [sp, #20]
    if (msg < MSG_OK) {
  202434:	e59d3014 	ldr	r3, [sp, #20]
  202438:	e3530000 	cmp	r3, #0
  20243c:	aa000002 	bge	20244c <oqPutTimeout+0x4c>
      osalSysUnlock();
  202440:	eb000606 	bl	203c60 <osalSysUnlock.lto_priv.32>
      return msg;
  202444:	e59d3014 	ldr	r3, [sp, #20]
  202448:	ea000023 	b	2024dc <oqPutTimeout+0xdc>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
  20244c:	e59d300c 	ldr	r3, [sp, #12]
  202450:	e5933008 	ldr	r3, [r3, #8]
  202454:	e3530000 	cmp	r3, #0
  202458:	0afffff0 	beq	202420 <oqPutTimeout+0x20>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  20245c:	e59d300c 	ldr	r3, [sp, #12]
  202460:	e5933008 	ldr	r3, [r3, #8]
  202464:	e2432001 	sub	r2, r3, #1
  202468:	e59d300c 	ldr	r3, [sp, #12]
  20246c:	e5832008 	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
  202470:	e59d300c 	ldr	r3, [sp, #12]
  202474:	e5933014 	ldr	r3, [r3, #20]
  202478:	e2831001 	add	r1, r3, #1
  20247c:	e59d200c 	ldr	r2, [sp, #12]
  202480:	e5821014 	str	r1, [r2, #20]
  202484:	e5dd200b 	ldrb	r2, [sp, #11]
  202488:	e5c32000 	strb	r2, [r3]
  if (oqp->q_wrptr >= oqp->q_top) {
  20248c:	e59d300c 	ldr	r3, [sp, #12]
  202490:	e5932014 	ldr	r2, [r3, #20]
  202494:	e59d300c 	ldr	r3, [sp, #12]
  202498:	e5933010 	ldr	r3, [r3, #16]
  20249c:	e1520003 	cmp	r2, r3
  2024a0:	3a000003 	bcc	2024b4 <oqPutTimeout+0xb4>
    oqp->q_wrptr = oqp->q_buffer;
  2024a4:	e59d300c 	ldr	r3, [sp, #12]
  2024a8:	e593200c 	ldr	r2, [r3, #12]
  2024ac:	e59d300c 	ldr	r3, [sp, #12]
  2024b0:	e5832014 	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
  2024b4:	e59d300c 	ldr	r3, [sp, #12]
  2024b8:	e593301c 	ldr	r3, [r3, #28]
  2024bc:	e3530000 	cmp	r3, #0
  2024c0:	0a000003 	beq	2024d4 <oqPutTimeout+0xd4>
    oqp->q_notify(oqp);
  2024c4:	e59d300c 	ldr	r3, [sp, #12]
  2024c8:	e593301c 	ldr	r3, [r3, #28]
  2024cc:	e59d000c 	ldr	r0, [sp, #12]
  2024d0:	e12fff33 	blx	r3
  }

  osalSysUnlock();
  2024d4:	eb0005e1 	bl	203c60 <osalSysUnlock.lto_priv.32>

  return MSG_OK;
  2024d8:	e3a03000 	mov	r3, #0
}
  2024dc:	e1a00003 	mov	r0, r3
  2024e0:	e28dd01c 	add	sp, sp, #28
  2024e4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002024f0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
  2024f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2024f4:	e24dd014 	sub	sp, sp, #20
  2024f8:	e58d0004 	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
  2024fc:	e59d3004 	ldr	r3, [sp, #4]
  202500:	e5932014 	ldr	r2, [r3, #20]
  202504:	e59d3004 	ldr	r3, [sp, #4]
  202508:	e5933018 	ldr	r3, [r3, #24]
  20250c:	e1520003 	cmp	r2, r3
  202510:	1a000005 	bne	20252c <oqGetI+0x3c>
  202514:	e59d3004 	ldr	r3, [sp, #4]
  202518:	e5933008 	ldr	r3, [r3, #8]
  20251c:	e3530000 	cmp	r3, #0
  202520:	0a000001 	beq	20252c <oqGetI+0x3c>
  202524:	e3a03001 	mov	r3, #1
  202528:	ea000000 	b	202530 <oqGetI+0x40>
  20252c:	e3a03000 	mov	r3, #0
  202530:	e2033001 	and	r3, r3, #1
  202534:	e3530000 	cmp	r3, #0
  202538:	0a000001 	beq	202544 <oqGetI+0x54>
    return MSG_TIMEOUT;
  20253c:	e3e03000 	mvn	r3, #0
  202540:	ea00001a 	b	2025b0 <oqGetI+0xc0>
  }

  oqp->q_counter++;
  202544:	e59d3004 	ldr	r3, [sp, #4]
  202548:	e5933008 	ldr	r3, [r3, #8]
  20254c:	e2832001 	add	r2, r3, #1
  202550:	e59d3004 	ldr	r3, [sp, #4]
  202554:	e5832008 	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
  202558:	e59d3004 	ldr	r3, [sp, #4]
  20255c:	e5933018 	ldr	r3, [r3, #24]
  202560:	e2831001 	add	r1, r3, #1
  202564:	e59d2004 	ldr	r2, [sp, #4]
  202568:	e5821018 	str	r1, [r2, #24]
  20256c:	e5d33000 	ldrb	r3, [r3]
  202570:	e5cd300f 	strb	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
  202574:	e59d3004 	ldr	r3, [sp, #4]
  202578:	e5932018 	ldr	r2, [r3, #24]
  20257c:	e59d3004 	ldr	r3, [sp, #4]
  202580:	e5933010 	ldr	r3, [r3, #16]
  202584:	e1520003 	cmp	r2, r3
  202588:	3a000003 	bcc	20259c <oqGetI+0xac>
    oqp->q_rdptr = oqp->q_buffer;
  20258c:	e59d3004 	ldr	r3, [sp, #4]
  202590:	e593200c 	ldr	r2, [r3, #12]
  202594:	e59d3004 	ldr	r3, [sp, #4]
  202598:	e5832018 	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
  20259c:	e59d3004 	ldr	r3, [sp, #4]
  2025a0:	e3a01000 	mov	r1, #0
  2025a4:	e1a00003 	mov	r0, r3
  2025a8:	eb0005cc 	bl	203ce0 <osalThreadDequeueNextI.lto_priv.49>

  return (msg_t)b;
  2025ac:	e5dd300f 	ldrb	r3, [sp, #15]
}
  2025b0:	e1a00003 	mov	r0, r3
  2025b4:	e28dd014 	add	sp, sp, #20
  2025b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2025bc:	00000000 	andeq	r0, r0, r0

002025c0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  2025c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2025c4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
  2025c8:	e58d000c 	str	r0, [sp, #12]
  2025cc:	e58d1008 	str	r1, [sp, #8]
  2025d0:	e58d2004 	str	r2, [sp, #4]
  2025d4:	e58d3000 	str	r3, [sp]
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  2025d8:	e59d300c 	ldr	r3, [sp, #12]
  2025dc:	e593301c 	ldr	r3, [r3, #28]
  2025e0:	e58d301c 	str	r3, [sp, #28]
  size_t w = 0;
  2025e4:	e3a03000 	mov	r3, #0
  2025e8:	e58d3024 	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
  2025ec:	eb000597 	bl	203c50 <osalSysLock.lto_priv.35>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
  2025f0:	eb00059e 	bl	203c70 <osalOsGetSystemTimeX.lto_priv.48>
  2025f4:	e1a02000 	mov	r2, r0
  2025f8:	e59d3000 	ldr	r3, [sp]
  2025fc:	e0823003 	add	r3, r2, r3
  202600:	e58d3018 	str	r3, [sp, #24]
  202604:	ea000022 	b	202694 <oqWriteTimeout+0xd4>
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202608:	e59d3000 	ldr	r3, [sp]
  20260c:	e3730001 	cmn	r3, #1
  202610:	0a000002 	beq	202620 <oqWriteTimeout+0x60>
  202614:	e59d3000 	ldr	r3, [sp]
  202618:	e3530000 	cmp	r3, #0
  20261c:	1a000005 	bne	202638 <oqWriteTimeout+0x78>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
  202620:	e59d300c 	ldr	r3, [sp, #12]
  202624:	e59d1000 	ldr	r1, [sp]
  202628:	e1a00003 	mov	r0, r3
  20262c:	eb00059f 	bl	203cb0 <osalThreadEnqueueTimeoutS.lto_priv.47>
  202630:	e58d0020 	str	r0, [sp, #32]
  202634:	ea000010 	b	20267c <oqWriteTimeout+0xbc>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
  202638:	eb00058c 	bl	203c70 <osalOsGetSystemTimeX.lto_priv.48>
  20263c:	e1a02000 	mov	r2, r0
  202640:	e59d3018 	ldr	r3, [sp, #24]
  202644:	e0623003 	rsb	r3, r2, r3
  202648:	e58d3014 	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
  20264c:	e59d2014 	ldr	r2, [sp, #20]
  202650:	e59d3000 	ldr	r3, [sp]
  202654:	e1520003 	cmp	r2, r3
  202658:	9a000002 	bls	202668 <oqWriteTimeout+0xa8>
          osalSysUnlock();
  20265c:	eb00057f 	bl	203c60 <osalSysUnlock.lto_priv.32>
          return w;
  202660:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202664:	ea00003b 	b	202758 <oqWriteTimeout+0x198>
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
  202668:	e59d300c 	ldr	r3, [sp, #12]
  20266c:	e59d1014 	ldr	r1, [sp, #20]
  202670:	e1a00003 	mov	r0, r3
  202674:	eb00058d 	bl	203cb0 <osalThreadEnqueueTimeoutS.lto_priv.47>
  202678:	e58d0020 	str	r0, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  20267c:	e59d3020 	ldr	r3, [sp, #32]
  202680:	e3530000 	cmp	r3, #0
  202684:	0a000002 	beq	202694 <oqWriteTimeout+0xd4>
        osalSysUnlock();
  202688:	eb000574 	bl	203c60 <osalSysUnlock.lto_priv.32>
        return w;
  20268c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202690:	ea000030 	b	202758 <oqWriteTimeout+0x198>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
  202694:	e59d300c 	ldr	r3, [sp, #12]
  202698:	e5933008 	ldr	r3, [r3, #8]
  20269c:	e3530000 	cmp	r3, #0
  2026a0:	0affffd8 	beq	202608 <oqWriteTimeout+0x48>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
  2026a4:	e59d300c 	ldr	r3, [sp, #12]
  2026a8:	e5933008 	ldr	r3, [r3, #8]
  2026ac:	e2432001 	sub	r2, r3, #1
  2026b0:	e59d300c 	ldr	r3, [sp, #12]
  2026b4:	e5832008 	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
  2026b8:	e59d300c 	ldr	r3, [sp, #12]
  2026bc:	e5933014 	ldr	r3, [r3, #20]
  2026c0:	e2831001 	add	r1, r3, #1
  2026c4:	e59d200c 	ldr	r2, [sp, #12]
  2026c8:	e5821014 	str	r1, [r2, #20]
  2026cc:	e59d2008 	ldr	r2, [sp, #8]
  2026d0:	e2821001 	add	r1, r2, #1
  2026d4:	e58d1008 	str	r1, [sp, #8]
  2026d8:	e5d22000 	ldrb	r2, [r2]
  2026dc:	e5c32000 	strb	r2, [r3]
    if (oqp->q_wrptr >= oqp->q_top) {
  2026e0:	e59d300c 	ldr	r3, [sp, #12]
  2026e4:	e5932014 	ldr	r2, [r3, #20]
  2026e8:	e59d300c 	ldr	r3, [sp, #12]
  2026ec:	e5933010 	ldr	r3, [r3, #16]
  2026f0:	e1520003 	cmp	r2, r3
  2026f4:	3a000003 	bcc	202708 <oqWriteTimeout+0x148>
      oqp->q_wrptr = oqp->q_buffer;
  2026f8:	e59d300c 	ldr	r3, [sp, #12]
  2026fc:	e593200c 	ldr	r2, [r3, #12]
  202700:	e59d300c 	ldr	r3, [sp, #12]
  202704:	e5832014 	str	r2, [r3, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
  202708:	e59d301c 	ldr	r3, [sp, #28]
  20270c:	e3530000 	cmp	r3, #0
  202710:	0a000002 	beq	202720 <oqWriteTimeout+0x160>
      nfy(oqp);
  202714:	e59d301c 	ldr	r3, [sp, #28]
  202718:	e59d000c 	ldr	r0, [sp, #12]
  20271c:	e12fff33 	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
  202720:	eb00054e 	bl	203c60 <osalSysUnlock.lto_priv.32>

    w++;
  202724:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202728:	e2833001 	add	r3, r3, #1
  20272c:	e58d3024 	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
  202730:	e59d3004 	ldr	r3, [sp, #4]
  202734:	e2433001 	sub	r3, r3, #1
  202738:	e58d3004 	str	r3, [sp, #4]
  20273c:	e59d3004 	ldr	r3, [sp, #4]
  202740:	e3530000 	cmp	r3, #0
  202744:	1a000001 	bne	202750 <oqWriteTimeout+0x190>
      return w;
  202748:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  20274c:	ea000001 	b	202758 <oqWriteTimeout+0x198>
    }

    osalSysLock();
  202750:	eb00053e 	bl	203c50 <osalSysLock.lto_priv.35>
  202754:	eaffffce 	b	202694 <oqWriteTimeout+0xd4>
  }
}
  202758:	e1a00003 	mov	r0, r3
  20275c:	e28dd02c 	add	sp, sp, #44	; 0x2c
  202760:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202770 <port_lock.lto_priv.44>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  202770:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  202774:	e12fff1e 	bx	lr
	...

00202780 <port_unlock.lto_priv.42>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  202780:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  202784:	e12fff1e 	bx	lr
	...

00202790 <chSysLock.lto_priv.40>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  202790:	e92d4010 	push	{r4, lr}

  port_lock();
  202794:	ebfffff5 	bl	202770 <port_lock.lto_priv.44>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  202798:	e8bd8010 	pop	{r4, pc}
  20279c:	00000000 	andeq	r0, r0, r0

002027a0 <chSysUnlock.lto_priv.38>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  2027a0:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  2027a4:	ebfffff5 	bl	202780 <port_unlock.lto_priv.42>
}
  2027a8:	e8bd8010 	pop	{r4, pc}
  2027ac:	00000000 	andeq	r0, r0, r0

002027b0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
  2027b0:	e24dd008 	sub	sp, sp, #8
  2027b4:	e58d0004 	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
  2027b8:	e59d3004 	ldr	r3, [sp, #4]
  2027bc:	e59d2004 	ldr	r2, [sp, #4]
  2027c0:	e5832000 	str	r2, [r3]
}
  2027c4:	e28dd008 	add	sp, sp, #8
  2027c8:	e12fff1e 	bx	lr
  2027cc:	00000000 	andeq	r0, r0, r0

002027d0 <osalSysLock.lto_priv.36>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
  2027d0:	e92d4010 	push	{r4, lr}

  chSysLock();
  2027d4:	ebffffed 	bl	202790 <chSysLock.lto_priv.40>
}
  2027d8:	e8bd8010 	pop	{r4, pc}
  2027dc:	00000000 	andeq	r0, r0, r0

002027e0 <osalSysUnlock.lto_priv.33>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
  2027e0:	e92d4010 	push	{r4, lr}

  chSysUnlock();
  2027e4:	ebffffed 	bl	2027a0 <chSysUnlock.lto_priv.38>
}
  2027e8:	e8bd8010 	pop	{r4, pc}
  2027ec:	00000000 	andeq	r0, r0, r0

002027f0 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
  2027f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2027f4:	e24dd00c 	sub	sp, sp, #12
  2027f8:	e58d0004 	str	r0, [sp, #4]

  chEvtObjectInit(esp);
  2027fc:	e59d0004 	ldr	r0, [sp, #4]
  202800:	ebffffea 	bl	2027b0 <chEvtObjectInit>
}
  202804:	e28dd00c 	add	sp, sp, #12
  202808:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20280c:	00000000 	andeq	r0, r0, r0

00202810 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
  202810:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202814:	e24dd00c 	sub	sp, sp, #12
  202818:	e58d0004 	str	r0, [sp, #4]
  20281c:	e58d1000 	str	r1, [sp]

  chEvtBroadcastFlagsI(esp, flags);
  202820:	e59d1000 	ldr	r1, [sp]
  202824:	e59d0004 	ldr	r0, [sp, #4]
  202828:	eb000abc 	bl	205320 <chEvtBroadcastFlagsI>
}
  20282c:	e28dd00c 	add	sp, sp, #12
  202830:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202840 <_write.lto_priv.12>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
  202840:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202844:	e24dd014 	sub	sp, sp, #20
  202848:	e58d000c 	str	r0, [sp, #12]
  20284c:	e58d1008 	str	r1, [sp, #8]
  202850:	e58d2004 	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
  202854:	e59d300c 	ldr	r3, [sp, #12]
  202858:	e2830030 	add	r0, r3, #48	; 0x30
  20285c:	e3e03000 	mvn	r3, #0
  202860:	e59d2004 	ldr	r2, [sp, #4]
  202864:	e59d1008 	ldr	r1, [sp, #8]
  202868:	ebffff54 	bl	2025c0 <oqWriteTimeout>
  20286c:	e1a03000 	mov	r3, r0
                        n, TIME_INFINITE);
}
  202870:	e1a00003 	mov	r0, r3
  202874:	e28dd014 	add	sp, sp, #20
  202878:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20287c:	00000000 	andeq	r0, r0, r0

00202880 <_read.lto_priv.13>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
  202880:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202884:	e24dd014 	sub	sp, sp, #20
  202888:	e58d000c 	str	r0, [sp, #12]
  20288c:	e58d1008 	str	r1, [sp, #8]
  202890:	e58d2004 	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
  202894:	e59d300c 	ldr	r3, [sp, #12]
  202898:	e283000c 	add	r0, r3, #12
  20289c:	e3e03000 	mvn	r3, #0
  2028a0:	e59d2004 	ldr	r2, [sp, #4]
  2028a4:	e59d1008 	ldr	r1, [sp, #8]
  2028a8:	ebfffe44 	bl	2021c0 <iqReadTimeout>
  2028ac:	e1a03000 	mov	r3, r0
                       n, TIME_INFINITE);
}
  2028b0:	e1a00003 	mov	r0, r3
  2028b4:	e28dd014 	add	sp, sp, #20
  2028b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2028bc:	00000000 	andeq	r0, r0, r0

002028c0 <_put.lto_priv.14>:

static msg_t _put(void *ip, uint8_t b) {
  2028c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2028c4:	e24dd00c 	sub	sp, sp, #12
  2028c8:	e58d0004 	str	r0, [sp, #4]
  2028cc:	e1a03001 	mov	r3, r1
  2028d0:	e5cd3003 	strb	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
  2028d4:	e59d3004 	ldr	r3, [sp, #4]
  2028d8:	e2833030 	add	r3, r3, #48	; 0x30
  2028dc:	e5dd1003 	ldrb	r1, [sp, #3]
  2028e0:	e3e02000 	mvn	r2, #0
  2028e4:	e1a00003 	mov	r0, r3
  2028e8:	ebfffec4 	bl	202400 <oqPutTimeout>
  2028ec:	e1a03000 	mov	r3, r0
}
  2028f0:	e1a00003 	mov	r0, r3
  2028f4:	e28dd00c 	add	sp, sp, #12
  2028f8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2028fc:	00000000 	andeq	r0, r0, r0

00202900 <_get.lto_priv.15>:

static msg_t _get(void *ip) {
  202900:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202904:	e24dd00c 	sub	sp, sp, #12
  202908:	e58d0004 	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
  20290c:	e59d3004 	ldr	r3, [sp, #4]
  202910:	e283300c 	add	r3, r3, #12
  202914:	e3e01000 	mvn	r1, #0
  202918:	e1a00003 	mov	r0, r3
  20291c:	ebfffdef 	bl	2020e0 <iqGetTimeout>
  202920:	e1a03000 	mov	r3, r0
}
  202924:	e1a00003 	mov	r0, r3
  202928:	e28dd00c 	add	sp, sp, #12
  20292c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202930 <_putt.lto_priv.16>:

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
  202930:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202934:	e24dd014 	sub	sp, sp, #20
  202938:	e58d000c 	str	r0, [sp, #12]
  20293c:	e1a03001 	mov	r3, r1
  202940:	e58d2004 	str	r2, [sp, #4]
  202944:	e5cd300b 	strb	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
  202948:	e59d300c 	ldr	r3, [sp, #12]
  20294c:	e2833030 	add	r3, r3, #48	; 0x30
  202950:	e5dd100b 	ldrb	r1, [sp, #11]
  202954:	e59d2004 	ldr	r2, [sp, #4]
  202958:	e1a00003 	mov	r0, r3
  20295c:	ebfffea7 	bl	202400 <oqPutTimeout>
  202960:	e1a03000 	mov	r3, r0
}
  202964:	e1a00003 	mov	r0, r3
  202968:	e28dd014 	add	sp, sp, #20
  20296c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202970 <_gett.lto_priv.17>:

static msg_t _gett(void *ip, systime_t timeout) {
  202970:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202974:	e24dd00c 	sub	sp, sp, #12
  202978:	e58d0004 	str	r0, [sp, #4]
  20297c:	e58d1000 	str	r1, [sp]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
  202980:	e59d3004 	ldr	r3, [sp, #4]
  202984:	e283300c 	add	r3, r3, #12
  202988:	e59d1000 	ldr	r1, [sp]
  20298c:	e1a00003 	mov	r0, r3
  202990:	ebfffdd2 	bl	2020e0 <iqGetTimeout>
  202994:	e1a03000 	mov	r3, r0
}
  202998:	e1a00003 	mov	r0, r3
  20299c:	e28dd00c 	add	sp, sp, #12
  2029a0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002029b0 <_writet.lto_priv.18>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
  2029b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2029b4:	e24dd014 	sub	sp, sp, #20
  2029b8:	e58d000c 	str	r0, [sp, #12]
  2029bc:	e58d1008 	str	r1, [sp, #8]
  2029c0:	e58d2004 	str	r2, [sp, #4]
  2029c4:	e58d3000 	str	r3, [sp]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
  2029c8:	e59d300c 	ldr	r3, [sp, #12]
  2029cc:	e2830030 	add	r0, r3, #48	; 0x30
  2029d0:	e59d3000 	ldr	r3, [sp]
  2029d4:	e59d2004 	ldr	r2, [sp, #4]
  2029d8:	e59d1008 	ldr	r1, [sp, #8]
  2029dc:	ebfffef7 	bl	2025c0 <oqWriteTimeout>
  2029e0:	e1a03000 	mov	r3, r0
}
  2029e4:	e1a00003 	mov	r0, r3
  2029e8:	e28dd014 	add	sp, sp, #20
  2029ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

002029f0 <_readt.lto_priv.19>:

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
  2029f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2029f4:	e24dd014 	sub	sp, sp, #20
  2029f8:	e58d000c 	str	r0, [sp, #12]
  2029fc:	e58d1008 	str	r1, [sp, #8]
  202a00:	e58d2004 	str	r2, [sp, #4]
  202a04:	e58d3000 	str	r3, [sp]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
  202a08:	e59d300c 	ldr	r3, [sp, #12]
  202a0c:	e283000c 	add	r0, r3, #12
  202a10:	e59d3000 	ldr	r3, [sp]
  202a14:	e59d2004 	ldr	r2, [sp, #4]
  202a18:	e59d1008 	ldr	r1, [sp, #8]
  202a1c:	ebfffde7 	bl	2021c0 <iqReadTimeout>
  202a20:	e1a03000 	mov	r3, r0
}
  202a24:	e1a00003 	mov	r0, r3
  202a28:	e28dd014 	add	sp, sp, #20
  202a2c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202a30 <_ctl.lto_priv.20>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
  202a30:	e24dd018 	sub	sp, sp, #24
  202a34:	e58d000c 	str	r0, [sp, #12]
  202a38:	e58d1008 	str	r1, [sp, #8]
  202a3c:	e58d2004 	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
  202a40:	e59d300c 	ldr	r3, [sp, #12]
  202a44:	e58d3014 	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);

  switch (operation) {
  202a48:	e59d3008 	ldr	r3, [sp, #8]
  202a4c:	e3530001 	cmp	r3, #1
#endif
  case CHN_CTL_INVALID:
    osalDbgAssert(false, "invalid CTL operation");
    break;
  }
  return MSG_OK;
  202a50:	e3a03000 	mov	r3, #0
}
  202a54:	e1a00003 	mov	r0, r3
  202a58:	e28dd018 	add	sp, sp, #24
  202a5c:	e12fff1e 	bx	lr

00202a60 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
  202a60:	e92d4010 	push	{r4, lr}

  sd_lld_init();
  202a64:	ebfff971 	bl	201030 <sd_lld_init>
}
  202a68:	e8bd8010 	pop	{r4, pc}
  202a6c:	00000000 	andeq	r0, r0, r0

00202a70 <sdObjectInit>:
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {
  202a70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202a74:	e24dd00c 	sub	sp, sp, #12
  202a78:	e58d0004 	str	r0, [sp, #4]

  sdp->vmt = &vmt;
  202a7c:	e59d2004 	ldr	r2, [sp, #4]
  202a80:	e3053520 	movw	r3, #21792	; 0x5520
  202a84:	e3403020 	movt	r3, #32
  202a88:	e5823000 	str	r3, [r2]
  osalEventObjectInit(&sdp->event);
  202a8c:	e59d3004 	ldr	r3, [sp, #4]
  202a90:	e2833004 	add	r3, r3, #4
  202a94:	e1a00003 	mov	r0, r3
  202a98:	ebffff54 	bl	2027f0 <osalEventObjectInit>
  sdp->state = SD_STOP;
  202a9c:	e59d3004 	ldr	r3, [sp, #4]
  202aa0:	e3a02001 	mov	r2, #1
  202aa4:	e5c32008 	strb	r2, [r3, #8]
}
  202aa8:	e28dd00c 	add	sp, sp, #12
  202aac:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202ab0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
  202ab0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202ab4:	e24dd00c 	sub	sp, sp, #12
  202ab8:	e58d0004 	str	r0, [sp, #4]
  202abc:	e58d1000 	str	r1, [sp]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
  202ac0:	ebffff42 	bl	2027d0 <osalSysLock.lto_priv.36>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  202ac4:	e59d1000 	ldr	r1, [sp]
  202ac8:	e59d0004 	ldr	r0, [sp, #4]
  202acc:	ebfff987 	bl	2010f0 <sd_lld_start>
  sdp->state = SD_READY;
  202ad0:	e59d3004 	ldr	r3, [sp, #4]
  202ad4:	e3a02002 	mov	r2, #2
  202ad8:	e5c32008 	strb	r2, [r3, #8]
  osalSysUnlock();
  202adc:	ebffff3f 	bl	2027e0 <osalSysUnlock.lto_priv.33>
}
  202ae0:	e28dd00c 	add	sp, sp, #12
  202ae4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202af0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
  202af0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202af4:	e24dd00c 	sub	sp, sp, #12
  202af8:	e58d0004 	str	r0, [sp, #4]
  202afc:	e1a03001 	mov	r3, r1
  202b00:	e5cd3003 	strb	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
  202b04:	e59d3004 	ldr	r3, [sp, #4]
  202b08:	e5933014 	ldr	r3, [r3, #20]
  202b0c:	e3530000 	cmp	r3, #0
  202b10:	1a000004 	bne	202b28 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  202b14:	e59d3004 	ldr	r3, [sp, #4]
  202b18:	e2833004 	add	r3, r3, #4
  202b1c:	e3a01004 	mov	r1, #4
  202b20:	e1a00003 	mov	r0, r3
  202b24:	ebffff39 	bl	202810 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
  202b28:	e59d3004 	ldr	r3, [sp, #4]
  202b2c:	e283300c 	add	r3, r3, #12
  202b30:	e5dd2003 	ldrb	r2, [sp, #3]
  202b34:	e1a01002 	mov	r1, r2
  202b38:	e1a00003 	mov	r0, r3
  202b3c:	eb000497 	bl	203da0 <iqPutI>
  202b40:	e1a03000 	mov	r3, r0
  202b44:	e3530000 	cmp	r3, #0
  202b48:	aa000004 	bge	202b60 <sdIncomingDataI+0x70>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
  202b4c:	e59d3004 	ldr	r3, [sp, #4]
  202b50:	e2833004 	add	r3, r3, #4
  202b54:	e3a01b01 	mov	r1, #1024	; 0x400
  202b58:	e1a00003 	mov	r0, r3
  202b5c:	ebffff2b 	bl	202810 <osalEventBroadcastFlagsI>
}
  202b60:	e28dd00c 	add	sp, sp, #12
  202b64:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202b70 <port_lock.lto_priv.45>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  202b70:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  202b74:	e12fff1e 	bx	lr
	...

00202b80 <port_unlock.lto_priv.43>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  202b80:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  202b84:	e12fff1e 	bx	lr
	...

00202b90 <chSysLock.lto_priv.41>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  202b90:	e92d4010 	push	{r4, lr}

  port_lock();
  202b94:	ebfffff5 	bl	202b70 <port_lock.lto_priv.45>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  202b98:	e8bd8010 	pop	{r4, pc}
  202b9c:	00000000 	andeq	r0, r0, r0

00202ba0 <chSysUnlock.lto_priv.39>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  202ba0:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  202ba4:	ebfffff5 	bl	202b80 <port_unlock.lto_priv.43>
}
  202ba8:	e8bd8010 	pop	{r4, pc}
  202bac:	00000000 	andeq	r0, r0, r0

00202bb0 <osalSysLock.lto_priv.37>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
  202bb0:	e92d4010 	push	{r4, lr}

  chSysLock();
  202bb4:	ebfffff5 	bl	202b90 <chSysLock.lto_priv.41>
}
  202bb8:	e8bd8010 	pop	{r4, pc}
  202bbc:	00000000 	andeq	r0, r0, r0

00202bc0 <osalSysUnlock.lto_priv.34>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
  202bc0:	e92d4010 	push	{r4, lr}

  chSysUnlock();
  202bc4:	ebfffff5 	bl	202ba0 <chSysUnlock.lto_priv.39>
}
  202bc8:	e8bd8010 	pop	{r4, pc}
  202bcc:	00000000 	andeq	r0, r0, r0

00202bd0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
  202bd0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202bd4:	e24dd00c 	sub	sp, sp, #12
  202bd8:	e58d0004 	str	r0, [sp, #4]

  return chThdSuspendS(trp);
  202bdc:	e59d0004 	ldr	r0, [sp, #4]
  202be0:	eb000962 	bl	205170 <chThdSuspendS>
  202be4:	e1a03000 	mov	r3, r0
}
  202be8:	e1a00003 	mov	r0, r3
  202bec:	e28dd00c 	add	sp, sp, #12
  202bf0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202c00 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
  202c00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202c04:	e24dd00c 	sub	sp, sp, #12
  202c08:	e58d0004 	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
  202c0c:	e59d0004 	ldr	r0, [sp, #4]
  202c10:	eb0009b6 	bl	2052f0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
  202c14:	e28dd00c 	add	sp, sp, #12
  202c18:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  202c1c:	00000000 	andeq	r0, r0, r0

00202c20 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
  202c20:	e92d4010 	push	{r4, lr}

  spi_lld_init();
  202c24:	ebfff6d1 	bl	200770 <spi_lld_init>
}
  202c28:	e8bd8010 	pop	{r4, pc}
  202c2c:	00000000 	andeq	r0, r0, r0

00202c30 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
  202c30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202c34:	e24dd00c 	sub	sp, sp, #12
  202c38:	e58d0004 	str	r0, [sp, #4]

  spip->state = SPI_STOP;
  202c3c:	e59d3004 	ldr	r3, [sp, #4]
  202c40:	e3a02001 	mov	r2, #1
  202c44:	e5c32000 	strb	r2, [r3]
  spip->config = NULL;
  202c48:	e59d3004 	ldr	r3, [sp, #4]
  202c4c:	e3a02000 	mov	r2, #0
  202c50:	e5832004 	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
  202c54:	e59d3004 	ldr	r3, [sp, #4]
  202c58:	e3a02000 	mov	r2, #0
  202c5c:	e5832008 	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
  202c60:	e59d3004 	ldr	r3, [sp, #4]
  202c64:	e283300c 	add	r3, r3, #12
  202c68:	e1a00003 	mov	r0, r3
  202c6c:	ebffffe3 	bl	202c00 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
  202c70:	e28dd00c 	add	sp, sp, #12
  202c74:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202c80 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
  202c80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202c84:	e24dd00c 	sub	sp, sp, #12
  202c88:	e58d0004 	str	r0, [sp, #4]
  202c8c:	e58d1000 	str	r1, [sp]

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  202c90:	ebffffc6 	bl	202bb0 <osalSysLock.lto_priv.37>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
  202c94:	e59d3004 	ldr	r3, [sp, #4]
  202c98:	e59d2000 	ldr	r2, [sp]
  202c9c:	e5832004 	str	r2, [r3, #4]
  spi_lld_start(spip);
  202ca0:	e59d0004 	ldr	r0, [sp, #4]
  202ca4:	ebfff6cd 	bl	2007e0 <spi_lld_start>
  spip->state = SPI_READY;
  202ca8:	e59d3004 	ldr	r3, [sp, #4]
  202cac:	e3a02002 	mov	r2, #2
  202cb0:	e5c32000 	strb	r2, [r3]
  osalSysUnlock();
  202cb4:	ebffffc1 	bl	202bc0 <osalSysUnlock.lto_priv.34>
}
  202cb8:	e28dd00c 	add	sp, sp, #12
  202cbc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202cc0 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
  202cc0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202cc4:	e24dd014 	sub	sp, sp, #20
  202cc8:	e58d000c 	str	r0, [sp, #12]
  202ccc:	e58d1008 	str	r1, [sp, #8]
  202cd0:	e58d2004 	str	r2, [sp, #4]
  202cd4:	e58d3000 	str	r3, [sp]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  202cd8:	ebffffb4 	bl	202bb0 <osalSysLock.lto_priv.37>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
  202cdc:	e59d300c 	ldr	r3, [sp, #12]
  202ce0:	e3a02003 	mov	r2, #3
  202ce4:	e5c32000 	strb	r2, [r3]
  202ce8:	e59d3000 	ldr	r3, [sp]
  202cec:	e59d2004 	ldr	r2, [sp, #4]
  202cf0:	e59d1008 	ldr	r1, [sp, #8]
  202cf4:	e59d000c 	ldr	r0, [sp, #12]
  202cf8:	ebfff768 	bl	200aa0 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
  202cfc:	e59d300c 	ldr	r3, [sp, #12]
  202d00:	e2833008 	add	r3, r3, #8
  202d04:	e1a00003 	mov	r0, r3
  202d08:	ebffffb0 	bl	202bd0 <osalThreadSuspendS>
  osalSysUnlock();
  202d0c:	ebffffab 	bl	202bc0 <osalSysUnlock.lto_priv.34>
}
  202d10:	e28dd014 	add	sp, sp, #20
  202d14:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202d20 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
  202d20:	e92d4010 	push	{r4, lr}

  /* Disabling PMC write protection. */
  pmcDisableWP();
  202d24:	e3a03901 	mov	r3, #16384	; 0x4000
  202d28:	e34f3001 	movt	r3, #61441	; 0xf001
  202d2c:	e3a02c43 	mov	r2, #17152	; 0x4300
  202d30:	e345204d 	movt	r2, #20557	; 0x504d
  202d34:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling matrix clock */
  pmcEnableH32MX();
  202d38:	e3a03901 	mov	r3, #16384	; 0x4000
  202d3c:	e34f3001 	movt	r3, #61441	; 0xf001
  202d40:	e3a02c43 	mov	r2, #17152	; 0x4300
  202d44:	e345204d 	movt	r2, #20557	; 0x504d
  202d48:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  202d4c:	e3a03901 	mov	r3, #16384	; 0x4000
  202d50:	e34f3001 	movt	r3, #61441	; 0xf001
  202d54:	e3a02901 	mov	r2, #16384	; 0x4000
  202d58:	e34f2001 	movt	r2, #61441	; 0xf001
  202d5c:	e5922010 	ldr	r2, [r2, #16]
  202d60:	e3822901 	orr	r2, r2, #16384	; 0x4000
  202d64:	e5832010 	str	r2, [r3, #16]
  202d68:	e3a03901 	mov	r3, #16384	; 0x4000
  202d6c:	e34f3001 	movt	r3, #61441	; 0xf001
  202d70:	e3042301 	movw	r2, #17153	; 0x4301
  202d74:	e345204d 	movt	r2, #20557	; 0x504d
  202d78:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  pmcEnableH64MX();
  202d7c:	e3a03901 	mov	r3, #16384	; 0x4000
  202d80:	e34f3001 	movt	r3, #61441	; 0xf001
  202d84:	e3a02c43 	mov	r2, #17152	; 0x4300
  202d88:	e345204d 	movt	r2, #20557	; 0x504d
  202d8c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  202d90:	e3a03901 	mov	r3, #16384	; 0x4000
  202d94:	e34f3001 	movt	r3, #61441	; 0xf001
  202d98:	e3a02901 	mov	r2, #16384	; 0x4000
  202d9c:	e34f2001 	movt	r2, #61441	; 0xf001
  202da0:	e5922010 	ldr	r2, [r2, #16]
  202da4:	e3822902 	orr	r2, r2, #32768	; 0x8000
  202da8:	e5832010 	str	r2, [r3, #16]
  202dac:	e3a03901 	mov	r3, #16384	; 0x4000
  202db0:	e34f3001 	movt	r3, #61441	; 0xf001
  202db4:	e3042301 	movw	r2, #17153	; 0x4301
  202db8:	e345204d 	movt	r2, #20557	; 0x504d
  202dbc:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling write protection.  */
  pmcEnableWP();
  202dc0:	e3a03901 	mov	r3, #16384	; 0x4000
  202dc4:	e34f3001 	movt	r3, #61441	; 0xf001
  202dc8:	e3042301 	movw	r2, #17153	; 0x4301
  202dcc:	e345204d 	movt	r2, #20557	; 0x504d
  202dd0:	e58320e4 	str	r2, [r3, #228]	; 0xe4

#if defined(SAMA_DMA_REQUIRED)
  dmaInit();
  202dd4:	eb000209 	bl	203600 <dmaInit>
#endif
  /* Advanced interrupt controller init */
  aicInit();
  202dd8:	eb000128 	bl	203280 <aicInit>
}
  202ddc:	e8bd8010 	pop	{r4, pc}

00202de0 <sama_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void sama_clock_init(void) {
  202de0:	e24dd010 	sub	sp, sp, #16
#if !SAMA_NO_INIT
  uint32_t mor, pllar, mckr, mainf;
  /* Disabling PMC write protection. */
  pmcDisableWP();
  202de4:	e3a03901 	mov	r3, #16384	; 0x4000
  202de8:	e34f3001 	movt	r3, #61441	; 0xf001
  202dec:	e3a02c43 	mov	r2, #17152	; 0x4300
  202df0:	e345204d 	movt	r2, #20557	; 0x504d
  202df4:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* 
   * Enforcing the reset default configuration of clock tree. 
   */  
  /* Setting Slow Clock source to OSCRC. */
  SCKC->SCKC_CR = 0U;
  202df8:	e3083050 	movw	r3, #32848	; 0x8050
  202dfc:	e34f3804 	movt	r3, #63492	; 0xf804
  202e00:	e3a02000 	mov	r2, #0
  202e04:	e5832000 	str	r2, [r3]

  /* Enabling MOSCRC. */
  PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  202e08:	e3a02901 	mov	r2, #16384	; 0x4000
  202e0c:	e34f2001 	movt	r2, #61441	; 0xf001
  202e10:	e3a03901 	mov	r3, #16384	; 0x4000
  202e14:	e34f3001 	movt	r3, #61441	; 0xf001
  202e18:	e5933020 	ldr	r3, [r3, #32]
  202e1c:	e3833837 	orr	r3, r3, #3604480	; 0x370000
  202e20:	e3833008 	orr	r3, r3, #8
  202e24:	e5823020 	str	r3, [r2, #32]
  while (!(PMC->PMC_SR & PMC_SR_MOSCRCS))
  202e28:	e3a03901 	mov	r3, #16384	; 0x4000
  202e2c:	e34f3001 	movt	r3, #61441	; 0xf001
  202e30:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202e34:	e2033802 	and	r3, r3, #131072	; 0x20000
  202e38:	e3530000 	cmp	r3, #0
  202e3c:	0afffff9 	beq	202e28 <sama_clock_init+0x48>
    ;                                       /* Waits until MOSCRC is stable.*/

  /* Switching Main Oscillator Source to MOSRC. */
  mor = PMC->CKGR_MOR | CKGR_MOR_KEY_PASSWD;
  202e40:	e3a03901 	mov	r3, #16384	; 0x4000
  202e44:	e34f3001 	movt	r3, #61441	; 0xf001
  202e48:	e5933020 	ldr	r3, [r3, #32]
  202e4c:	e3833837 	orr	r3, r3, #3604480	; 0x370000
  202e50:	e58d300c 	str	r3, [sp, #12]
  mor &= ~CKGR_MOR_MOSCSEL;
  202e54:	e59d300c 	ldr	r3, [sp, #12]
  202e58:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
  202e5c:	e58d300c 	str	r3, [sp, #12]
  mor |= SAMA_MOSC_MOSCRC;
  PMC->CKGR_MOR = mor;
  202e60:	e3a03901 	mov	r3, #16384	; 0x4000
  202e64:	e34f3001 	movt	r3, #61441	; 0xf001
  202e68:	e59d200c 	ldr	r2, [sp, #12]
  202e6c:	e5832020 	str	r2, [r3, #32]

  while (!(PMC->PMC_SR & PMC_SR_MOSCSELS))
  202e70:	e3a03901 	mov	r3, #16384	; 0x4000
  202e74:	e34f3001 	movt	r3, #61441	; 0xf001
  202e78:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202e7c:	e2033801 	and	r3, r3, #65536	; 0x10000
  202e80:	e3530000 	cmp	r3, #0
  202e84:	0afffff9 	beq	202e70 <sama_clock_init+0x90>
    ;                                       /* Waits until MOSCSEL has changed.*/

  /* Switching Master Clock source to Main Clock. */
  mckr = PMC->PMC_MCKR;
  202e88:	e3a03901 	mov	r3, #16384	; 0x4000
  202e8c:	e34f3001 	movt	r3, #61441	; 0xf001
  202e90:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  202e94:	e58d3008 	str	r3, [sp, #8]
  mckr &= ~PMC_MCKR_CSS_Msk;
  202e98:	e59d3008 	ldr	r3, [sp, #8]
  202e9c:	e3c33003 	bic	r3, r3, #3
  202ea0:	e58d3008 	str	r3, [sp, #8]
  mckr |= PMC_MCKR_CSS_MAIN_CLK;
  202ea4:	e59d3008 	ldr	r3, [sp, #8]
  202ea8:	e3833001 	orr	r3, r3, #1
  202eac:	e58d3008 	str	r3, [sp, #8]
  PMC->PMC_MCKR = mckr;
  202eb0:	e3a03901 	mov	r3, #16384	; 0x4000
  202eb4:	e34f3001 	movt	r3, #61441	; 0xf001
  202eb8:	e59d2008 	ldr	r2, [sp, #8]
  202ebc:	e5832030 	str	r2, [r3, #48]	; 0x30

  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
  202ec0:	e3a03901 	mov	r3, #16384	; 0x4000
  202ec4:	e34f3001 	movt	r3, #61441	; 0xf001
  202ec8:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202ecc:	e2033008 	and	r3, r3, #8
  202ed0:	e3530000 	cmp	r3, #0
  202ed4:	0afffff9 	beq	202ec0 <sama_clock_init+0xe0>
    ;                                       /* Waits until Master Clock is stable.*/

  /* Counter Clock Source to MOSCRC. */
  PMC->CKGR_MCFR &= ~CKGR_MCFR_CCSS;
  202ed8:	e3a03901 	mov	r3, #16384	; 0x4000
  202edc:	e34f3001 	movt	r3, #61441	; 0xf001
  202ee0:	e3a02901 	mov	r2, #16384	; 0x4000
  202ee4:	e34f2001 	movt	r2, #61441	; 0xf001
  202ee8:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  202eec:	e3c22401 	bic	r2, r2, #16777216	; 0x1000000
  202ef0:	e5832024 	str	r2, [r3, #36]	; 0x24

  /*
   * Main oscillator configuration block.
   */
  /* Setting Slow clock source. */
  SCKC->SCKC_CR = SAMA_OSC_SEL;
  202ef4:	e3083050 	movw	r3, #32848	; 0x8050
  202ef8:	e34f3804 	movt	r3, #63492	; 0xf804
  202efc:	e3a02008 	mov	r2, #8
  202f00:	e5832000 	str	r2, [r3]
  while ((SAMA_OSC_SEL && !(PMC->PMC_SR & PMC_SR_OSCSELS)) ||
  202f04:	e3a03901 	mov	r3, #16384	; 0x4000
  202f08:	e34f3001 	movt	r3, #61441	; 0xf001
  202f0c:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202f10:	e2033080 	and	r3, r3, #128	; 0x80
  202f14:	e3530000 	cmp	r3, #0
  202f18:	0afffff9 	beq	202f04 <sama_clock_init+0x124>
        (!SAMA_OSC_SEL &&  (PMC->PMC_SR & PMC_SR_OSCSELS)))
    ;                                       /* Waits until MOSCxxS switch is done.*/
  mor = PMC->CKGR_MOR | CKGR_MOR_KEY_PASSWD;
  202f1c:	e3a03901 	mov	r3, #16384	; 0x4000
  202f20:	e34f3001 	movt	r3, #61441	; 0xf001
  202f24:	e5933020 	ldr	r3, [r3, #32]
  202f28:	e3833837 	orr	r3, r3, #3604480	; 0x370000
  202f2c:	e58d300c 	str	r3, [sp, #12]
#if SAMA_MOSCXT_ENABLED
  mor |= CKGR_MOR_MOSCXTEN;
  202f30:	e59d300c 	ldr	r3, [sp, #12]
  202f34:	e3833001 	orr	r3, r3, #1
  202f38:	e58d300c 	str	r3, [sp, #12]
  PMC->CKGR_MOR = mor;
  202f3c:	e3a03901 	mov	r3, #16384	; 0x4000
  202f40:	e34f3001 	movt	r3, #61441	; 0xf001
  202f44:	e59d200c 	ldr	r2, [sp, #12]
  202f48:	e5832020 	str	r2, [r3, #32]
  while (!(PMC->PMC_SR & PMC_SR_MOSCXTS))
  202f4c:	e3a03901 	mov	r3, #16384	; 0x4000
  202f50:	e34f3001 	movt	r3, #61441	; 0xf001
  202f54:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202f58:	e2033001 	and	r3, r3, #1
  202f5c:	e3530000 	cmp	r3, #0
  202f60:	0afffff9 	beq	202f4c <sama_clock_init+0x16c>
    ;                                       /* Waits until MOSCXT is stable.*/
  /* Counter Clock Source to MOSCXT. */
  PMC->CKGR_MCFR |= CKGR_MCFR_CCSS;
  202f64:	e3a03901 	mov	r3, #16384	; 0x4000
  202f68:	e34f3001 	movt	r3, #61441	; 0xf001
  202f6c:	e3a02901 	mov	r2, #16384	; 0x4000
  202f70:	e34f2001 	movt	r2, #61441	; 0xf001
  202f74:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  202f78:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
  202f7c:	e5832024 	str	r2, [r3, #36]	; 0x24
#else
  mor &= ~CKGR_MOR_MOSCXTEN;
  PMC->CKGR_MOR = mor;
#endif

  PMC->CKGR_MCFR |= CKGR_MCFR_RCMEAS;
  202f80:	e3a03901 	mov	r3, #16384	; 0x4000
  202f84:	e34f3001 	movt	r3, #61441	; 0xf001
  202f88:	e3a02901 	mov	r2, #16384	; 0x4000
  202f8c:	e34f2001 	movt	r2, #61441	; 0xf001
  202f90:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  202f94:	e3822601 	orr	r2, r2, #1048576	; 0x100000
  202f98:	e5832024 	str	r2, [r3, #36]	; 0x24
  while (!(PMC->CKGR_MCFR & CKGR_MCFR_MAINFRDY))
  202f9c:	e3a03901 	mov	r3, #16384	; 0x4000
  202fa0:	e34f3001 	movt	r3, #61441	; 0xf001
  202fa4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  202fa8:	e2033801 	and	r3, r3, #65536	; 0x10000
  202fac:	e3530000 	cmp	r3, #0
  202fb0:	0afffff9 	beq	202f9c <sama_clock_init+0x1bc>
    ;
  mainf = CKGR_MCFR_MAINF(PMC->CKGR_MCFR);
  202fb4:	e3a03901 	mov	r3, #16384	; 0x4000
  202fb8:	e34f3001 	movt	r3, #61441	; 0xf001
  202fbc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  202fc0:	e6ff3073 	uxth	r3, r3
  202fc4:	e58d3004 	str	r3, [sp, #4]
   * should be activable through a switch.
   */
  (void)mainf;

  /* Switching Main Clock source. */
  mor &= ~CKGR_MOR_MOSCSEL;
  202fc8:	e59d300c 	ldr	r3, [sp, #12]
  202fcc:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
  202fd0:	e58d300c 	str	r3, [sp, #12]
  mor |= SAMA_MOSC_SEL;
  202fd4:	e59d300c 	ldr	r3, [sp, #12]
  202fd8:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
  202fdc:	e58d300c 	str	r3, [sp, #12]
  PMC->CKGR_MOR = mor;
  202fe0:	e3a03901 	mov	r3, #16384	; 0x4000
  202fe4:	e34f3001 	movt	r3, #61441	; 0xf001
  202fe8:	e59d200c 	ldr	r2, [sp, #12]
  202fec:	e5832020 	str	r2, [r3, #32]

  /* Eventually disabling MOSCRC. */
#if !SAMA_MOSCRC_ENABLED
  PMC->CKGR_MOR &= ~ CKGR_MOR_MOSCRCEN;
  202ff0:	e3a03901 	mov	r3, #16384	; 0x4000
  202ff4:	e34f3001 	movt	r3, #61441	; 0xf001
  202ff8:	e3a02901 	mov	r2, #16384	; 0x4000
  202ffc:	e34f2001 	movt	r2, #61441	; 0xf001
  203000:	e5922020 	ldr	r2, [r2, #32]
  203004:	e3c22008 	bic	r2, r2, #8
  203008:	e5832020 	str	r2, [r3, #32]
#endif

/*
 * PLLA configuration block.
 */
  pllar = SAMA_PLLA_ONE | CKGR_PLLAR_PLLACOUNT(0x3F);
  20300c:	e3a03c3f 	mov	r3, #16128	; 0x3f00
  203010:	e3423000 	movt	r3, #8192	; 0x2000
  203014:	e58d3000 	str	r3, [sp]
#if SAMA_ACTIVATE_PLLA
  pllar |= CKGR_PLLAR_DIVA_BYPASS | SAMA_PLLA_MUL;
  203018:	e59d3000 	ldr	r3, [sp]
  20301c:	e3833752 	orr	r3, r3, #21495808	; 0x1480000
  203020:	e3833001 	orr	r3, r3, #1
  203024:	e58d3000 	str	r3, [sp]
#endif
  PMC->CKGR_PLLAR = pllar;                  /* Writing PLLA register.       */
  203028:	e3a03901 	mov	r3, #16384	; 0x4000
  20302c:	e34f3001 	movt	r3, #61441	; 0xf001
  203030:	e59d2000 	ldr	r2, [sp]
  203034:	e5832028 	str	r2, [r3, #40]	; 0x28

#if SAMA_ACTIVATE_PLLA
  while (!(PMC->PMC_SR & PMC_SR_LOCKA))
  203038:	e3a03901 	mov	r3, #16384	; 0x4000
  20303c:	e34f3001 	movt	r3, #61441	; 0xf001
  203040:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  203044:	e2033002 	and	r3, r3, #2
  203048:	e3530000 	cmp	r3, #0
  20304c:	0afffff9 	beq	203038 <sama_clock_init+0x258>
#endif

/*
 * Master clock configuration block.
 */
  mckr = PMC->PMC_MCKR;
  203050:	e3a03901 	mov	r3, #16384	; 0x4000
  203054:	e34f3001 	movt	r3, #61441	; 0xf001
  203058:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  20305c:	e58d3008 	str	r3, [sp, #8]
  mckr &= ~PMC_MCKR_CSS_Msk;
  203060:	e59d3008 	ldr	r3, [sp, #8]
  203064:	e3c33003 	bic	r3, r3, #3
  203068:	e58d3008 	str	r3, [sp, #8]
  mckr |= SAMA_MCK_SEL;
  20306c:	e59d3008 	ldr	r3, [sp, #8]
  203070:	e3833002 	orr	r3, r3, #2
  203074:	e58d3008 	str	r3, [sp, #8]
  PMC->PMC_MCKR = mckr;
  203078:	e3a03901 	mov	r3, #16384	; 0x4000
  20307c:	e34f3001 	movt	r3, #61441	; 0xf001
  203080:	e59d2008 	ldr	r2, [sp, #8]
  203084:	e5832030 	str	r2, [r3, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
  203088:	e3a03901 	mov	r3, #16384	; 0x4000
  20308c:	e34f3001 	movt	r3, #61441	; 0xf001
  203090:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  203094:	e2033008 	and	r3, r3, #8
  203098:	e3530000 	cmp	r3, #0
  20309c:	0afffff9 	beq	203088 <sama_clock_init+0x2a8>
    ;                                       /* Waits until MCK is stable.   */

  mckr &= ~(PMC_MCKR_PRES_Msk | PMC_MCKR_MDIV_Msk | PMC_MCKR_H32MXDIV);
  2030a0:	e59d3008 	ldr	r3, [sp, #8]
  2030a4:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
  2030a8:	e3c33e37 	bic	r3, r3, #880	; 0x370
  2030ac:	e58d3008 	str	r3, [sp, #8]
  
  /* Note that prescaler and divider must be changed with separate accesses.*/
  mckr |= SAMA_MCK_PRES;
  mckr |= SAMA_MCK_MDIV;
  2030b0:	e59d3008 	ldr	r3, [sp, #8]
  2030b4:	e3833c03 	orr	r3, r3, #768	; 0x300
  2030b8:	e58d3008 	str	r3, [sp, #8]
  mckr |= SAMA_H64MX_H32MX_DIV;
  2030bc:	e59d3008 	ldr	r3, [sp, #8]
  2030c0:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
  2030c4:	e58d3008 	str	r3, [sp, #8]
#if SAMA_PLLADIV2_EN
  mckr |= PMC_MCKR_PLLADIV2;
  2030c8:	e59d3008 	ldr	r3, [sp, #8]
  2030cc:	e3833a01 	orr	r3, r3, #4096	; 0x1000
  2030d0:	e58d3008 	str	r3, [sp, #8]
#else
  mckr &= ~PMC_MCKR_PLLADIV2;
#endif
  PMC->PMC_MCKR = mckr;
  2030d4:	e3a03901 	mov	r3, #16384	; 0x4000
  2030d8:	e34f3001 	movt	r3, #61441	; 0xf001
  2030dc:	e59d2008 	ldr	r2, [sp, #8]
  2030e0:	e5832030 	str	r2, [r3, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
  2030e4:	e3a03901 	mov	r3, #16384	; 0x4000
  2030e8:	e34f3001 	movt	r3, #61441	; 0xf001
  2030ec:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  2030f0:	e2033008 	and	r3, r3, #8
  2030f4:	e3530000 	cmp	r3, #0
  2030f8:	0afffff9 	beq	2030e4 <sama_clock_init+0x304>
    ;                                       /* Waits until MCK is stable.   */

  /* Enabling write protection.  */
  pmcEnableWP();
  2030fc:	e3a03901 	mov	r3, #16384	; 0x4000
  203100:	e34f3001 	movt	r3, #61441	; 0xf001
  203104:	e3042301 	movw	r2, #17153	; 0x4301
  203108:	e345204d 	movt	r2, #20557	; 0x504d
  20310c:	e58320e4 	str	r2, [r3, #228]	; 0xe4

#endif /* !SAMA_NO_INIT */
}
  203110:	e28dd010 	add	sp, sp, #16
  203114:	e12fff1e 	bx	lr
	...

00203120 <port_lock_from_isr.lto_priv.30>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  203120:	e12fff1e 	bx	lr
	...

00203130 <port_unlock_from_isr.lto_priv.28>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  203130:	e12fff1e 	bx	lr
	...

00203140 <chSysLockFromISR.lto_priv.26>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  203140:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  203144:	ebfffff5 	bl	203120 <port_lock_from_isr.lto_priv.30>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  203148:	e8bd8010 	pop	{r4, pc}
  20314c:	00000000 	andeq	r0, r0, r0

00203150 <chSysUnlockFromISR.lto_priv.24>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  203150:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  203154:	ebfffff5 	bl	203130 <port_unlock_from_isr.lto_priv.28>
}
  203158:	e8bd8010 	pop	{r4, pc}
  20315c:	00000000 	andeq	r0, r0, r0

00203160 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
  203160:	e92d4010 	push	{r4, lr}

  chSysLockFromISR();
  203164:	ebfffff5 	bl	203140 <chSysLockFromISR.lto_priv.26>
}
  203168:	e8bd8010 	pop	{r4, pc}
  20316c:	00000000 	andeq	r0, r0, r0

00203170 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
  203170:	e92d4010 	push	{r4, lr}

  chSysUnlockFromISR();
  203174:	ebfffff5 	bl	203150 <chSysUnlockFromISR.lto_priv.24>
}
  203178:	e8bd8010 	pop	{r4, pc}
  20317c:	00000000 	andeq	r0, r0, r0

00203180 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
  203180:	e92d4010 	push	{r4, lr}

  chSysTimerHandlerI();
  203184:	eb000479 	bl	204370 <chSysTimerHandlerI>
}
  203188:	e8bd8010 	pop	{r4, pc}
  20318c:	00000000 	andeq	r0, r0, r0

00203190 <PIT_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(PIT_Handler) {
  203190:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203194:	e24dd00c 	sub	sp, sp, #12
  uint32_t ivr;
  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
  203198:	ebfffff0 	bl	203160 <osalSysLockFromISR>
  ivr = PIT->PIT_PIVR;    /* acknowledge PIT interrupt */
  20319c:	e3083030 	movw	r3, #32816	; 0x8030
  2031a0:	e34f3804 	movt	r3, #63492	; 0xf804
  2031a4:	e5933008 	ldr	r3, [r3, #8]
  2031a8:	e58d3004 	str	r3, [sp, #4]
  osalDbgAssert((ivr & PIT_PIVR_PICNT_Msk) == (1 << PIT_PIVR_PICNT_Pos),
      "check for lost tick");
  osalOsTimerHandlerI();
  2031ac:	ebfffff3 	bl	203180 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
  2031b0:	ebffffee 	bl	203170 <osalSysUnlockFromISR>
  aicAckInt();
  2031b4:	e3a03903 	mov	r3, #49152	; 0xc000
  2031b8:	e34f3803 	movt	r3, #63491	; 0xf803
  2031bc:	e3a02001 	mov	r2, #1
  2031c0:	e5832038 	str	r2, [r3, #56]	; 0x38
  OSAL_IRQ_EPILOGUE();
  2031c4:	eb000631 	bl	204a90 <chSchIsPreemptionRequired>
  2031c8:	e1a03000 	mov	r3, r0
}
  2031cc:	e1a00003 	mov	r0, r3
  2031d0:	e28dd00c 	add	sp, sp, #12
  2031d4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002031e0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
  2031e0:	e92d4010 	push	{r4, lr}

#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC)
  /* Enabling PIT.*/
  pmcEnablePIT();
  2031e4:	e3a03901 	mov	r3, #16384	; 0x4000
  2031e8:	e34f3001 	movt	r3, #61441	; 0xf001
  2031ec:	e3a02c43 	mov	r2, #17152	; 0x4300
  2031f0:	e345204d 	movt	r2, #20557	; 0x504d
  2031f4:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  2031f8:	e3a03901 	mov	r3, #16384	; 0x4000
  2031fc:	e34f3001 	movt	r3, #61441	; 0xf001
  203200:	e3a02901 	mov	r2, #16384	; 0x4000
  203204:	e34f2001 	movt	r2, #61441	; 0xf001
  203208:	e5922010 	ldr	r2, [r2, #16]
  20320c:	e3822008 	orr	r2, r2, #8
  203210:	e5832010 	str	r2, [r3, #16]
  203214:	e3a03901 	mov	r3, #16384	; 0x4000
  203218:	e34f3001 	movt	r3, #61441	; 0xf001
  20321c:	e3042301 	movw	r2, #17153	; 0x4301
  203220:	e345204d 	movt	r2, #20557	; 0x504d
  203224:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  PIT->PIT_MR = PIT_MR_PIV((SAMA_PIT / OSAL_ST_FREQUENCY) - 1);
  203228:	e3083030 	movw	r3, #32816	; 0x8030
  20322c:	e34f3804 	movt	r3, #63492	; 0xf804
  203230:	e3012442 	movw	r2, #5186	; 0x1442
  203234:	e5832000 	str	r2, [r3]
  PIT->PIT_MR |= PIT_MR_PITEN | PIT_MR_PITIEN;
  203238:	e3083030 	movw	r3, #32816	; 0x8030
  20323c:	e34f3804 	movt	r3, #63492	; 0xf804
  203240:	e3082030 	movw	r2, #32816	; 0x8030
  203244:	e34f2804 	movt	r2, #63492	; 0xf804
  203248:	e5922000 	ldr	r2, [r2]
  20324c:	e3822403 	orr	r2, r2, #50331648	; 0x3000000
  203250:	e5832000 	str	r2, [r3]

  /* IRQ enabled.*/
  aicSetSourcePriority(ID_PIT, SAMA_ST_IRQ_PRIORITY);
  203254:	e3a01000 	mov	r1, #0
  203258:	e3a00003 	mov	r0, #3
  20325c:	eb00001f 	bl	2032e0 <aicSetSourcePriority>
  aicSetSourceHandler(ID_PIT, PIT_Handler);
  203260:	e3031190 	movw	r1, #12688	; 0x3190
  203264:	e3401020 	movt	r1, #32
  203268:	e3a00003 	mov	r0, #3
  20326c:	eb00003b 	bl	203360 <aicSetSourceHandler>
  aicEnableInt(ID_PIT);
  203270:	e3a00003 	mov	r0, #3
  203274:	eb000051 	bl	2033c0 <aicEnableInt>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
  203278:	e8bd8010 	pop	{r4, pc}
  20327c:	00000000 	andeq	r0, r0, r0

00203280 <aicInit>:
 * @brief   AIC Initialization.
 * @note    Better reset everything in the AIC.
 *
 * @notapi
 */
void aicInit(void) {
  203280:	e24dd008 	sub	sp, sp, #8

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  203284:	e3a03903 	mov	r3, #49152	; 0xc000
  203288:	e34f3803 	movt	r3, #63491	; 0xf803
  20328c:	e58d3000 	str	r3, [sp]
  Aic *aic = AIC;
#endif

  unsigned i;
  /* Disable all interrupts */
  for (i = 1; i < ID_PERIPH_COUNT; i++) {
  203290:	e3a03001 	mov	r3, #1
  203294:	e58d3004 	str	r3, [sp, #4]
  203298:	ea000008 	b	2032c0 <aicInit+0x40>
    aic->AIC_SSR = i;
  20329c:	e59d3000 	ldr	r3, [sp]
  2032a0:	e59d2004 	ldr	r2, [sp, #4]
  2032a4:	e5832000 	str	r2, [r3]
    aic->AIC_IDCR = AIC_IDCR_INTD;
  2032a8:	e59d3000 	ldr	r3, [sp]
  2032ac:	e3a02001 	mov	r2, #1
  2032b0:	e5832044 	str	r2, [r3, #68]	; 0x44
  Aic *aic = AIC;
#endif

  unsigned i;
  /* Disable all interrupts */
  for (i = 1; i < ID_PERIPH_COUNT; i++) {
  2032b4:	e59d3004 	ldr	r3, [sp, #4]
  2032b8:	e2833001 	add	r3, r3, #1
  2032bc:	e58d3004 	str	r3, [sp, #4]
  2032c0:	e59d3004 	ldr	r3, [sp, #4]
  2032c4:	e353004e 	cmp	r3, #78	; 0x4e
  2032c8:	9afffff3 	bls	20329c <aicInit+0x1c>
    aic->AIC_SSR = i;
    aic->AIC_IDCR = AIC_IDCR_INTD;
  }
}
  2032cc:	e28dd008 	add	sp, sp, #8
  2032d0:	e12fff1e 	bx	lr
	...

002032e0 <aicSetSourcePriority>:
 * @note    Source cannot be ID_SAIC_FIQ (0).
 *
 * @param[in] source    interrupt source to configure
 * @param[in] priority  priority level of the selected source.
 */
void aicSetSourcePriority(uint32_t source, uint8_t priority) {
  2032e0:	e24dd010 	sub	sp, sp, #16
  2032e4:	e58d0004 	str	r0, [sp, #4]
  2032e8:	e1a03001 	mov	r3, r1
  2032ec:	e5cd3003 	strb	r3, [sp, #3]

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  2032f0:	e3a03903 	mov	r3, #49152	; 0xc000
  2032f4:	e34f3803 	movt	r3, #63491	; 0xf803
  2032f8:	e58d300c 	str	r3, [sp, #12]
#endif

  osalDbgCheck(source != ID_SAIC_FIQ);
  osalDbgAssert(SAMA_IRQ_IS_VALID_PRIORITY(priority), "invalid irq priority");
  /* Disable write protection */
  aicDisableWP(aic);
  2032fc:	e59d200c 	ldr	r2, [sp, #12]
  203300:	e3a03c43 	mov	r3, #17152	; 0x4300
  203304:	e3443149 	movt	r3, #16713	; 0x4149
  203308:	e58230e4 	str	r3, [r2, #228]	; 0xe4
  /* Set source id */
  aic->AIC_SSR = source;
  20330c:	e59d300c 	ldr	r3, [sp, #12]
  203310:	e59d2004 	ldr	r2, [sp, #4]
  203314:	e5832000 	str	r2, [r3]
  /* Disable the interrupt first */
  aic->AIC_IDCR = AIC_IDCR_INTD;
  203318:	e59d300c 	ldr	r3, [sp, #12]
  20331c:	e3a02001 	mov	r2, #1
  203320:	e5832044 	str	r2, [r3, #68]	; 0x44
  /* Configure priority */
  aic->AIC_SMR = AIC_SMR_PRIOR(priority);
  203324:	e5dd3003 	ldrb	r3, [sp, #3]
  203328:	e2032007 	and	r2, r3, #7
  20332c:	e59d300c 	ldr	r3, [sp, #12]
  203330:	e5832004 	str	r2, [r3, #4]
  /* Clear interrupt */
  aic->AIC_ICCR = AIC_ICCR_INTCLR;
  203334:	e59d300c 	ldr	r3, [sp, #12]
  203338:	e3a02001 	mov	r2, #1
  20333c:	e5832048 	str	r2, [r3, #72]	; 0x48
  /* Enable write protection */
  aicEnableWP(aic);
  203340:	e59d200c 	ldr	r2, [sp, #12]
  203344:	e3043301 	movw	r3, #17153	; 0x4301
  203348:	e3443149 	movt	r3, #16713	; 0x4149
  20334c:	e58230e4 	str	r3, [r2, #228]	; 0xe4
}
  203350:	e28dd010 	add	sp, sp, #16
  203354:	e12fff1e 	bx	lr
	...

00203360 <aicSetSourceHandler>:
 * @brief   Sets the source handler of an interrupt.
 *
 * @param[in] source    interrupt source to configure
 * @param[in] handler   handler for the interrupt source selected
 */
void aicSetSourceHandler(uint32_t source, bool (*handler)(void)) {
  203360:	e24dd010 	sub	sp, sp, #16
  203364:	e58d0004 	str	r0, [sp, #4]
  203368:	e58d1000 	str	r1, [sp]

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  20336c:	e3a03903 	mov	r3, #49152	; 0xc000
  203370:	e34f3803 	movt	r3, #63491	; 0xf803
  203374:	e58d300c 	str	r3, [sp, #12]
#else
  Aic *aic = AIC;
#endif

  /* Disable write protection */
  aicDisableWP(aic);
  203378:	e59d200c 	ldr	r2, [sp, #12]
  20337c:	e3a03c43 	mov	r3, #17152	; 0x4300
  203380:	e3443149 	movt	r3, #16713	; 0x4149
  203384:	e58230e4 	str	r3, [r2, #228]	; 0xe4
  /* Select source and assign handler */
  aic->AIC_SSR = AIC_SSR_INTSEL(source);
  203388:	e59d3004 	ldr	r3, [sp, #4]
  20338c:	e203207f 	and	r2, r3, #127	; 0x7f
  203390:	e59d300c 	ldr	r3, [sp, #12]
  203394:	e5832000 	str	r2, [r3]
  aic->AIC_SVR = (uint32_t)handler;
  203398:	e59d2000 	ldr	r2, [sp]
  20339c:	e59d300c 	ldr	r3, [sp, #12]
  2033a0:	e5832008 	str	r2, [r3, #8]
  /* Enable write protection */
  aicEnableWP(aic);
  2033a4:	e59d200c 	ldr	r2, [sp, #12]
  2033a8:	e3043301 	movw	r3, #17153	; 0x4301
  2033ac:	e3443149 	movt	r3, #16713	; 0x4149
  2033b0:	e58230e4 	str	r3, [r2, #228]	; 0xe4
}
  2033b4:	e28dd010 	add	sp, sp, #16
  2033b8:	e12fff1e 	bx	lr
  2033bc:	00000000 	andeq	r0, r0, r0

002033c0 <aicEnableInt>:
/**
 * @brief   Enables interrupts coming from the source.
 *
 * @param[in] source    interrupt source to enable
 */
void aicEnableInt(uint32_t source) {
  2033c0:	e24dd010 	sub	sp, sp, #16
  2033c4:	e58d0004 	str	r0, [sp, #4]

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  2033c8:	e3a03903 	mov	r3, #49152	; 0xc000
  2033cc:	e34f3803 	movt	r3, #63491	; 0xf803
  2033d0:	e58d300c 	str	r3, [sp, #12]
#else
  Aic *aic = AIC;
#endif

  aic->AIC_SSR = AIC_SSR_INTSEL(source);
  2033d4:	e59d3004 	ldr	r3, [sp, #4]
  2033d8:	e203207f 	and	r2, r3, #127	; 0x7f
  2033dc:	e59d300c 	ldr	r3, [sp, #12]
  2033e0:	e5832000 	str	r2, [r3]
  aic->AIC_IECR = AIC_IECR_INTEN;
  2033e4:	e59d300c 	ldr	r3, [sp, #12]
  2033e8:	e3a02001 	mov	r2, #1
  2033ec:	e5832040 	str	r2, [r3, #64]	; 0x40
}
  2033f0:	e28dd010 	add	sp, sp, #16
  2033f4:	e12fff1e 	bx	lr
	...

00203400 <dmaHandler>:
/*===========================================================================*/

/**
 * @brief XDMAC interrupt handler
 */
OSAL_IRQ_HANDLER(dmaHandler) {
  203400:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203404:	e24dd024 	sub	sp, sp, #36	; 0x24
  uint32_t cont;

  OSAL_IRQ_PROLOGUE();
  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  203408:	e3a03000 	mov	r3, #0
  20340c:	e58d301c 	str	r3, [sp, #28]
  203410:	ea00006c 	b	2035c8 <dmaHandler+0x1c8>
    uint32_t chan, gis, flags;

    Xdmac *xdmac = dmaControllerSelect(cont);
  203414:	e59d301c 	ldr	r3, [sp, #28]
  203418:	e3530000 	cmp	r3, #0
  20341c:	1a000002 	bne	20342c <dmaHandler+0x2c>
  203420:	e3a03000 	mov	r3, #0
  203424:	e34f3001 	movt	r3, #61441	; 0xf001
  203428:	ea000001 	b	203434 <dmaHandler+0x34>
  20342c:	e3a03901 	mov	r3, #16384	; 0x4000
  203430:	e34f3000 	movt	r3, #61440	; 0xf000
  203434:	e58d3010 	str	r3, [sp, #16]

    /* Read Global Interrupt Status Register */
    gis = dmaGetGlobalInt(xdmac);
  203438:	e59d3010 	ldr	r3, [sp, #16]
  20343c:	e5933018 	ldr	r3, [r3, #24]
  203440:	e58d300c 	str	r3, [sp, #12]

    if ((gis & 0xFFFF) == 0)
  203444:	e59d300c 	ldr	r3, [sp, #12]
  203448:	e6ff3073 	uxth	r3, r3
  20344c:	e3530000 	cmp	r3, #0
  203450:	0a000058 	beq	2035b8 <dmaHandler+0x1b8>
    /* There is no interrupt pending for this xdmac controller */
      continue;

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  203454:	e3a03000 	mov	r3, #0
  203458:	e58d3018 	str	r3, [sp, #24]
  20345c:	ea000051 	b	2035a8 <dmaHandler+0x1a8>
      sama_dma_channel_t *channel = &_sama_dma_channel_t[(cont * XDMAC_CHANNELS) + chan];
  203460:	e59d301c 	ldr	r3, [sp, #28]
  203464:	e1a02203 	lsl	r2, r3, #4
  203468:	e59d3018 	ldr	r3, [sp, #24]
  20346c:	e0823003 	add	r3, r2, r3
  203470:	e1a02203 	lsl	r2, r3, #4
  203474:	e30039d8 	movw	r3, #2520	; 0x9d8
  203478:	e3403021 	movt	r3, #33	; 0x21
  20347c:	e0823003 	add	r3, r2, r3
  203480:	e58d3008 	str	r3, [sp, #8]
      bool pendingInt = FALSE;
  203484:	e3a03000 	mov	r3, #0
  203488:	e5cd3017 	strb	r3, [sp, #23]

      if (!(gis & (0x1 << chan)))
  20348c:	e3a02001 	mov	r2, #1
  203490:	e59d3018 	ldr	r3, [sp, #24]
  203494:	e1a03312 	lsl	r3, r2, r3
  203498:	e1a02003 	mov	r2, r3
  20349c:	e59d300c 	ldr	r3, [sp, #12]
  2034a0:	e0033002 	and	r3, r3, r2
  2034a4:	e3530000 	cmp	r3, #0
  2034a8:	0a000038 	beq	203590 <dmaHandler+0x190>
      /* There is no pending interrupt for this channel */
        continue;

      if (channel->state == SAMA_DMA_FREE)
  2034ac:	e59d3008 	ldr	r3, [sp, #8]
  2034b0:	e5d33005 	ldrb	r3, [r3, #5]
  2034b4:	e3530000 	cmp	r3, #0
  2034b8:	0a000036 	beq	203598 <dmaHandler+0x198>
      /* Channel is free */
        continue;

      uint32_t cis = dmaGetChannelInt(channel);
  2034bc:	e59d3008 	ldr	r3, [sp, #8]
  2034c0:	e5932000 	ldr	r2, [r3]
  2034c4:	e59d3008 	ldr	r3, [sp, #8]
  2034c8:	e5d33004 	ldrb	r3, [r3, #4]
  2034cc:	e1a03303 	lsl	r3, r3, #6
  2034d0:	e0823003 	add	r3, r2, r3
  2034d4:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
  2034d8:	e58d3004 	str	r3, [sp, #4]

      if (cis & XDMAC_CIS_BIS) {
  2034dc:	e59d3004 	ldr	r3, [sp, #4]
  2034e0:	e2033001 	and	r3, r3, #1
  2034e4:	e3530000 	cmp	r3, #0
  2034e8:	0a00000b 	beq	20351c <dmaHandler+0x11c>
        if (!(dmaGetChannelIntMask(channel) & XDMAC_CIM_LIM)) {
  2034ec:	e59d3008 	ldr	r3, [sp, #8]
  2034f0:	e5932000 	ldr	r2, [r3]
  2034f4:	e59d3008 	ldr	r3, [sp, #8]
  2034f8:	e5d33004 	ldrb	r3, [r3, #4]
  2034fc:	e1a03303 	lsl	r3, r3, #6
  203500:	e0823003 	add	r3, r2, r3
  203504:	e5933058 	ldr	r3, [r3, #88]	; 0x58
  203508:	e2033002 	and	r3, r3, #2
  20350c:	e3530000 	cmp	r3, #0
  203510:	1a000001 	bne	20351c <dmaHandler+0x11c>
          pendingInt = TRUE;
  203514:	e3a03001 	mov	r3, #1
  203518:	e5cd3017 	strb	r3, [sp, #23]
        }
      }

      if (cis & XDMAC_CIS_LIS) {
  20351c:	e59d3004 	ldr	r3, [sp, #4]
  203520:	e2033002 	and	r3, r3, #2
  203524:	e3530000 	cmp	r3, #0
  203528:	0a000001 	beq	203534 <dmaHandler+0x134>
        pendingInt = TRUE;
  20352c:	e3a03001 	mov	r3, #1
  203530:	e5cd3017 	strb	r3, [sp, #23]
      }

      if (cis & XDMAC_CIS_DIS) {
  203534:	e59d3004 	ldr	r3, [sp, #4]
  203538:	e2033004 	and	r3, r3, #4
  20353c:	e3530000 	cmp	r3, #0
  203540:	0a000001 	beq	20354c <dmaHandler+0x14c>
        pendingInt = TRUE;
  203544:	e3a03001 	mov	r3, #1
  203548:	e5cd3017 	strb	r3, [sp, #23]
      }
      flags = cis;
  20354c:	e59d3004 	ldr	r3, [sp, #4]
  203550:	e58d3000 	str	r3, [sp]

      /* Execute callback */
      if (pendingInt && channel->dma_func) {
  203554:	e5dd3017 	ldrb	r3, [sp, #23]
  203558:	e3530000 	cmp	r3, #0
  20355c:	0a00000e 	beq	20359c <dmaHandler+0x19c>
  203560:	e59d3008 	ldr	r3, [sp, #8]
  203564:	e5933008 	ldr	r3, [r3, #8]
  203568:	e3530000 	cmp	r3, #0
  20356c:	0a00000a 	beq	20359c <dmaHandler+0x19c>
        channel->dma_func(channel->dma_param,flags);
  203570:	e59d3008 	ldr	r3, [sp, #8]
  203574:	e5933008 	ldr	r3, [r3, #8]
  203578:	e59d2008 	ldr	r2, [sp, #8]
  20357c:	e592200c 	ldr	r2, [r2, #12]
  203580:	e59d1000 	ldr	r1, [sp]
  203584:	e1a00002 	mov	r0, r2
  203588:	e12fff33 	blx	r3
  20358c:	ea000002 	b	20359c <dmaHandler+0x19c>
      sama_dma_channel_t *channel = &_sama_dma_channel_t[(cont * XDMAC_CHANNELS) + chan];
      bool pendingInt = FALSE;

      if (!(gis & (0x1 << chan)))
      /* There is no pending interrupt for this channel */
        continue;
  203590:	e1a00000 	nop			; (mov r0, r0)
  203594:	ea000000 	b	20359c <dmaHandler+0x19c>

      if (channel->state == SAMA_DMA_FREE)
      /* Channel is free */
        continue;
  203598:	e1a00000 	nop			; (mov r0, r0)

    if ((gis & 0xFFFF) == 0)
    /* There is no interrupt pending for this xdmac controller */
      continue;

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  20359c:	e59d3018 	ldr	r3, [sp, #24]
  2035a0:	e2833001 	add	r3, r3, #1
  2035a4:	e58d3018 	str	r3, [sp, #24]
  2035a8:	e59d3018 	ldr	r3, [sp, #24]
  2035ac:	e353000f 	cmp	r3, #15
  2035b0:	9affffaa 	bls	203460 <dmaHandler+0x60>
  2035b4:	ea000000 	b	2035bc <dmaHandler+0x1bc>
    /* Read Global Interrupt Status Register */
    gis = dmaGetGlobalInt(xdmac);

    if ((gis & 0xFFFF) == 0)
    /* There is no interrupt pending for this xdmac controller */
      continue;
  2035b8:	e1a00000 	nop			; (mov r0, r0)
 */
OSAL_IRQ_HANDLER(dmaHandler) {
  uint32_t cont;

  OSAL_IRQ_PROLOGUE();
  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  2035bc:	e59d301c 	ldr	r3, [sp, #28]
  2035c0:	e2833001 	add	r3, r3, #1
  2035c4:	e58d301c 	str	r3, [sp, #28]
  2035c8:	e59d301c 	ldr	r3, [sp, #28]
  2035cc:	e3530001 	cmp	r3, #1
  2035d0:	9affff8f 	bls	203414 <dmaHandler+0x14>
      if (pendingInt && channel->dma_func) {
        channel->dma_func(channel->dma_param,flags);
      }
    }
  }
  aicAckInt();
  2035d4:	e3a03903 	mov	r3, #49152	; 0xc000
  2035d8:	e34f3803 	movt	r3, #63491	; 0xf803
  2035dc:	e3a02001 	mov	r2, #1
  2035e0:	e5832038 	str	r2, [r3, #56]	; 0x38
  OSAL_IRQ_EPILOGUE();
  2035e4:	eb000529 	bl	204a90 <chSchIsPreemptionRequired>
  2035e8:	e1a03000 	mov	r3, r0
}
  2035ec:	e1a00003 	mov	r0, r3
  2035f0:	e28dd024 	add	sp, sp, #36	; 0x24
  2035f4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203600 <dmaInit>:
/**
 * @brief   SAMA DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
  203600:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203604:	e24dd014 	sub	sp, sp, #20

  uint8_t cont, chan;

  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  203608:	e3a03000 	mov	r3, #0
  20360c:	e5cd300f 	strb	r3, [sp, #15]
  203610:	ea00003d 	b	20370c <dmaInit+0x10c>

    Xdmac *xdmac = dmaControllerSelect(cont);
  203614:	e5dd300f 	ldrb	r3, [sp, #15]
  203618:	e3530000 	cmp	r3, #0
  20361c:	1a000002 	bne	20362c <dmaInit+0x2c>
  203620:	e3a03000 	mov	r3, #0
  203624:	e34f3001 	movt	r3, #61441	; 0xf001
  203628:	ea000001 	b	203634 <dmaInit+0x34>
  20362c:	e3a03901 	mov	r3, #16384	; 0x4000
  203630:	e34f3000 	movt	r3, #61440	; 0xf000
  203634:	e58d3008 	str	r3, [sp, #8]

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  203638:	e3a03000 	mov	r3, #0
  20363c:	e5cd300e 	strb	r3, [sp, #14]
  203640:	ea00001e 	b	2036c0 <dmaInit+0xc0>
      sama_dma_channel_t *channel = &_sama_dma_channel_t[(cont * XDMAC_CHANNELS) + chan];
  203644:	e5dd300f 	ldrb	r3, [sp, #15]
  203648:	e1a02203 	lsl	r2, r3, #4
  20364c:	e5dd300e 	ldrb	r3, [sp, #14]
  203650:	e0823003 	add	r3, r2, r3
  203654:	e1a02203 	lsl	r2, r3, #4
  203658:	e30039d8 	movw	r3, #2520	; 0x9d8
  20365c:	e3403021 	movt	r3, #33	; 0x21
  203660:	e0823003 	add	r3, r2, r3
  203664:	e58d3004 	str	r3, [sp, #4]

      /* Initialization of the specific channel */
      channel->xdmac    = xdmac;
  203668:	e59d3004 	ldr	r3, [sp, #4]
  20366c:	e59d2008 	ldr	r2, [sp, #8]
  203670:	e5832000 	str	r2, [r3]
      channel->chid     = chan;
  203674:	e59d3004 	ldr	r3, [sp, #4]
  203678:	e5dd200e 	ldrb	r2, [sp, #14]
  20367c:	e5c32004 	strb	r2, [r3, #4]
      channel->state    = SAMA_DMA_FREE;
  203680:	e59d3004 	ldr	r3, [sp, #4]
  203684:	e3a02000 	mov	r2, #0
  203688:	e5c32005 	strb	r2, [r3, #5]
      channel->dma_func = NULL;
  20368c:	e59d3004 	ldr	r3, [sp, #4]
  203690:	e3a02000 	mov	r2, #0
  203694:	e5832008 	str	r2, [r3, #8]

      /* Clear interrupts */
      dmaGetChannelInt(channel);
  203698:	e59d3004 	ldr	r3, [sp, #4]
  20369c:	e5932000 	ldr	r2, [r3]
  2036a0:	e59d3004 	ldr	r3, [sp, #4]
  2036a4:	e5d33004 	ldrb	r3, [r3, #4]
  2036a8:	e1a03303 	lsl	r3, r3, #6
  2036ac:	e0823003 	add	r3, r2, r3
  2036b0:	e593305c 	ldr	r3, [r3, #92]	; 0x5c

  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {

    Xdmac *xdmac = dmaControllerSelect(cont);

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  2036b4:	e5dd300e 	ldrb	r3, [sp, #14]
  2036b8:	e2833001 	add	r3, r3, #1
  2036bc:	e5cd300e 	strb	r3, [sp, #14]
  2036c0:	e5dd300e 	ldrb	r3, [sp, #14]
  2036c4:	e353000f 	cmp	r3, #15
  2036c8:	9affffdd 	bls	203644 <dmaInit+0x44>

      /* Clear interrupts */
      dmaGetChannelInt(channel);
    }

    uint32_t id = dmaGetControllerId(xdmac);
  2036cc:	e59d2008 	ldr	r2, [sp, #8]
  2036d0:	e3a03000 	mov	r3, #0
  2036d4:	e34f3001 	movt	r3, #61441	; 0xf001
  2036d8:	e1520003 	cmp	r2, r3
  2036dc:	1a000001 	bne	2036e8 <dmaInit+0xe8>
  2036e0:	e3a03006 	mov	r3, #6
  2036e4:	ea000000 	b	2036ec <dmaInit+0xec>
  2036e8:	e3a03007 	mov	r3, #7
  2036ec:	e58d3000 	str	r3, [sp]
    /* set aic source handler */
    aicSetSourceHandler(id, dmaHandler);
  2036f0:	e3031400 	movw	r1, #13312	; 0x3400
  2036f4:	e3401020 	movt	r1, #32
  2036f8:	e59d0000 	ldr	r0, [sp]
  2036fc:	ebffff17 	bl	203360 <aicSetSourceHandler>
 */
void dmaInit(void) {

  uint8_t cont, chan;

  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  203700:	e5dd300f 	ldrb	r3, [sp, #15]
  203704:	e2833001 	add	r3, r3, #1
  203708:	e5cd300f 	strb	r3, [sp, #15]
  20370c:	e5dd300f 	ldrb	r3, [sp, #15]
  203710:	e3530001 	cmp	r3, #1
  203714:	9affffbe 	bls	203614 <dmaInit+0x14>

    uint32_t id = dmaGetControllerId(xdmac);
    /* set aic source handler */
    aicSetSourceHandler(id, dmaHandler);
  }
}
  203718:	e28dd014 	add	sp, sp, #20
  20371c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00203720 <dmaChannelSetTransactionSize>:
 * @param[in] dmastp    pointer to a sama_dma_channel_t structure
 * @param[in] size      value to be written in the XDMAC_CUBC register
 *
 * @special
 */
void dmaChannelSetTransactionSize(sama_dma_channel_t *dmachp, size_t n) {
  203720:	e92d4030 	push	{r4, r5, lr}
  203724:	e24dd014 	sub	sp, sp, #20
  203728:	e58d0004 	str	r0, [sp, #4]
  20372c:	e58d1000 	str	r1, [sp]

uint32_t i;
uint32_t divisor;
  /* Single block single microblock */
  if (n <= XDMAC_MAX_BT_SIZE) {
  203730:	e59d3000 	ldr	r3, [sp]
  203734:	e3530401 	cmp	r3, #16777216	; 0x1000000
  203738:	2a00000a 	bcs	203768 <dmaChannelSetTransactionSize+0x48>
    (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(n);
  20373c:	e59d3004 	ldr	r3, [sp, #4]
  203740:	e5931000 	ldr	r1, [r3]
  203744:	e59d3004 	ldr	r3, [sp, #4]
  203748:	e5d33004 	ldrb	r3, [r3, #4]
  20374c:	e1a00003 	mov	r0, r3
  203750:	e59d3000 	ldr	r3, [sp]
  203754:	e3c324ff 	bic	r2, r3, #-16777216	; 0xff000000
  203758:	e1a03300 	lsl	r3, r0, #6
  20375c:	e0813003 	add	r3, r1, r3
  203760:	e5832070 	str	r2, [r3, #112]	; 0x70
  203764:	ea000036 	b	203844 <dmaChannelSetTransactionSize+0x124>
  }
  /* Single block multiple microblocks */
  else {
   /* If n exceeds XDMAC_MAX_BT_SIZE, split the transfer in microblocks */
    for (i = 2; i < XDMAC_MAX_BT_SIZE; i++) {
  203768:	e3a03002 	mov	r3, #2
  20376c:	e58d300c 	str	r3, [sp, #12]
  203770:	ea00002e 	b	203830 <dmaChannelSetTransactionSize+0x110>
      divisor = XDMAC_MAX_BT_SIZE / i;
  203774:	e59d100c 	ldr	r1, [sp, #12]
  203778:	e3e004ff 	mvn	r0, #-16777216	; 0xff000000
  20377c:	ebfff2eb 	bl	200330 <__aeabi_uidiv>
  203780:	e1a03000 	mov	r3, r0
  203784:	e58d3008 	str	r3, [sp, #8]
      if (n % divisor)
  203788:	e59d3000 	ldr	r3, [sp]
  20378c:	e59d1008 	ldr	r1, [sp, #8]
  203790:	e1a00003 	mov	r0, r3
  203794:	ebfff360 	bl	20051c <__aeabi_uidivmod>
  203798:	e1a03001 	mov	r3, r1
  20379c:	e3530000 	cmp	r3, #0
  2037a0:	1a00001e 	bne	203820 <dmaChannelSetTransactionSize+0x100>
        continue;
      if ((n / divisor) <= XDMAC_MAX_BLOCK_LEN) {
  2037a4:	e59d1008 	ldr	r1, [sp, #8]
  2037a8:	e59d0000 	ldr	r0, [sp]
  2037ac:	ebfff2df 	bl	200330 <__aeabi_uidiv>
  2037b0:	e1a03000 	mov	r3, r0
  2037b4:	e3530a01 	cmp	r3, #4096	; 0x1000
  2037b8:	2a000019 	bcs	203824 <dmaChannelSetTransactionSize+0x104>
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(i);
  2037bc:	e59d3004 	ldr	r3, [sp, #4]
  2037c0:	e5931000 	ldr	r1, [r3]
  2037c4:	e59d3004 	ldr	r3, [sp, #4]
  2037c8:	e5d33004 	ldrb	r3, [r3, #4]
  2037cc:	e1a00003 	mov	r0, r3
  2037d0:	e59d300c 	ldr	r3, [sp, #12]
  2037d4:	e3c324ff 	bic	r2, r3, #-16777216	; 0xff000000
  2037d8:	e1a03300 	lsl	r3, r0, #6
  2037dc:	e0813003 	add	r3, r1, r3
  2037e0:	e5832070 	str	r2, [r3, #112]	; 0x70
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CBC =
  2037e4:	e59d3004 	ldr	r3, [sp, #4]
  2037e8:	e5934000 	ldr	r4, [r3]
  2037ec:	e59d3004 	ldr	r3, [sp, #4]
  2037f0:	e5d33004 	ldrb	r3, [r3, #4]
  2037f4:	e1a05003 	mov	r5, r3
                                                   XDMAC_CBC_BLEN((n / divisor) - 1);
  2037f8:	e59d1008 	ldr	r1, [sp, #8]
  2037fc:	e59d0000 	ldr	r0, [sp]
  203800:	ebfff2ca 	bl	200330 <__aeabi_uidiv>
  203804:	e1a03000 	mov	r3, r0
  203808:	e2433001 	sub	r3, r3, #1
  20380c:	e7eb2053 	ubfx	r2, r3, #0, #12
      divisor = XDMAC_MAX_BT_SIZE / i;
      if (n % divisor)
        continue;
      if ((n / divisor) <= XDMAC_MAX_BLOCK_LEN) {
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(i);
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CBC =
  203810:	e1a03305 	lsl	r3, r5, #6
  203814:	e0843003 	add	r3, r4, r3
  203818:	e5832074 	str	r2, [r3, #116]	; 0x74
  20381c:	ea000008 	b	203844 <dmaChannelSetTransactionSize+0x124>
  else {
   /* If n exceeds XDMAC_MAX_BT_SIZE, split the transfer in microblocks */
    for (i = 2; i < XDMAC_MAX_BT_SIZE; i++) {
      divisor = XDMAC_MAX_BT_SIZE / i;
      if (n % divisor)
        continue;
  203820:	e1a00000 	nop			; (mov r0, r0)
    (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(n);
  }
  /* Single block multiple microblocks */
  else {
   /* If n exceeds XDMAC_MAX_BT_SIZE, split the transfer in microblocks */
    for (i = 2; i < XDMAC_MAX_BT_SIZE; i++) {
  203824:	e59d300c 	ldr	r3, [sp, #12]
  203828:	e2833001 	add	r3, r3, #1
  20382c:	e58d300c 	str	r3, [sp, #12]
  203830:	e59d200c 	ldr	r2, [sp, #12]
  203834:	e30f3ffe 	movw	r3, #65534	; 0xfffe
  203838:	e34030ff 	movt	r3, #255	; 0xff
  20383c:	e1520003 	cmp	r2, r3
  203840:	9affffcb 	bls	203774 <dmaChannelSetTransactionSize+0x54>
        break;
      }
    }
    osalDbgAssert(n == XDMAC_MAX_BT_SIZE, "unsupported DMA transfer size");
  }
}
  203844:	e28dd014 	add	sp, sp, #20
  203848:	e8bd8030 	pop	{r4, r5, pc}
  20384c:	00000000 	andeq	r0, r0, r0

00203850 <dmaChannelAllocate>:
 *
 * @special
 */
sama_dma_channel_t* dmaChannelAllocate(uint32_t priority,
                                       sama_dmaisr_t func,
                                       void *param) {
  203850:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203854:	e24dd01c 	sub	sp, sp, #28
  203858:	e58d000c 	str	r0, [sp, #12]
  20385c:	e58d1008 	str	r1, [sp, #8]
  203860:	e58d2004 	str	r2, [sp, #4]

  sama_dma_channel_t *channel = NULL;
  203864:	e3a03000 	mov	r3, #0
  203868:	e58d3014 	str	r3, [sp, #20]
  uint8_t id;
  uint8_t chan;
  for (chan = 0; chan < XDMAC_CHANNELS_TOT; chan++) {
  20386c:	e3a03000 	mov	r3, #0
  203870:	e5cd3013 	strb	r3, [sp, #19]
  203874:	ea00000e 	b	2038b4 <dmaChannelAllocate+0x64>
    channel = &_sama_dma_channel_t[chan];
  203878:	e5dd3013 	ldrb	r3, [sp, #19]
  20387c:	e1a02203 	lsl	r2, r3, #4
  203880:	e30039d8 	movw	r3, #2520	; 0x9d8
  203884:	e3403021 	movt	r3, #33	; 0x21
  203888:	e0823003 	add	r3, r2, r3
  20388c:	e58d3014 	str	r3, [sp, #20]
    if (channel->state != SAMA_DMA_FREE) {
  203890:	e59d3014 	ldr	r3, [sp, #20]
  203894:	e5d33005 	ldrb	r3, [r3, #5]
  203898:	e3530000 	cmp	r3, #0
  20389c:	0a000007 	beq	2038c0 <dmaChannelAllocate+0x70>
      channel = NULL;
  2038a0:	e3a03000 	mov	r3, #0
  2038a4:	e58d3014 	str	r3, [sp, #20]
                                       void *param) {

  sama_dma_channel_t *channel = NULL;
  uint8_t id;
  uint8_t chan;
  for (chan = 0; chan < XDMAC_CHANNELS_TOT; chan++) {
  2038a8:	e5dd3013 	ldrb	r3, [sp, #19]
  2038ac:	e2833001 	add	r3, r3, #1
  2038b0:	e5cd3013 	strb	r3, [sp, #19]
  2038b4:	e5dd3013 	ldrb	r3, [sp, #19]
  2038b8:	e353001f 	cmp	r3, #31
  2038bc:	9affffed 	bls	203878 <dmaChannelAllocate+0x28>
    else {
      break;
    }
  }

  if (channel != NULL) {
  2038c0:	e59d3014 	ldr	r3, [sp, #20]
  2038c4:	e3530000 	cmp	r3, #0
  2038c8:	0a000051 	beq	203a14 <dmaChannelAllocate+0x1c4>
  /* Marks the channel as allocated.*/
    channel->state = SAMA_DMA_NOT_FREE;
  2038cc:	e59d3014 	ldr	r3, [sp, #20]
  2038d0:	e3a02001 	mov	r2, #1
  2038d4:	e5c32005 	strb	r2, [r3, #5]
    channel->dma_func = func;
  2038d8:	e59d3014 	ldr	r3, [sp, #20]
  2038dc:	e59d2008 	ldr	r2, [sp, #8]
  2038e0:	e5832008 	str	r2, [r3, #8]
    channel->dma_param = param;
  2038e4:	e59d3014 	ldr	r3, [sp, #20]
  2038e8:	e59d2004 	ldr	r2, [sp, #4]
  2038ec:	e583200c 	str	r2, [r3, #12]
    id = dmaGetControllerId(channel->xdmac);
  2038f0:	e59d3014 	ldr	r3, [sp, #20]
  2038f4:	e5932000 	ldr	r2, [r3]
  2038f8:	e3a03000 	mov	r3, #0
  2038fc:	e34f3001 	movt	r3, #61441	; 0xf001
  203900:	e1520003 	cmp	r2, r3
  203904:	1a000001 	bne	203910 <dmaChannelAllocate+0xc0>
  203908:	e3a03006 	mov	r3, #6
  20390c:	ea000000 	b	203914 <dmaChannelAllocate+0xc4>
  203910:	e3a03007 	mov	r3, #7
  203914:	e5cd3012 	strb	r3, [sp, #18]

  /* Setting aic */
    aicSetSourcePriority(id, priority);
  203918:	e5dd3012 	ldrb	r3, [sp, #18]
  20391c:	e59d200c 	ldr	r2, [sp, #12]
  203920:	e6ef2072 	uxtb	r2, r2
  203924:	e1a01002 	mov	r1, r2
  203928:	e1a00003 	mov	r0, r3
  20392c:	ebfffe6b 	bl	2032e0 <aicSetSourcePriority>
    aicEnableInt(id);
  203930:	e5dd3012 	ldrb	r3, [sp, #18]
  203934:	e1a00003 	mov	r0, r3
  203938:	ebfffea0 	bl	2033c0 <aicEnableInt>

  /* Enabling DMA clocks required by the current channel set.*/
    if (id == ID_XDMAC0) {
  20393c:	e5dd3012 	ldrb	r3, [sp, #18]
  203940:	e3530006 	cmp	r3, #6
  203944:	1a000011 	bne	203990 <dmaChannelAllocate+0x140>
      pmcEnableXDMAC0();
  203948:	e3a03901 	mov	r3, #16384	; 0x4000
  20394c:	e34f3001 	movt	r3, #61441	; 0xf001
  203950:	e3a02c43 	mov	r2, #17152	; 0x4300
  203954:	e345204d 	movt	r2, #20557	; 0x504d
  203958:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  20395c:	e3a03901 	mov	r3, #16384	; 0x4000
  203960:	e34f3001 	movt	r3, #61441	; 0xf001
  203964:	e3a02901 	mov	r2, #16384	; 0x4000
  203968:	e34f2001 	movt	r2, #61441	; 0xf001
  20396c:	e5922010 	ldr	r2, [r2, #16]
  203970:	e3822040 	orr	r2, r2, #64	; 0x40
  203974:	e5832010 	str	r2, [r3, #16]
  203978:	e3a03901 	mov	r3, #16384	; 0x4000
  20397c:	e34f3001 	movt	r3, #61441	; 0xf001
  203980:	e3042301 	movw	r2, #17153	; 0x4301
  203984:	e345204d 	movt	r2, #20557	; 0x504d
  203988:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  20398c:	ea000010 	b	2039d4 <dmaChannelAllocate+0x184>
    }
    else {
      pmcEnableXDMAC1();
  203990:	e3a03901 	mov	r3, #16384	; 0x4000
  203994:	e34f3001 	movt	r3, #61441	; 0xf001
  203998:	e3a02c43 	mov	r2, #17152	; 0x4300
  20399c:	e345204d 	movt	r2, #20557	; 0x504d
  2039a0:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  2039a4:	e3a03901 	mov	r3, #16384	; 0x4000
  2039a8:	e34f3001 	movt	r3, #61441	; 0xf001
  2039ac:	e3a02901 	mov	r2, #16384	; 0x4000
  2039b0:	e34f2001 	movt	r2, #61441	; 0xf001
  2039b4:	e5922010 	ldr	r2, [r2, #16]
  2039b8:	e3822080 	orr	r2, r2, #128	; 0x80
  2039bc:	e5832010 	str	r2, [r3, #16]
  2039c0:	e3a03901 	mov	r3, #16384	; 0x4000
  2039c4:	e34f3001 	movt	r3, #61441	; 0xf001
  2039c8:	e3042301 	movw	r2, #17153	; 0x4301
  2039cc:	e345204d 	movt	r2, #20557	; 0x504d
  2039d0:	e58320e4 	str	r2, [r3, #228]	; 0xe4
    }

  /* Enable channel interrupt */
    channel->xdmac->XDMAC_CHID[channel->chid].XDMAC_CIE =  XDMAC_CIE_BIE;
  2039d4:	e59d3014 	ldr	r3, [sp, #20]
  2039d8:	e5932000 	ldr	r2, [r3]
  2039dc:	e59d3014 	ldr	r3, [sp, #20]
  2039e0:	e5d33004 	ldrb	r3, [r3, #4]
  2039e4:	e1a03303 	lsl	r3, r3, #6
  2039e8:	e0823003 	add	r3, r2, r3
  2039ec:	e3a02001 	mov	r2, #1
  2039f0:	e5832050 	str	r2, [r3, #80]	; 0x50
    channel->xdmac->XDMAC_GIE = XDMAC_GIE_IE0 << (channel->chid);
  2039f4:	e59d3014 	ldr	r3, [sp, #20]
  2039f8:	e5933000 	ldr	r3, [r3]
  2039fc:	e59d2014 	ldr	r2, [sp, #20]
  203a00:	e5d22004 	ldrb	r2, [r2, #4]
  203a04:	e1a01002 	mov	r1, r2
  203a08:	e3a02001 	mov	r2, #1
  203a0c:	e1a02112 	lsl	r2, r2, r1
  203a10:	e583200c 	str	r2, [r3, #12]
  }
  return channel;
  203a14:	e59d3014 	ldr	r3, [sp, #20]
}
  203a18:	e1a00003 	mov	r0, r3
  203a1c:	e28dd01c 	add	sp, sp, #28
  203a20:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203a30 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  203a30:	e24dd018 	sub	sp, sp, #24
  203a34:	e58d000c 	str	r0, [sp, #12]
  203a38:	e58d1008 	str	r1, [sp, #8]
  203a3c:	e58d2004 	str	r2, [sp, #4]

  uint32_t mskr = (mask);
  203a40:	e59d3008 	ldr	r3, [sp, #8]
  203a44:	e58d3014 	str	r3, [sp, #20]
  uint32_t cfgr = (mode & (PAL_SAMA_CFGR_MASK));
  203a48:	e59d2004 	ldr	r2, [sp, #4]
  203a4c:	e30f3703 	movw	r3, #63235	; 0xf703
  203a50:	e3403003 	movt	r3, #3
  203a54:	e0033002 	and	r3, r3, r2
  203a58:	e58d3010 	str	r3, [sp, #16]

#if SAMA_HAL_IS_SECURE
  if(mode && PAL_SAMA_SECURE_MASK) {
  203a5c:	e59d3004 	ldr	r3, [sp, #4]
  203a60:	e3530000 	cmp	r3, #0
  203a64:	0a000003 	beq	203a78 <_pal_lld_setgroupmode+0x48>
    port->SIOSR = mask;
  203a68:	e59d300c 	ldr	r3, [sp, #12]
  203a6c:	e59d2008 	ldr	r2, [sp, #8]
  203a70:	e5832034 	str	r2, [r3, #52]	; 0x34
  203a74:	ea000002 	b	203a84 <_pal_lld_setgroupmode+0x54>
  }
  else {
    port->SIONR = mask;
  203a78:	e59d300c 	ldr	r3, [sp, #12]
  203a7c:	e59d2008 	ldr	r2, [sp, #8]
  203a80:	e5832030 	str	r2, [r3, #48]	; 0x30
  }
#endif /* SAMA_HAL_IS_SECURE */
  port->MSKR = mskr;
  203a84:	e59d300c 	ldr	r3, [sp, #12]
  203a88:	e59d2014 	ldr	r2, [sp, #20]
  203a8c:	e5832000 	str	r2, [r3]
  port->CFGR = cfgr;
  203a90:	e59d300c 	ldr	r3, [sp, #12]
  203a94:	e59d2010 	ldr	r2, [sp, #16]
  203a98:	e5832004 	str	r2, [r3, #4]
}
  203a9c:	e28dd018 	add	sp, sp, #24
  203aa0:	e12fff1e 	bx	lr
	...

00203ab0 <port_lock_from_isr.lto_priv.31>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  203ab0:	e12fff1e 	bx	lr
	...

00203ac0 <port_unlock_from_isr.lto_priv.29>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  203ac0:	e12fff1e 	bx	lr
	...

00203ad0 <chSysLockFromISR.lto_priv.27>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  203ad0:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  203ad4:	ebfffff5 	bl	203ab0 <port_lock_from_isr.lto_priv.31>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  203ad8:	e8bd8010 	pop	{r4, pc}
  203adc:	00000000 	andeq	r0, r0, r0

00203ae0 <chSysUnlockFromISR.lto_priv.25>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  203ae0:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  203ae4:	ebfffff5 	bl	203ac0 <port_unlock_from_isr.lto_priv.29>
}
  203ae8:	e8bd8010 	pop	{r4, pc}
  203aec:	00000000 	andeq	r0, r0, r0

00203af0 <osalSysHalt.lto_priv.23>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
  203af0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203af4:	e24dd00c 	sub	sp, sp, #12
  203af8:	e58d0004 	str	r0, [sp, #4]

  chSysHalt(reason);
  203afc:	e59d0004 	ldr	r0, [sp, #4]
  203b00:	eb00020e 	bl	204340 <chSysHalt>
}
  203b04:	e28dd00c 	add	sp, sp, #12
  203b08:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  203b0c:	00000000 	andeq	r0, r0, r0

00203b10 <osalSysLockFromISR.lto_priv.10>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
  203b10:	e92d4010 	push	{r4, lr}

  chSysLockFromISR();
  203b14:	ebffffed 	bl	203ad0 <chSysLockFromISR.lto_priv.27>
}
  203b18:	e8bd8010 	pop	{r4, pc}
  203b1c:	00000000 	andeq	r0, r0, r0

00203b20 <osalSysUnlockFromISR.lto_priv.8>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
  203b20:	e92d4010 	push	{r4, lr}

  chSysUnlockFromISR();
  203b24:	ebffffed 	bl	203ae0 <chSysUnlockFromISR.lto_priv.25>
}
  203b28:	e8bd8010 	pop	{r4, pc}
  203b2c:	00000000 	andeq	r0, r0, r0

00203b30 <osalThreadResumeI.lto_priv.22>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
  203b30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203b34:	e24dd00c 	sub	sp, sp, #12
  203b38:	e58d0004 	str	r0, [sp, #4]
  203b3c:	e58d1000 	str	r1, [sp]

  chThdResumeI(trp, msg);
  203b40:	e59d1000 	ldr	r1, [sp]
  203b44:	e59d0004 	ldr	r0, [sp, #4]
  203b48:	eb00059c 	bl	2051c0 <chThdResumeI>
}
  203b4c:	e28dd00c 	add	sp, sp, #12
  203b50:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203b60 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
  203b60:	e12fff1e 	bx	lr
	...

00203b70 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
  203b70:	e92d4010 	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
  203b74:	ebfffff9 	bl	203b60 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
  203b78:	ebfffc68 	bl	202d20 <hal_lld_init>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
  203b7c:	ebfffbb7 	bl	202a60 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
  203b80:	ebfffc26 	bl	202c20 <spiInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
  203b84:	ebfff589 	bl	2011b0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
  203b88:	eb000000 	bl	203b90 <stInit>
#endif
}
  203b8c:	e8bd8010 	pop	{r4, pc}

00203b90 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
  203b90:	e92d4010 	push	{r4, lr}

  st_lld_init();
  203b94:	ebfffd91 	bl	2031e0 <st_lld_init>
}
  203b98:	e8bd8010 	pop	{r4, pc}
  203b9c:	00000000 	andeq	r0, r0, r0

00203ba0 <port_lock.lto_priv.67>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  203ba0:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  203ba4:	e12fff1e 	bx	lr
	...

00203bb0 <port_unlock.lto_priv.65>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  203bb0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  203bb4:	e12fff1e 	bx	lr
	...

00203bc0 <queue_init.lto_priv.63>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  203bc0:	e24dd008 	sub	sp, sp, #8
  203bc4:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  203bc8:	e59d3004 	ldr	r3, [sp, #4]
  203bcc:	e59d2004 	ldr	r2, [sp, #4]
  203bd0:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  203bd4:	e59d3004 	ldr	r3, [sp, #4]
  203bd8:	e59d2004 	ldr	r2, [sp, #4]
  203bdc:	e5832004 	str	r2, [r3, #4]
}
  203be0:	e28dd008 	add	sp, sp, #8
  203be4:	e12fff1e 	bx	lr
	...

00203bf0 <chSysLock.lto_priv.61>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  203bf0:	e92d4010 	push	{r4, lr}

  port_lock();
  203bf4:	ebffffe9 	bl	203ba0 <port_lock.lto_priv.67>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  203bf8:	e8bd8010 	pop	{r4, pc}
  203bfc:	00000000 	andeq	r0, r0, r0

00203c00 <chSysUnlock.lto_priv.58>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  203c00:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  203c04:	ebffffe9 	bl	203bb0 <port_unlock.lto_priv.65>
}
  203c08:	e8bd8010 	pop	{r4, pc}
  203c0c:	00000000 	andeq	r0, r0, r0

00203c10 <chVTGetSystemTimeX.lto_priv.55>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
  203c10:	e3003938 	movw	r3, #2360	; 0x938
  203c14:	e3403021 	movt	r3, #33	; 0x21
  203c18:	e5933028 	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  203c1c:	e1a00003 	mov	r0, r3
  203c20:	e12fff1e 	bx	lr
	...

00203c30 <chThdQueueObjectInit.lto_priv.53>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
  203c30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203c34:	e24dd00c 	sub	sp, sp, #12
  203c38:	e58d0004 	str	r0, [sp, #4]

  queue_init(tqp);
  203c3c:	e59d0004 	ldr	r0, [sp, #4]
  203c40:	ebffffde 	bl	203bc0 <queue_init.lto_priv.63>
}
  203c44:	e28dd00c 	add	sp, sp, #12
  203c48:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  203c4c:	00000000 	andeq	r0, r0, r0

00203c50 <osalSysLock.lto_priv.35>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
  203c50:	e92d4010 	push	{r4, lr}

  chSysLock();
  203c54:	ebffffe5 	bl	203bf0 <chSysLock.lto_priv.61>
}
  203c58:	e8bd8010 	pop	{r4, pc}
  203c5c:	00000000 	andeq	r0, r0, r0

00203c60 <osalSysUnlock.lto_priv.32>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
  203c60:	e92d4010 	push	{r4, lr}

  chSysUnlock();
  203c64:	ebffffe5 	bl	203c00 <chSysUnlock.lto_priv.58>
}
  203c68:	e8bd8010 	pop	{r4, pc}
  203c6c:	00000000 	andeq	r0, r0, r0

00203c70 <osalOsGetSystemTimeX.lto_priv.48>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
  203c70:	e92d4010 	push	{r4, lr}

  return chVTGetSystemTimeX();
  203c74:	ebffffe5 	bl	203c10 <chVTGetSystemTimeX.lto_priv.55>
  203c78:	e1a03000 	mov	r3, r0
}
  203c7c:	e1a00003 	mov	r0, r3
  203c80:	e8bd8010 	pop	{r4, pc}
	...

00203c90 <osalThreadQueueObjectInit.lto_priv.51>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
  203c90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203c94:	e24dd00c 	sub	sp, sp, #12
  203c98:	e58d0004 	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
  203c9c:	e59d0004 	ldr	r0, [sp, #4]
  203ca0:	ebffffe2 	bl	203c30 <chThdQueueObjectInit.lto_priv.53>
}
  203ca4:	e28dd00c 	add	sp, sp, #12
  203ca8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  203cac:	00000000 	andeq	r0, r0, r0

00203cb0 <osalThreadEnqueueTimeoutS.lto_priv.47>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
  203cb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203cb4:	e24dd00c 	sub	sp, sp, #12
  203cb8:	e58d0004 	str	r0, [sp, #4]
  203cbc:	e58d1000 	str	r1, [sp]

  return chThdEnqueueTimeoutS(tqp, time);
  203cc0:	e59d1000 	ldr	r1, [sp]
  203cc4:	e59d0004 	ldr	r0, [sp, #4]
  203cc8:	eb000554 	bl	205220 <chThdEnqueueTimeoutS>
  203ccc:	e1a03000 	mov	r3, r0
}
  203cd0:	e1a00003 	mov	r0, r3
  203cd4:	e28dd00c 	add	sp, sp, #12
  203cd8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  203cdc:	00000000 	andeq	r0, r0, r0

00203ce0 <osalThreadDequeueNextI.lto_priv.49>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  203ce0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203ce4:	e24dd00c 	sub	sp, sp, #12
  203ce8:	e58d0004 	str	r0, [sp, #4]
  203cec:	e58d1000 	str	r1, [sp]

  chThdDequeueNextI(tqp, msg);
  203cf0:	e59d1000 	ldr	r1, [sp]
  203cf4:	e59d0004 	ldr	r0, [sp, #4]
  203cf8:	eb000560 	bl	205280 <chThdDequeueNextI>
}
  203cfc:	e28dd00c 	add	sp, sp, #12
  203d00:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203d10 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
  203d10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203d14:	e24dd014 	sub	sp, sp, #20
  203d18:	e58d000c 	str	r0, [sp, #12]
  203d1c:	e58d1008 	str	r1, [sp, #8]
  203d20:	e58d2004 	str	r2, [sp, #4]
  203d24:	e58d3000 	str	r3, [sp]

  osalThreadQueueObjectInit(&iqp->q_waiting);
  203d28:	e59d300c 	ldr	r3, [sp, #12]
  203d2c:	e1a00003 	mov	r0, r3
  203d30:	ebffffd6 	bl	203c90 <osalThreadQueueObjectInit.lto_priv.51>
  iqp->q_counter = 0;
  203d34:	e59d300c 	ldr	r3, [sp, #12]
  203d38:	e3a02000 	mov	r2, #0
  203d3c:	e5832008 	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
  203d40:	e59d300c 	ldr	r3, [sp, #12]
  203d44:	e59d2008 	ldr	r2, [sp, #8]
  203d48:	e583200c 	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
  203d4c:	e59d300c 	ldr	r3, [sp, #12]
  203d50:	e59d2008 	ldr	r2, [sp, #8]
  203d54:	e5832018 	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
  203d58:	e59d300c 	ldr	r3, [sp, #12]
  203d5c:	e59d2008 	ldr	r2, [sp, #8]
  203d60:	e5832014 	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
  203d64:	e59d2008 	ldr	r2, [sp, #8]
  203d68:	e59d3004 	ldr	r3, [sp, #4]
  203d6c:	e0822003 	add	r2, r2, r3
  203d70:	e59d300c 	ldr	r3, [sp, #12]
  203d74:	e5832010 	str	r2, [r3, #16]
  iqp->q_notify  = infy;
  203d78:	e59d300c 	ldr	r3, [sp, #12]
  203d7c:	e59d2000 	ldr	r2, [sp]
  203d80:	e583201c 	str	r2, [r3, #28]
  iqp->q_link    = link;
  203d84:	e59d300c 	ldr	r3, [sp, #12]
  203d88:	e59d2018 	ldr	r2, [sp, #24]
  203d8c:	e5832020 	str	r2, [r3, #32]
}
  203d90:	e28dd014 	add	sp, sp, #20
  203d94:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203da0 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
  203da0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203da4:	e24dd00c 	sub	sp, sp, #12
  203da8:	e58d0004 	str	r0, [sp, #4]
  203dac:	e1a03001 	mov	r3, r1
  203db0:	e5cd3003 	strb	r3, [sp, #3]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
  203db4:	e59d3004 	ldr	r3, [sp, #4]
  203db8:	e5932014 	ldr	r2, [r3, #20]
  203dbc:	e59d3004 	ldr	r3, [sp, #4]
  203dc0:	e5933018 	ldr	r3, [r3, #24]
  203dc4:	e1520003 	cmp	r2, r3
  203dc8:	1a000005 	bne	203de4 <iqPutI+0x44>
  203dcc:	e59d3004 	ldr	r3, [sp, #4]
  203dd0:	e5933008 	ldr	r3, [r3, #8]
  203dd4:	e3530000 	cmp	r3, #0
  203dd8:	0a000001 	beq	203de4 <iqPutI+0x44>
  203ddc:	e3a03001 	mov	r3, #1
  203de0:	ea000000 	b	203de8 <iqPutI+0x48>
  203de4:	e3a03000 	mov	r3, #0
  203de8:	e2033001 	and	r3, r3, #1
  203dec:	e3530000 	cmp	r3, #0
  203df0:	0a000001 	beq	203dfc <iqPutI+0x5c>
    return MSG_TIMEOUT;
  203df4:	e3e03000 	mvn	r3, #0
  203df8:	ea00001a 	b	203e68 <iqPutI+0xc8>
  }

  iqp->q_counter++;
  203dfc:	e59d3004 	ldr	r3, [sp, #4]
  203e00:	e5933008 	ldr	r3, [r3, #8]
  203e04:	e2832001 	add	r2, r3, #1
  203e08:	e59d3004 	ldr	r3, [sp, #4]
  203e0c:	e5832008 	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
  203e10:	e59d3004 	ldr	r3, [sp, #4]
  203e14:	e5933014 	ldr	r3, [r3, #20]
  203e18:	e2831001 	add	r1, r3, #1
  203e1c:	e59d2004 	ldr	r2, [sp, #4]
  203e20:	e5821014 	str	r1, [r2, #20]
  203e24:	e5dd2003 	ldrb	r2, [sp, #3]
  203e28:	e5c32000 	strb	r2, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
  203e2c:	e59d3004 	ldr	r3, [sp, #4]
  203e30:	e5932014 	ldr	r2, [r3, #20]
  203e34:	e59d3004 	ldr	r3, [sp, #4]
  203e38:	e5933010 	ldr	r3, [r3, #16]
  203e3c:	e1520003 	cmp	r2, r3
  203e40:	3a000003 	bcc	203e54 <iqPutI+0xb4>
    iqp->q_wrptr = iqp->q_buffer;
  203e44:	e59d3004 	ldr	r3, [sp, #4]
  203e48:	e593200c 	ldr	r2, [r3, #12]
  203e4c:	e59d3004 	ldr	r3, [sp, #4]
  203e50:	e5832014 	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
  203e54:	e59d3004 	ldr	r3, [sp, #4]
  203e58:	e3a01000 	mov	r1, #0
  203e5c:	e1a00003 	mov	r0, r3
  203e60:	ebffff9e 	bl	203ce0 <osalThreadDequeueNextI.lto_priv.49>

  return MSG_OK;
  203e64:	e3a03000 	mov	r3, #0
}
  203e68:	e1a00003 	mov	r0, r3
  203e6c:	e28dd00c 	add	sp, sp, #12
  203e70:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203e80 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
  203e80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203e84:	e24dd00c 	sub	sp, sp, #12
  203e88:	e58d0004 	str	r0, [sp, #4]
  203e8c:	e58d1000 	str	r1, [sp]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  203e90:	e59d3004 	ldr	r3, [sp, #4]
  203e94:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  203e98:	e59d3000 	ldr	r3, [sp]
  203e9c:	e1822003 	orr	r2, r2, r3
  203ea0:	e59d3004 	ldr	r3, [sp, #4]
  203ea4:	e5832038 	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
  203ea8:	e59d3004 	ldr	r3, [sp, #4]
  203eac:	e5d33020 	ldrb	r3, [r3, #32]
  203eb0:	e353000a 	cmp	r3, #10
  203eb4:	1a000006 	bne	203ed4 <chEvtSignalI+0x54>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  203eb8:	e59d3004 	ldr	r3, [sp, #4]
  203ebc:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  203ec0:	e59d3004 	ldr	r3, [sp, #4]
  203ec4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  203ec8:	e0033002 	and	r3, r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
  203ecc:	e3530000 	cmp	r3, #0
  203ed0:	1a00000c 	bne	203f08 <chEvtSignalI+0x88>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
  203ed4:	e59d3004 	ldr	r3, [sp, #4]
  203ed8:	e5d33020 	ldrb	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  203edc:	e353000b 	cmp	r3, #11
  203ee0:	1a00000d 	bne	203f1c <chEvtSignalI+0x9c>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  203ee4:	e59d3004 	ldr	r3, [sp, #4]
  203ee8:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  203eec:	e59d3004 	ldr	r3, [sp, #4]
  203ef0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  203ef4:	e0022003 	and	r2, r2, r3
  203ef8:	e59d3004 	ldr	r3, [sp, #4]
  203efc:	e5933028 	ldr	r3, [r3, #40]	; 0x28

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
  203f00:	e1520003 	cmp	r2, r3
  203f04:	1a000004 	bne	203f1c <chEvtSignalI+0x9c>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
  203f08:	e59d3004 	ldr	r3, [sp, #4]
  203f0c:	e3a02000 	mov	r2, #0
  203f10:	e5832028 	str	r2, [r3, #40]	; 0x28
    (void) chSchReadyI(tp);
  203f14:	e59d0004 	ldr	r0, [sp, #4]
  203f18:	eb000200 	bl	204720 <chSchReadyI>
  }
}
  203f1c:	e28dd00c 	add	sp, sp, #12
  203f20:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203f30 <port_lock.lto_priv.86>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  203f30:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  203f34:	e12fff1e 	bx	lr
	...

00203f40 <port_unlock.lto_priv.80>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  203f40:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  203f44:	e12fff1e 	bx	lr
	...

00203f50 <chSysLock.lto_priv.99>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  203f50:	e92d4010 	push	{r4, lr}

  port_lock();
  203f54:	ebfffff5 	bl	203f30 <port_lock.lto_priv.86>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  203f58:	e8bd8010 	pop	{r4, pc}
  203f5c:	00000000 	andeq	r0, r0, r0

00203f60 <chSysUnlock.lto_priv.93>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  203f60:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  203f64:	ebfffff5 	bl	203f40 <port_unlock.lto_priv.80>
}
  203f68:	e8bd8010 	pop	{r4, pc}
  203f6c:	00000000 	andeq	r0, r0, r0

00203f70 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
  203f70:	e30039b0 	movw	r3, #2480	; 0x9b0
  203f74:	e3403021 	movt	r3, #33	; 0x21
  203f78:	e3002f60 	movw	r2, #3936	; 0xf60
  203f7c:	e3402021 	movt	r2, #33	; 0x21
  203f80:	e5832000 	str	r2, [r3]
  ch_memcore.endmem  = __heap_end__;
  203f84:	e30039b0 	movw	r3, #2480	; 0x9b0
  203f88:	e3403021 	movt	r3, #33	; 0x21
  203f8c:	e3002000 	movw	r2, #0
  203f90:	e3402022 	movt	r2, #34	; 0x22
  203f94:	e5832004 	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
  203f98:	e12fff1e 	bx	lr
  203f9c:	00000000 	andeq	r0, r0, r0

00203fa0 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
  203fa0:	e24dd018 	sub	sp, sp, #24
  203fa4:	e58d000c 	str	r0, [sp, #12]
  203fa8:	e58d1008 	str	r1, [sp, #8]
  203fac:	e58d2004 	str	r2, [sp, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  203fb0:	e59d2008 	ldr	r2, [sp, #8]
  203fb4:	e59d300c 	ldr	r3, [sp, #12]
  203fb8:	e0823003 	add	r3, r2, r3
  203fbc:	e2432001 	sub	r2, r3, #1
  203fc0:	e59d3008 	ldr	r3, [sp, #8]
  203fc4:	e2633000 	rsb	r3, r3, #0
  203fc8:	e0033002 	and	r3, r3, r2
  203fcc:	e58d300c 	str	r3, [sp, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  203fd0:	e30039b0 	movw	r3, #2480	; 0x9b0
  203fd4:	e3403021 	movt	r3, #33	; 0x21
  203fd8:	e5932000 	ldr	r2, [r3]
  203fdc:	e59d3004 	ldr	r3, [sp, #4]
  203fe0:	e0823003 	add	r3, r2, r3
  203fe4:	e1a02003 	mov	r2, r3
  203fe8:	e59d3008 	ldr	r3, [sp, #8]
  203fec:	e0823003 	add	r3, r2, r3
  203ff0:	e2432001 	sub	r2, r3, #1
  203ff4:	e59d3008 	ldr	r3, [sp, #8]
  203ff8:	e2633000 	rsb	r3, r3, #0
  203ffc:	e0033002 	and	r3, r3, r2
  204000:	e58d3014 	str	r3, [sp, #20]
  next = p + size;
  204004:	e59d2014 	ldr	r2, [sp, #20]
  204008:	e59d300c 	ldr	r3, [sp, #12]
  20400c:	e0823003 	add	r3, r2, r3
  204010:	e58d3010 	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  204014:	e30039b0 	movw	r3, #2480	; 0x9b0
  204018:	e3403021 	movt	r3, #33	; 0x21
  20401c:	e5932004 	ldr	r2, [r3, #4]
  204020:	e59d3010 	ldr	r3, [sp, #16]
  204024:	e1520003 	cmp	r2, r3
  204028:	3a000005 	bcc	204044 <chCoreAllocAlignedWithOffsetI+0xa4>
  20402c:	e30039b0 	movw	r3, #2480	; 0x9b0
  204030:	e3403021 	movt	r3, #33	; 0x21
  204034:	e5932000 	ldr	r2, [r3]
  204038:	e59d3010 	ldr	r3, [sp, #16]
  20403c:	e1520003 	cmp	r2, r3
  204040:	9a000001 	bls	20404c <chCoreAllocAlignedWithOffsetI+0xac>
    return NULL;
  204044:	e3a03000 	mov	r3, #0
  204048:	ea000004 	b	204060 <chCoreAllocAlignedWithOffsetI+0xc0>
  }

  ch_memcore.nextmem = next;
  20404c:	e30039b0 	movw	r3, #2480	; 0x9b0
  204050:	e3403021 	movt	r3, #33	; 0x21
  204054:	e59d2010 	ldr	r2, [sp, #16]
  204058:	e5832000 	str	r2, [r3]

  return p;
  20405c:	e59d3014 	ldr	r3, [sp, #20]
}
  204060:	e1a00003 	mov	r0, r3
  204064:	e28dd018 	add	sp, sp, #24
  204068:	e12fff1e 	bx	lr
  20406c:	00000000 	andeq	r0, r0, r0

00204070 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
  204070:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204074:	e24dd01c 	sub	sp, sp, #28
  204078:	e58d000c 	str	r0, [sp, #12]
  20407c:	e58d1008 	str	r1, [sp, #8]
  204080:	e58d2004 	str	r2, [sp, #4]
  void *p;

  chSysLock();
  204084:	ebffffb1 	bl	203f50 <chSysLock.lto_priv.99>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  204088:	e59d2004 	ldr	r2, [sp, #4]
  20408c:	e59d1008 	ldr	r1, [sp, #8]
  204090:	e59d000c 	ldr	r0, [sp, #12]
  204094:	ebffffc1 	bl	203fa0 <chCoreAllocAlignedWithOffsetI>
  204098:	e58d0014 	str	r0, [sp, #20]
  chSysUnlock();
  20409c:	ebffffaf 	bl	203f60 <chSysUnlock.lto_priv.93>

  return p;
  2040a0:	e59d3014 	ldr	r3, [sp, #20]
}
  2040a4:	e1a00003 	mov	r0, r3
  2040a8:	e28dd01c 	add	sp, sp, #28
  2040ac:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

002040b0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
  2040b0:	e92d4010 	push	{r4, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
  2040b4:	e30039b8 	movw	r3, #2488	; 0x9b8
  2040b8:	e3403021 	movt	r3, #33	; 0x21
  2040bc:	e3042070 	movw	r2, #16496	; 0x4070
  2040c0:	e3402020 	movt	r2, #32
  2040c4:	e5832000 	str	r2, [r3]
  H_NEXT(&default_heap.header) = NULL;
  2040c8:	e30039b8 	movw	r3, #2488	; 0x9b8
  2040cc:	e3403021 	movt	r3, #33	; 0x21
  2040d0:	e3a02000 	mov	r2, #0
  2040d4:	e5832008 	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
  2040d8:	e30039b8 	movw	r3, #2488	; 0x9b8
  2040dc:	e3403021 	movt	r3, #33	; 0x21
  2040e0:	e3a02000 	mov	r2, #0
  2040e4:	e583200c 	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
  2040e8:	e30009c8 	movw	r0, #2504	; 0x9c8
  2040ec:	e3400021 	movt	r0, #33	; 0x21
  2040f0:	eb00047e 	bl	2052f0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
  2040f4:	e8bd8010 	pop	{r4, pc}
	...

00204100 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
  204100:	e12fff1e 	bx	lr
	...

00204110 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
  204110:	eafffffe 	b	204110 <__default_exit>
	...

00204120 <port_init>:
/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

}
  204120:	e12fff1e 	bx	lr
	...

00204130 <port_lock_from_isr.lto_priv.157>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  204130:	e12fff1e 	bx	lr
	...

00204140 <port_unlock_from_isr.lto_priv.155>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  204140:	e12fff1e 	bx	lr
	...

00204150 <port_disable>:
 * @details In this port it disables FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_disable(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  204150:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  204154:	e12fff1e 	bx	lr
	...

00204160 <port_enable>:
 * @brief   Enables all the interrupt sources.
 * @note    In this port it enables the FIQ sources.
 */
static inline void port_enable(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  204160:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  204164:	e12fff1e 	bx	lr
	...

00204170 <port_wait_for_interrupt>:
 *          modes.
 * @note    Implemented as an inlined @p WFI instruction.
 */
static inline void port_wait_for_interrupt(void) {

  asm volatile ("wfi" : : : "memory");
  204170:	e320f003 	wfi
}
  204174:	e12fff1e 	bx	lr
	...

00204180 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
  204180:	e92d4010 	push	{r4, lr}

  _dbg_check_enable();
  port_enable();
  204184:	ebfffff5 	bl	204160 <port_enable>
}
  204188:	e8bd8010 	pop	{r4, pc}
  20418c:	00000000 	andeq	r0, r0, r0

00204190 <chSysLockFromISR.lto_priv.153>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  204190:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  204194:	ebffffe5 	bl	204130 <port_lock_from_isr.lto_priv.157>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  204198:	e8bd8010 	pop	{r4, pc}
  20419c:	00000000 	andeq	r0, r0, r0

002041a0 <chSysUnlockFromISR.lto_priv.151>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  2041a0:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  2041a4:	ebffffe5 	bl	204140 <port_unlock_from_isr.lto_priv.155>
}
  2041a8:	e8bd8010 	pop	{r4, pc}
  2041ac:	00000000 	andeq	r0, r0, r0

002041b0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
  2041b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2041b4:	e24dd00c 	sub	sp, sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  2041b8:	e3003938 	movw	r3, #2360	; 0x938
  2041bc:	e3403021 	movt	r3, #33	; 0x21
  2041c0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  2041c4:	e2832001 	add	r2, r3, #1
  2041c8:	e3003938 	movw	r3, #2360	; 0x938
  2041cc:	e3403021 	movt	r3, #33	; 0x21
  2041d0:	e5832028 	str	r2, [r3, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  2041d4:	e3003938 	movw	r3, #2360	; 0x938
  2041d8:	e3403021 	movt	r3, #33	; 0x21
  2041dc:	e593301c 	ldr	r3, [r3, #28]
  2041e0:	e3002954 	movw	r2, #2388	; 0x954
  2041e4:	e3402021 	movt	r2, #33	; 0x21
  2041e8:	e1530002 	cmp	r3, r2
  2041ec:	0a000027 	beq	204290 <chVTDoTickI+0xe0>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
  2041f0:	e3003938 	movw	r3, #2360	; 0x938
  2041f4:	e3403021 	movt	r3, #33	; 0x21
  2041f8:	e593301c 	ldr	r3, [r3, #28]
  2041fc:	e5932008 	ldr	r2, [r3, #8]
  204200:	e2422001 	sub	r2, r2, #1
  204204:	e5832008 	str	r2, [r3, #8]
  204208:	ea00001a 	b	204278 <chVTDoTickI+0xc8>
    while (ch.vtlist.next->delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.next;
  20420c:	e3003938 	movw	r3, #2360	; 0x938
  204210:	e3403021 	movt	r3, #33	; 0x21
  204214:	e593301c 	ldr	r3, [r3, #28]
  204218:	e58d3004 	str	r3, [sp, #4]
      fn = vtp->func;
  20421c:	e59d3004 	ldr	r3, [sp, #4]
  204220:	e593300c 	ldr	r3, [r3, #12]
  204224:	e58d3000 	str	r3, [sp]
      vtp->func = NULL;
  204228:	e59d3004 	ldr	r3, [sp, #4]
  20422c:	e3a02000 	mov	r2, #0
  204230:	e583200c 	str	r2, [r3, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  204234:	e59d3004 	ldr	r3, [sp, #4]
  204238:	e5933000 	ldr	r3, [r3]
  20423c:	e3002954 	movw	r2, #2388	; 0x954
  204240:	e3402021 	movt	r2, #33	; 0x21
  204244:	e5832004 	str	r2, [r3, #4]
      ch.vtlist.next = vtp->next;
  204248:	e59d3004 	ldr	r3, [sp, #4]
  20424c:	e5932000 	ldr	r2, [r3]
  204250:	e3003938 	movw	r3, #2360	; 0x938
  204254:	e3403021 	movt	r3, #33	; 0x21
  204258:	e583201c 	str	r2, [r3, #28]
      chSysUnlockFromISR();
  20425c:	ebffffcf 	bl	2041a0 <chSysUnlockFromISR.lto_priv.151>
      fn(vtp->par);
  204260:	e59d3004 	ldr	r3, [sp, #4]
  204264:	e5932010 	ldr	r2, [r3, #16]
  204268:	e59d3000 	ldr	r3, [sp]
  20426c:	e1a00002 	mov	r0, r2
  204270:	e12fff33 	blx	r3
      chSysLockFromISR();
  204274:	ebffffc5 	bl	204190 <chSysLockFromISR.lto_priv.153>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
    while (ch.vtlist.next->delta == (systime_t)0) {
  204278:	e3003938 	movw	r3, #2360	; 0x938
  20427c:	e3403021 	movt	r3, #33	; 0x21
  204280:	e593301c 	ldr	r3, [r3, #28]
  204284:	e5933008 	ldr	r3, [r3, #8]
  204288:	e3530000 	cmp	r3, #0
  20428c:	0affffde 	beq	20420c <chVTDoTickI+0x5c>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  204290:	e28dd00c 	add	sp, sp, #12
  204294:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002042a0 <_idle_thread.lto_priv.21>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
  2042a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2042a4:	e24dd00c 	sub	sp, sp, #12
  2042a8:	e58d0004 	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
  2042ac:	ebffffaf 	bl	204170 <port_wait_for_interrupt>
  2042b0:	eafffffd 	b	2042ac <_idle_thread.lto_priv.21+0xc>
	...

002042c0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
  2042c0:	e92d4010 	push	{r4, lr}

  _scheduler_init();
  2042c4:	eb000101 	bl	2046d0 <_scheduler_init>
  _vt_init();
  2042c8:	eb000034 	bl	2043a0 <_vt_init>
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
  2042cc:	ebffff27 	bl	203f70 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
  2042d0:	ebffff76 	bl	2040b0 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  2042d4:	e3a02080 	mov	r2, #128	; 0x80
  2042d8:	e3051500 	movw	r1, #21760	; 0x5500
  2042dc:	e3401020 	movt	r1, #32
  2042e0:	e3000968 	movw	r0, #2408	; 0x968
  2042e4:	e3400021 	movt	r0, #33	; 0x21
  2042e8:	eb0002b0 	bl	204db0 <_thread_init>
  2042ec:	e1a02000 	mov	r2, r0
  2042f0:	e3003938 	movw	r3, #2360	; 0x938
  2042f4:	e3403021 	movt	r3, #33	; 0x21
  2042f8:	e5832018 	str	r2, [r3, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
  2042fc:	e3003938 	movw	r3, #2360	; 0x938
  204300:	e3403021 	movt	r3, #33	; 0x21
  204304:	e5933018 	ldr	r3, [r3, #24]
  204308:	e3a02000 	mov	r2, #0
  20430c:	e583201c 	str	r2, [r3, #28]
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
  204310:	e3003938 	movw	r3, #2360	; 0x938
  204314:	e3403021 	movt	r3, #33	; 0x21
  204318:	e5933018 	ldr	r3, [r3, #24]
  20431c:	e3a02001 	mov	r2, #1
  204320:	e5c32020 	strb	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
  204324:	ebffff7d 	bl	204120 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
  204328:	ebffff94 	bl	204180 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
  20432c:	e30504e0 	movw	r0, #21728	; 0x54e0
  204330:	e3400020 	movt	r0, #32
  204334:	eb000309 	bl	204f60 <chThdCreate>
  }
#endif
}
  204338:	e8bd8010 	pop	{r4, pc}
  20433c:	00000000 	andeq	r0, r0, r0

00204340 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
  204340:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204344:	e24dd00c 	sub	sp, sp, #12
  204348:	e58d0004 	str	r0, [sp, #4]

  port_disable();
  20434c:	ebffff7f 	bl	204150 <port_disable>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
  204350:	e3003938 	movw	r3, #2360	; 0x938
  204354:	e3403021 	movt	r3, #33	; 0x21
  204358:	e59d2004 	ldr	r2, [sp, #4]
  20435c:	e583202c 	str	r2, [r3, #44]	; 0x2c
  204360:	eafffffe 	b	204360 <chSysHalt+0x20>
	...

00204370 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
  204370:	e92d4010 	push	{r4, lr}
    /* Decrement remaining quantum.*/
    currp->preempt--;
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
  204374:	e3003938 	movw	r3, #2360	; 0x938
  204378:	e3403021 	movt	r3, #33	; 0x21
  20437c:	e5933018 	ldr	r3, [r3, #24]
  204380:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  204384:	e2822001 	add	r2, r2, #1
  204388:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif
  chVTDoTickI();
  20438c:	ebffff87 	bl	2041b0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
  204390:	e8bd8010 	pop	{r4, pc}
	...

002043a0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  2043a0:	e3003938 	movw	r3, #2360	; 0x938
  2043a4:	e3403021 	movt	r3, #33	; 0x21
  2043a8:	e3002954 	movw	r2, #2388	; 0x954
  2043ac:	e3402021 	movt	r2, #33	; 0x21
  2043b0:	e583201c 	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  2043b4:	e3003938 	movw	r3, #2360	; 0x938
  2043b8:	e3403021 	movt	r3, #33	; 0x21
  2043bc:	e3002954 	movw	r2, #2388	; 0x954
  2043c0:	e3402021 	movt	r2, #33	; 0x21
  2043c4:	e5832020 	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
  2043c8:	e3003938 	movw	r3, #2360	; 0x938
  2043cc:	e3403021 	movt	r3, #33	; 0x21
  2043d0:	e3e02000 	mvn	r2, #0
  2043d4:	e5832024 	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
  2043d8:	e3003938 	movw	r3, #2360	; 0x938
  2043dc:	e3403021 	movt	r3, #33	; 0x21
  2043e0:	e3a02000 	mov	r2, #0
  2043e4:	e5832028 	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  2043e8:	e12fff1e 	bx	lr
  2043ec:	00000000 	andeq	r0, r0, r0

002043f0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  2043f0:	e24dd018 	sub	sp, sp, #24
  2043f4:	e58d000c 	str	r0, [sp, #12]
  2043f8:	e58d1008 	str	r1, [sp, #8]
  2043fc:	e58d2004 	str	r2, [sp, #4]
  204400:	e58d3000 	str	r3, [sp]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  204404:	e59d300c 	ldr	r3, [sp, #12]
  204408:	e59d2000 	ldr	r2, [sp]
  20440c:	e5832010 	str	r2, [r3, #16]
  vtp->func = vtfunc;
  204410:	e59d300c 	ldr	r3, [sp, #12]
  204414:	e59d2004 	ldr	r2, [sp, #4]
  204418:	e583200c 	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
  20441c:	e59d3008 	ldr	r3, [sp, #8]
  204420:	e58d3010 	str	r3, [sp, #16]

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
  204424:	e3003938 	movw	r3, #2360	; 0x938
  204428:	e3403021 	movt	r3, #33	; 0x21
  20442c:	e593301c 	ldr	r3, [r3, #28]
  204430:	e58d3014 	str	r3, [sp, #20]
  204434:	ea000007 	b	204458 <chVTDoSetI+0x68>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
  204438:	e59d3014 	ldr	r3, [sp, #20]
  20443c:	e5933008 	ldr	r3, [r3, #8]
  204440:	e59d2010 	ldr	r2, [sp, #16]
  204444:	e0633002 	rsb	r3, r3, r2
  204448:	e58d3010 	str	r3, [sp, #16]
    p = p->next;
  20444c:	e59d3014 	ldr	r3, [sp, #20]
  204450:	e5933000 	ldr	r3, [r3]
  204454:	e58d3014 	str	r3, [sp, #20]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
  204458:	e59d3014 	ldr	r3, [sp, #20]
  20445c:	e5932008 	ldr	r2, [r3, #8]
  204460:	e59d3010 	ldr	r3, [sp, #16]
  204464:	e1520003 	cmp	r2, r3
  204468:	3afffff2 	bcc	204438 <chVTDoSetI+0x48>
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  20446c:	e59d300c 	ldr	r3, [sp, #12]
  204470:	e59d2014 	ldr	r2, [sp, #20]
  204474:	e5832000 	str	r2, [r3]
  vtp->prev = vtp->next->prev;
  204478:	e59d300c 	ldr	r3, [sp, #12]
  20447c:	e5933000 	ldr	r3, [r3]
  204480:	e5932004 	ldr	r2, [r3, #4]
  204484:	e59d300c 	ldr	r3, [sp, #12]
  204488:	e5832004 	str	r2, [r3, #4]
  vtp->prev->next = vtp;
  20448c:	e59d300c 	ldr	r3, [sp, #12]
  204490:	e5933004 	ldr	r3, [r3, #4]
  204494:	e59d200c 	ldr	r2, [sp, #12]
  204498:	e5832000 	str	r2, [r3]
  p->prev = vtp;
  20449c:	e59d3014 	ldr	r3, [sp, #20]
  2044a0:	e59d200c 	ldr	r2, [sp, #12]
  2044a4:	e5832004 	str	r2, [r3, #4]
  vtp->delta = delta
  2044a8:	e59d300c 	ldr	r3, [sp, #12]
  2044ac:	e59d2010 	ldr	r2, [sp, #16]
  2044b0:	e5832008 	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  2044b4:	e59d3014 	ldr	r3, [sp, #20]
  2044b8:	e5932008 	ldr	r2, [r3, #8]
  2044bc:	e59d3010 	ldr	r3, [sp, #16]
  2044c0:	e0632002 	rsb	r2, r3, r2
  2044c4:	e59d3014 	ldr	r3, [sp, #20]
  2044c8:	e5832008 	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
  2044cc:	e3003938 	movw	r3, #2360	; 0x938
  2044d0:	e3403021 	movt	r3, #33	; 0x21
  2044d4:	e3e02000 	mvn	r2, #0
  2044d8:	e5832024 	str	r2, [r3, #36]	; 0x24
}
  2044dc:	e28dd018 	add	sp, sp, #24
  2044e0:	e12fff1e 	bx	lr
	...

002044f0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
  2044f0:	e24dd008 	sub	sp, sp, #8
  2044f4:	e58d0004 	str	r0, [sp, #4]
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
  2044f8:	e59d3004 	ldr	r3, [sp, #4]
  2044fc:	e5933000 	ldr	r3, [r3]
  204500:	e59d2004 	ldr	r2, [sp, #4]
  204504:	e5922000 	ldr	r2, [r2]
  204508:	e5921008 	ldr	r1, [r2, #8]
  20450c:	e59d2004 	ldr	r2, [sp, #4]
  204510:	e5922008 	ldr	r2, [r2, #8]
  204514:	e0812002 	add	r2, r1, r2
  204518:	e5832008 	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
  20451c:	e59d3004 	ldr	r3, [sp, #4]
  204520:	e5933004 	ldr	r3, [r3, #4]
  204524:	e59d2004 	ldr	r2, [sp, #4]
  204528:	e5922000 	ldr	r2, [r2]
  20452c:	e5832000 	str	r2, [r3]
  vtp->next->prev = vtp->prev;
  204530:	e59d3004 	ldr	r3, [sp, #4]
  204534:	e5933000 	ldr	r3, [r3]
  204538:	e59d2004 	ldr	r2, [sp, #4]
  20453c:	e5922004 	ldr	r2, [r2, #4]
  204540:	e5832004 	str	r2, [r3, #4]
  vtp->func = NULL;
  204544:	e59d3004 	ldr	r3, [sp, #4]
  204548:	e3a02000 	mov	r2, #0
  20454c:	e583200c 	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
  204550:	e3003938 	movw	r3, #2360	; 0x938
  204554:	e3403021 	movt	r3, #33	; 0x21
  204558:	e3e02000 	mvn	r2, #0
  20455c:	e5832024 	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  204560:	e28dd008 	add	sp, sp, #8
  204564:	e12fff1e 	bx	lr
	...

00204570 <port_lock_from_isr.lto_priv.158>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  204570:	e12fff1e 	bx	lr
	...

00204580 <port_unlock_from_isr.lto_priv.156>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  204580:	e12fff1e 	bx	lr
	...

00204590 <queue_init.lto_priv.140>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  204590:	e24dd008 	sub	sp, sp, #8
  204594:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  204598:	e59d3004 	ldr	r3, [sp, #4]
  20459c:	e59d2004 	ldr	r2, [sp, #4]
  2045a0:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  2045a4:	e59d3004 	ldr	r3, [sp, #4]
  2045a8:	e59d2004 	ldr	r2, [sp, #4]
  2045ac:	e5832004 	str	r2, [r3, #4]
}
  2045b0:	e28dd008 	add	sp, sp, #8
  2045b4:	e12fff1e 	bx	lr
	...

002045c0 <queue_fifo_remove.lto_priv.130>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  2045c0:	e24dd010 	sub	sp, sp, #16
  2045c4:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
  2045c8:	e59d3004 	ldr	r3, [sp, #4]
  2045cc:	e5933000 	ldr	r3, [r3]
  2045d0:	e58d300c 	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
  2045d4:	e59d300c 	ldr	r3, [sp, #12]
  2045d8:	e5932000 	ldr	r2, [r3]
  2045dc:	e59d3004 	ldr	r3, [sp, #4]
  2045e0:	e5832000 	str	r2, [r3]
  tqp->next->queue.prev = (thread_t *)tqp;
  2045e4:	e59d3004 	ldr	r3, [sp, #4]
  2045e8:	e5933000 	ldr	r3, [r3]
  2045ec:	e59d2004 	ldr	r2, [sp, #4]
  2045f0:	e5832004 	str	r2, [r3, #4]

  return tp;
  2045f4:	e59d300c 	ldr	r3, [sp, #12]
}
  2045f8:	e1a00003 	mov	r0, r3
  2045fc:	e28dd010 	add	sp, sp, #16
  204600:	e12fff1e 	bx	lr
	...

00204610 <queue_dequeue.lto_priv.145>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
  204610:	e24dd008 	sub	sp, sp, #8
  204614:	e58d0004 	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
  204618:	e59d3004 	ldr	r3, [sp, #4]
  20461c:	e5933004 	ldr	r3, [r3, #4]
  204620:	e59d2004 	ldr	r2, [sp, #4]
  204624:	e5922000 	ldr	r2, [r2]
  204628:	e5832000 	str	r2, [r3]
  tp->queue.next->queue.prev = tp->queue.prev;
  20462c:	e59d3004 	ldr	r3, [sp, #4]
  204630:	e5933000 	ldr	r3, [r3]
  204634:	e59d2004 	ldr	r2, [sp, #4]
  204638:	e5922004 	ldr	r2, [r2, #4]
  20463c:	e5832004 	str	r2, [r3, #4]

  return tp;
  204640:	e59d3004 	ldr	r3, [sp, #4]
}
  204644:	e1a00003 	mov	r0, r3
  204648:	e28dd008 	add	sp, sp, #8
  20464c:	e12fff1e 	bx	lr

00204650 <chSysLockFromISR.lto_priv.154>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  204650:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  204654:	ebffffc5 	bl	204570 <port_lock_from_isr.lto_priv.158>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  204658:	e8bd8010 	pop	{r4, pc}
  20465c:	00000000 	andeq	r0, r0, r0

00204660 <chSysUnlockFromISR.lto_priv.152>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  204660:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  204664:	ebffffc5 	bl	204580 <port_unlock_from_isr.lto_priv.156>
}
  204668:	e8bd8010 	pop	{r4, pc}
  20466c:	00000000 	andeq	r0, r0, r0

00204670 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
  204670:	e24dd008 	sub	sp, sp, #8
  204674:	e58d0004 	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->func != NULL);
  204678:	e59d3004 	ldr	r3, [sp, #4]
  20467c:	e593300c 	ldr	r3, [r3, #12]
  204680:	e3530000 	cmp	r3, #0
  204684:	13a03001 	movne	r3, #1
  204688:	03a03000 	moveq	r3, #0
  20468c:	e6ef3073 	uxtb	r3, r3
}
  204690:	e1a00003 	mov	r0, r3
  204694:	e28dd008 	add	sp, sp, #8
  204698:	e12fff1e 	bx	lr
  20469c:	00000000 	andeq	r0, r0, r0

002046a0 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
  2046a0:	e24dd008 	sub	sp, sp, #8
  2046a4:	e58d0004 	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->cnt++;
  2046a8:	e59d3004 	ldr	r3, [sp, #4]
  2046ac:	e5933008 	ldr	r3, [r3, #8]
  2046b0:	e2832001 	add	r2, r3, #1
  2046b4:	e59d3004 	ldr	r3, [sp, #4]
  2046b8:	e5832008 	str	r2, [r3, #8]
}
  2046bc:	e28dd008 	add	sp, sp, #8
  2046c0:	e12fff1e 	bx	lr
	...

002046d0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
  2046d0:	e92d4010 	push	{r4, lr}

  queue_init(&ch.rlist.queue);
  2046d4:	e3000938 	movw	r0, #2360	; 0x938
  2046d8:	e3400021 	movt	r0, #33	; 0x21
  2046dc:	ebffffab 	bl	204590 <queue_init.lto_priv.140>
  ch.rlist.prio = NOPRIO;
  2046e0:	e3003938 	movw	r3, #2360	; 0x938
  2046e4:	e3403021 	movt	r3, #33	; 0x21
  2046e8:	e3a02000 	mov	r2, #0
  2046ec:	e5832008 	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
  2046f0:	e3003938 	movw	r3, #2360	; 0x938
  2046f4:	e3403021 	movt	r3, #33	; 0x21
  2046f8:	e3002938 	movw	r2, #2360	; 0x938
  2046fc:	e3402021 	movt	r2, #33	; 0x21
  204700:	e5832010 	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
  204704:	e3003938 	movw	r3, #2360	; 0x938
  204708:	e3403021 	movt	r3, #33	; 0x21
  20470c:	e3002938 	movw	r2, #2360	; 0x938
  204710:	e3402021 	movt	r2, #33	; 0x21
  204714:	e5832014 	str	r2, [r3, #20]
#endif
}
  204718:	e8bd8010 	pop	{r4, pc}
  20471c:	00000000 	andeq	r0, r0, r0

00204720 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
  204720:	e24dd010 	sub	sp, sp, #16
  204724:	e58d0004 	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  204728:	e59d3004 	ldr	r3, [sp, #4]
  20472c:	e3a02000 	mov	r2, #0
  204730:	e5c32020 	strb	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
  204734:	e3003938 	movw	r3, #2360	; 0x938
  204738:	e3403021 	movt	r3, #33	; 0x21
  20473c:	e58d300c 	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
  204740:	e59d300c 	ldr	r3, [sp, #12]
  204744:	e5933000 	ldr	r3, [r3]
  204748:	e58d300c 	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
  20474c:	e59d300c 	ldr	r3, [sp, #12]
  204750:	e5932008 	ldr	r2, [r3, #8]
  204754:	e59d3004 	ldr	r3, [sp, #4]
  204758:	e5933008 	ldr	r3, [r3, #8]
  20475c:	e1520003 	cmp	r2, r3
  204760:	2afffff6 	bcs	204740 <chSchReadyI+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  204764:	e59d3004 	ldr	r3, [sp, #4]
  204768:	e59d200c 	ldr	r2, [sp, #12]
  20476c:	e5832000 	str	r2, [r3]
  tp->queue.prev             = cp->queue.prev;
  204770:	e59d300c 	ldr	r3, [sp, #12]
  204774:	e5932004 	ldr	r2, [r3, #4]
  204778:	e59d3004 	ldr	r3, [sp, #4]
  20477c:	e5832004 	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  204780:	e59d3004 	ldr	r3, [sp, #4]
  204784:	e5933004 	ldr	r3, [r3, #4]
  204788:	e59d2004 	ldr	r2, [sp, #4]
  20478c:	e5832000 	str	r2, [r3]
  cp->queue.prev             = tp;
  204790:	e59d300c 	ldr	r3, [sp, #12]
  204794:	e59d2004 	ldr	r2, [sp, #4]
  204798:	e5832004 	str	r2, [r3, #4]

  return tp;
  20479c:	e59d3004 	ldr	r3, [sp, #4]
}
  2047a0:	e1a00003 	mov	r0, r3
  2047a4:	e28dd010 	add	sp, sp, #16
  2047a8:	e12fff1e 	bx	lr
  2047ac:	00000000 	andeq	r0, r0, r0

002047b0 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  2047b0:	e24dd010 	sub	sp, sp, #16
  2047b4:	e58d0004 	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  2047b8:	e59d3004 	ldr	r3, [sp, #4]
  2047bc:	e3a02000 	mov	r2, #0
  2047c0:	e5c32020 	strb	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
  2047c4:	e3003938 	movw	r3, #2360	; 0x938
  2047c8:	e3403021 	movt	r3, #33	; 0x21
  2047cc:	e58d300c 	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
  2047d0:	e59d300c 	ldr	r3, [sp, #12]
  2047d4:	e5933000 	ldr	r3, [r3]
  2047d8:	e58d300c 	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
  2047dc:	e59d300c 	ldr	r3, [sp, #12]
  2047e0:	e5932008 	ldr	r2, [r3, #8]
  2047e4:	e59d3004 	ldr	r3, [sp, #4]
  2047e8:	e5933008 	ldr	r3, [r3, #8]
  2047ec:	e1520003 	cmp	r2, r3
  2047f0:	8afffff6 	bhi	2047d0 <chSchReadyAheadI+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  2047f4:	e59d3004 	ldr	r3, [sp, #4]
  2047f8:	e59d200c 	ldr	r2, [sp, #12]
  2047fc:	e5832000 	str	r2, [r3]
  tp->queue.prev             = cp->queue.prev;
  204800:	e59d300c 	ldr	r3, [sp, #12]
  204804:	e5932004 	ldr	r2, [r3, #4]
  204808:	e59d3004 	ldr	r3, [sp, #4]
  20480c:	e5832004 	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  204810:	e59d3004 	ldr	r3, [sp, #4]
  204814:	e5933004 	ldr	r3, [r3, #4]
  204818:	e59d2004 	ldr	r2, [sp, #4]
  20481c:	e5832000 	str	r2, [r3]
  cp->queue.prev             = tp;
  204820:	e59d300c 	ldr	r3, [sp, #12]
  204824:	e59d2004 	ldr	r2, [sp, #4]
  204828:	e5832004 	str	r2, [r3, #4]

  return tp;
  20482c:	e59d3004 	ldr	r3, [sp, #4]
}
  204830:	e1a00003 	mov	r0, r3
  204834:	e28dd010 	add	sp, sp, #16
  204838:	e12fff1e 	bx	lr
  20483c:	00000000 	andeq	r0, r0, r0

00204840 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  204840:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204844:	e24dd014 	sub	sp, sp, #20
  204848:	e1a03000 	mov	r3, r0
  20484c:	e5cd3007 	strb	r3, [sp, #7]
  thread_t *otp = currp;
  204850:	e3003938 	movw	r3, #2360	; 0x938
  204854:	e3403021 	movt	r3, #33	; 0x21
  204858:	e5933018 	ldr	r3, [r3, #24]
  20485c:	e58d300c 	str	r3, [sp, #12]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
  204860:	e59d300c 	ldr	r3, [sp, #12]
  204864:	e5dd2007 	ldrb	r2, [sp, #7]
  204868:	e5c32020 	strb	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  20486c:	e3000938 	movw	r0, #2360	; 0x938
  204870:	e3400021 	movt	r0, #33	; 0x21
  204874:	ebffff51 	bl	2045c0 <queue_fifo_remove.lto_priv.130>
  204878:	e1a02000 	mov	r2, r0
  20487c:	e3003938 	movw	r3, #2360	; 0x938
  204880:	e3403021 	movt	r3, #33	; 0x21
  204884:	e5832018 	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
  204888:	e3003938 	movw	r3, #2360	; 0x938
  20488c:	e3403021 	movt	r3, #33	; 0x21
  204890:	e5933018 	ldr	r3, [r3, #24]
  204894:	e3a02001 	mov	r2, #1
  204898:	e5c32020 	strb	r2, [r3, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  20489c:	e3003938 	movw	r3, #2360	; 0x938
  2048a0:	e3403021 	movt	r3, #33	; 0x21
  2048a4:	e5933018 	ldr	r3, [r3, #24]
  2048a8:	e59d100c 	ldr	r1, [sp, #12]
  2048ac:	e1a00003 	mov	r0, r3
  2048b0:	ebffee3a 	bl	2001a0 <_port_switch_arm>
}
  2048b4:	e28dd014 	add	sp, sp, #20
  2048b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2048bc:	00000000 	andeq	r0, r0, r0

002048c0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
  2048c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2048c4:	e24dd014 	sub	sp, sp, #20
  2048c8:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
  2048cc:	e59d3004 	ldr	r3, [sp, #4]
  2048d0:	e58d300c 	str	r3, [sp, #12]

  chSysLockFromISR();
  2048d4:	ebffff5d 	bl	204650 <chSysLockFromISR.lto_priv.154>
  switch (tp->state) {
  2048d8:	e59d300c 	ldr	r3, [sp, #12]
  2048dc:	e5d33020 	ldrb	r3, [r3, #32]
  2048e0:	e3530007 	cmp	r3, #7
  2048e4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  2048e8:	ea000014 	b	204940 <wakeup+0x80>
  2048ec:	0020490c 	.word	0x0020490c
  2048f0:	00204940 	.word	0x00204940
  2048f4:	00204940 	.word	0x00204940
  2048f8:	00204914 	.word	0x00204914
  2048fc:	00204938 	.word	0x00204938
  204900:	00204928 	.word	0x00204928
  204904:	00204940 	.word	0x00204940
  204908:	00204938 	.word	0x00204938
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
  20490c:	ebffff53 	bl	204660 <chSysUnlockFromISR.lto_priv.152>
  204910:	ea000010 	b	204958 <wakeup+0x98>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
  204914:	e59d300c 	ldr	r3, [sp, #12]
  204918:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  20491c:	e3a02000 	mov	r2, #0
  204920:	e5832000 	str	r2, [r3]
  204924:	ea000005 	b	204940 <wakeup+0x80>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
  204928:	e59d300c 	ldr	r3, [sp, #12]
  20492c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  204930:	e1a00003 	mov	r0, r3
  204934:	ebffff59 	bl	2046a0 <chSemFastSignalI>
  case CH_STATE_WTCOND:
    /* Falls into, intentional. */
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
  204938:	e59d000c 	ldr	r0, [sp, #12]
  20493c:	ebffff33 	bl	204610 <queue_dequeue.lto_priv.145>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  204940:	e59d300c 	ldr	r3, [sp, #12]
  204944:	e3e02000 	mvn	r2, #0
  204948:	e5832028 	str	r2, [r3, #40]	; 0x28
  (void) chSchReadyI(tp);
  20494c:	e59d000c 	ldr	r0, [sp, #12]
  204950:	ebffff72 	bl	204720 <chSchReadyI>
  chSysUnlockFromISR();
  204954:	ebffff41 	bl	204660 <chSysUnlockFromISR.lto_priv.152>
}
  204958:	e28dd014 	add	sp, sp, #20
  20495c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00204960 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
  204960:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204964:	e24dd024 	sub	sp, sp, #36	; 0x24
  204968:	e1a03000 	mov	r3, r0
  20496c:	e58d1000 	str	r1, [sp]
  204970:	e5cd3007 	strb	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
  204974:	e59d3000 	ldr	r3, [sp]
  204978:	e3730001 	cmn	r3, #1
  20497c:	0a000014 	beq	2049d4 <chSchGoSleepTimeoutS+0x74>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
  204980:	e3003938 	movw	r3, #2360	; 0x938
  204984:	e3403021 	movt	r3, #33	; 0x21
  204988:	e5933018 	ldr	r3, [r3, #24]
  20498c:	e28d000c 	add	r0, sp, #12
  204990:	e30428c0 	movw	r2, #18624	; 0x48c0
  204994:	e3402020 	movt	r2, #32
  204998:	e59d1000 	ldr	r1, [sp]
  20499c:	ebfffe93 	bl	2043f0 <chVTDoSetI>
    chSchGoSleepS(newstate);
  2049a0:	e5dd3007 	ldrb	r3, [sp, #7]
  2049a4:	e1a00003 	mov	r0, r3
  2049a8:	ebffffa4 	bl	204840 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
  2049ac:	e28d300c 	add	r3, sp, #12
  2049b0:	e1a00003 	mov	r0, r3
  2049b4:	ebffff2d 	bl	204670 <chVTIsArmedI>
  2049b8:	e1a03000 	mov	r3, r0
  2049bc:	e3530000 	cmp	r3, #0
  2049c0:	0a000006 	beq	2049e0 <chSchGoSleepTimeoutS+0x80>
      chVTDoResetI(&vt);
  2049c4:	e28d300c 	add	r3, sp, #12
  2049c8:	e1a00003 	mov	r0, r3
  2049cc:	ebfffec7 	bl	2044f0 <chVTDoResetI>
  2049d0:	ea000002 	b	2049e0 <chSchGoSleepTimeoutS+0x80>
    }
  }
  else {
    chSchGoSleepS(newstate);
  2049d4:	e5dd3007 	ldrb	r3, [sp, #7]
  2049d8:	e1a00003 	mov	r0, r3
  2049dc:	ebffff97 	bl	204840 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
  2049e0:	e3003938 	movw	r3, #2360	; 0x938
  2049e4:	e3403021 	movt	r3, #33	; 0x21
  2049e8:	e5933018 	ldr	r3, [r3, #24]
  2049ec:	e5933028 	ldr	r3, [r3, #40]	; 0x28
}
  2049f0:	e1a00003 	mov	r0, r3
  2049f4:	e28dd024 	add	sp, sp, #36	; 0x24
  2049f8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2049fc:	00000000 	andeq	r0, r0, r0

00204a00 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  204a00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204a04:	e24dd014 	sub	sp, sp, #20
  204a08:	e58d0004 	str	r0, [sp, #4]
  204a0c:	e58d1000 	str	r1, [sp]
  thread_t *otp = currp;
  204a10:	e3003938 	movw	r3, #2360	; 0x938
  204a14:	e3403021 	movt	r3, #33	; 0x21
  204a18:	e5933018 	ldr	r3, [r3, #24]
  204a1c:	e58d300c 	str	r3, [sp, #12]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
  204a20:	e59d3004 	ldr	r3, [sp, #4]
  204a24:	e59d2000 	ldr	r2, [sp]
  204a28:	e5832028 	str	r2, [r3, #40]	; 0x28

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
  204a2c:	e59d3004 	ldr	r3, [sp, #4]
  204a30:	e5932008 	ldr	r2, [r3, #8]
  204a34:	e59d300c 	ldr	r3, [sp, #12]
  204a38:	e5933008 	ldr	r3, [r3, #8]
  204a3c:	e1520003 	cmp	r2, r3
  204a40:	8a000002 	bhi	204a50 <chSchWakeupS+0x50>
    (void) chSchReadyI(ntp);
  204a44:	e59d0004 	ldr	r0, [sp, #4]
  204a48:	ebffff34 	bl	204720 <chSchReadyI>
  204a4c:	ea00000c 	b	204a84 <chSchWakeupS+0x84>
  }
  else {
    otp = chSchReadyI(otp);
  204a50:	e59d000c 	ldr	r0, [sp, #12]
  204a54:	ebffff31 	bl	204720 <chSchReadyI>
  204a58:	e58d000c 	str	r0, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
  204a5c:	e3003938 	movw	r3, #2360	; 0x938
  204a60:	e3403021 	movt	r3, #33	; 0x21
  204a64:	e59d2004 	ldr	r2, [sp, #4]
  204a68:	e5832018 	str	r2, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
  204a6c:	e59d3004 	ldr	r3, [sp, #4]
  204a70:	e3a02001 	mov	r2, #1
  204a74:	e5c32020 	strb	r2, [r3, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  204a78:	e59d100c 	ldr	r1, [sp, #12]
  204a7c:	e59d0004 	ldr	r0, [sp, #4]
  204a80:	ebffedc6 	bl	2001a0 <_port_switch_arm>
  }
}
  204a84:	e28dd014 	add	sp, sp, #20
  204a88:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  204a8c:	00000000 	andeq	r0, r0, r0

00204a90 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  204a90:	e24dd008 	sub	sp, sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
  204a94:	e3003938 	movw	r3, #2360	; 0x938
  204a98:	e3403021 	movt	r3, #33	; 0x21
  204a9c:	e5933000 	ldr	r3, [r3]
  204aa0:	e5933008 	ldr	r3, [r3, #8]
  204aa4:	e58d3004 	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
  204aa8:	e3003938 	movw	r3, #2360	; 0x938
  204aac:	e3403021 	movt	r3, #33	; 0x21
  204ab0:	e5933018 	ldr	r3, [r3, #24]
  204ab4:	e5933008 	ldr	r3, [r3, #8]
  204ab8:	e58d3000 	str	r3, [sp]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
  204abc:	e59d2004 	ldr	r2, [sp, #4]
  204ac0:	e59d3000 	ldr	r3, [sp]
  204ac4:	e1520003 	cmp	r2, r3
  204ac8:	83a03001 	movhi	r3, #1
  204acc:	93a03000 	movls	r3, #0
  204ad0:	e6ef3073 	uxtb	r3, r3
#endif
}
  204ad4:	e1a00003 	mov	r0, r3
  204ad8:	e28dd008 	add	sp, sp, #8
  204adc:	e12fff1e 	bx	lr

00204ae0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  204ae0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204ae4:	e24dd00c 	sub	sp, sp, #12
  thread_t *otp = currp;
  204ae8:	e3003938 	movw	r3, #2360	; 0x938
  204aec:	e3403021 	movt	r3, #33	; 0x21
  204af0:	e5933018 	ldr	r3, [r3, #24]
  204af4:	e58d3004 	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  204af8:	e3000938 	movw	r0, #2360	; 0x938
  204afc:	e3400021 	movt	r0, #33	; 0x21
  204b00:	ebfffeae 	bl	2045c0 <queue_fifo_remove.lto_priv.130>
  204b04:	e1a02000 	mov	r2, r0
  204b08:	e3003938 	movw	r3, #2360	; 0x938
  204b0c:	e3403021 	movt	r3, #33	; 0x21
  204b10:	e5832018 	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
  204b14:	e3003938 	movw	r3, #2360	; 0x938
  204b18:	e3403021 	movt	r3, #33	; 0x21
  204b1c:	e5933018 	ldr	r3, [r3, #24]
  204b20:	e3a02001 	mov	r2, #1
  204b24:	e5c32020 	strb	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
  204b28:	e59d0004 	ldr	r0, [sp, #4]
  204b2c:	ebffff1f 	bl	2047b0 <chSchReadyAheadI>
  204b30:	e58d0004 	str	r0, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  204b34:	e3003938 	movw	r3, #2360	; 0x938
  204b38:	e3403021 	movt	r3, #33	; 0x21
  204b3c:	e5933018 	ldr	r3, [r3, #24]
  204b40:	e59d1004 	ldr	r1, [sp, #4]
  204b44:	e1a00003 	mov	r0, r3
  204b48:	ebffed94 	bl	2001a0 <_port_switch_arm>
}
  204b4c:	e28dd00c 	add	sp, sp, #12
  204b50:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204b60 <port_lock.lto_priv.110>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  204b60:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  204b64:	e12fff1e 	bx	lr
	...

00204b70 <port_unlock.lto_priv.103>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  204b70:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  204b74:	e12fff1e 	bx	lr
	...

00204b80 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
  204b80:	e24dd008 	sub	sp, sp, #8
  204b84:	e58d0004 	str	r0, [sp, #4]

  tlp->next = (thread_t *)tlp;
  204b88:	e59d3004 	ldr	r3, [sp, #4]
  204b8c:	e59d2004 	ldr	r2, [sp, #4]
  204b90:	e5832000 	str	r2, [r3]
}
  204b94:	e28dd008 	add	sp, sp, #8
  204b98:	e12fff1e 	bx	lr
  204b9c:	00000000 	andeq	r0, r0, r0

00204ba0 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
  204ba0:	e24dd008 	sub	sp, sp, #8
  204ba4:	e58d0004 	str	r0, [sp, #4]

  return (bool)(tlp->next != (thread_t *)tlp);
  204ba8:	e59d3004 	ldr	r3, [sp, #4]
  204bac:	e5932000 	ldr	r2, [r3]
  204bb0:	e59d3004 	ldr	r3, [sp, #4]
  204bb4:	e1520003 	cmp	r2, r3
  204bb8:	13a03001 	movne	r3, #1
  204bbc:	03a03000 	moveq	r3, #0
  204bc0:	e6ef3073 	uxtb	r3, r3
}
  204bc4:	e1a00003 	mov	r0, r3
  204bc8:	e28dd008 	add	sp, sp, #8
  204bcc:	e12fff1e 	bx	lr

00204bd0 <queue_init.lto_priv.141>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  204bd0:	e24dd008 	sub	sp, sp, #8
  204bd4:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  204bd8:	e59d3004 	ldr	r3, [sp, #4]
  204bdc:	e59d2004 	ldr	r2, [sp, #4]
  204be0:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  204be4:	e59d3004 	ldr	r3, [sp, #4]
  204be8:	e59d2004 	ldr	r2, [sp, #4]
  204bec:	e5832004 	str	r2, [r3, #4]
}
  204bf0:	e28dd008 	add	sp, sp, #8
  204bf4:	e12fff1e 	bx	lr
	...

00204c00 <queue_notempty.lto_priv.137>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
  204c00:	e24dd008 	sub	sp, sp, #8
  204c04:	e58d0004 	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
  204c08:	e59d3004 	ldr	r3, [sp, #4]
  204c0c:	e5932000 	ldr	r2, [r3]
  204c10:	e59d3004 	ldr	r3, [sp, #4]
  204c14:	e1520003 	cmp	r2, r3
  204c18:	13a03001 	movne	r3, #1
  204c1c:	03a03000 	moveq	r3, #0
  204c20:	e6ef3073 	uxtb	r3, r3
}
  204c24:	e1a00003 	mov	r0, r3
  204c28:	e28dd008 	add	sp, sp, #8
  204c2c:	e12fff1e 	bx	lr

00204c30 <list_remove>:

  tp->queue.next = tlp->next;
  tlp->next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
  204c30:	e24dd010 	sub	sp, sp, #16
  204c34:	e58d0004 	str	r0, [sp, #4]

  thread_t *tp = tlp->next;
  204c38:	e59d3004 	ldr	r3, [sp, #4]
  204c3c:	e5933000 	ldr	r3, [r3]
  204c40:	e58d300c 	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
  204c44:	e59d300c 	ldr	r3, [sp, #12]
  204c48:	e5932000 	ldr	r2, [r3]
  204c4c:	e59d3004 	ldr	r3, [sp, #4]
  204c50:	e5832000 	str	r2, [r3]

  return tp;
  204c54:	e59d300c 	ldr	r3, [sp, #12]
}
  204c58:	e1a00003 	mov	r0, r3
  204c5c:	e28dd010 	add	sp, sp, #16
  204c60:	e12fff1e 	bx	lr
	...

00204c70 <queue_insert.lto_priv.147>:
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
  204c70:	e24dd008 	sub	sp, sp, #8
  204c74:	e58d0004 	str	r0, [sp, #4]
  204c78:	e58d1000 	str	r1, [sp]

  tp->queue.next             = (thread_t *)tqp;
  204c7c:	e59d3004 	ldr	r3, [sp, #4]
  204c80:	e59d2000 	ldr	r2, [sp]
  204c84:	e5832000 	str	r2, [r3]
  tp->queue.prev             = tqp->prev;
  204c88:	e59d3000 	ldr	r3, [sp]
  204c8c:	e5932004 	ldr	r2, [r3, #4]
  204c90:	e59d3004 	ldr	r3, [sp, #4]
  204c94:	e5832004 	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  204c98:	e59d3004 	ldr	r3, [sp, #4]
  204c9c:	e5933004 	ldr	r3, [r3, #4]
  204ca0:	e59d2004 	ldr	r2, [sp, #4]
  204ca4:	e5832000 	str	r2, [r3]
  tqp->prev                  = tp;
  204ca8:	e59d3000 	ldr	r3, [sp]
  204cac:	e59d2004 	ldr	r2, [sp, #4]
  204cb0:	e5832004 	str	r2, [r3, #4]
}
  204cb4:	e28dd008 	add	sp, sp, #8
  204cb8:	e12fff1e 	bx	lr
  204cbc:	00000000 	andeq	r0, r0, r0

00204cc0 <queue_fifo_remove.lto_priv.131>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  204cc0:	e24dd010 	sub	sp, sp, #16
  204cc4:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
  204cc8:	e59d3004 	ldr	r3, [sp, #4]
  204ccc:	e5933000 	ldr	r3, [r3]
  204cd0:	e58d300c 	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
  204cd4:	e59d300c 	ldr	r3, [sp, #12]
  204cd8:	e5932000 	ldr	r2, [r3]
  204cdc:	e59d3004 	ldr	r3, [sp, #4]
  204ce0:	e5832000 	str	r2, [r3]
  tqp->next->queue.prev = (thread_t *)tqp;
  204ce4:	e59d3004 	ldr	r3, [sp, #4]
  204ce8:	e5933000 	ldr	r3, [r3]
  204cec:	e59d2004 	ldr	r2, [sp, #4]
  204cf0:	e5832004 	str	r2, [r3, #4]

  return tp;
  204cf4:	e59d300c 	ldr	r3, [sp, #12]
}
  204cf8:	e1a00003 	mov	r0, r3
  204cfc:	e28dd010 	add	sp, sp, #16
  204d00:	e12fff1e 	bx	lr
	...

00204d10 <chSysLock.lto_priv.125>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  204d10:	e92d4010 	push	{r4, lr}

  port_lock();
  204d14:	ebffff91 	bl	204b60 <port_lock.lto_priv.110>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  204d18:	e8bd8010 	pop	{r4, pc}
  204d1c:	00000000 	andeq	r0, r0, r0

00204d20 <chSysUnlock.lto_priv.119>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  204d20:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  204d24:	ebffff91 	bl	204b70 <port_unlock.lto_priv.103>
}
  204d28:	e8bd8010 	pop	{r4, pc}
  204d2c:	00000000 	andeq	r0, r0, r0

00204d30 <chThdGetSelfX.lto_priv.116>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
  204d30:	e3003938 	movw	r3, #2360	; 0x938
  204d34:	e3403021 	movt	r3, #33	; 0x21
  204d38:	e5933018 	ldr	r3, [r3, #24]
}
  204d3c:	e1a00003 	mov	r0, r3
  204d40:	e12fff1e 	bx	lr
	...

00204d50 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
  204d50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204d54:	e24dd00c 	sub	sp, sp, #12
  204d58:	e58d0004 	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
  204d5c:	e59d1004 	ldr	r1, [sp, #4]
  204d60:	e3a00008 	mov	r0, #8
  204d64:	ebfffefd 	bl	204960 <chSchGoSleepTimeoutS>
}
  204d68:	e28dd00c 	add	sp, sp, #12
  204d6c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00204d70 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  204d70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204d74:	e24dd014 	sub	sp, sp, #20
  204d78:	e58d0004 	str	r0, [sp, #4]
  204d7c:	e58d1000 	str	r1, [sp]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
  204d80:	e59d0004 	ldr	r0, [sp, #4]
  204d84:	ebffffcd 	bl	204cc0 <queue_fifo_remove.lto_priv.131>
  204d88:	e58d000c 	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  204d8c:	e59d300c 	ldr	r3, [sp, #12]
  204d90:	e59d2000 	ldr	r2, [sp]
  204d94:	e5832028 	str	r2, [r3, #40]	; 0x28
  (void) chSchReadyI(tp);
  204d98:	e59d000c 	ldr	r0, [sp, #12]
  204d9c:	ebfffe5f 	bl	204720 <chSchReadyI>
}
  204da0:	e28dd014 	add	sp, sp, #20
  204da4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204db0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
  204db0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204db4:	e24dd014 	sub	sp, sp, #20
  204db8:	e58d000c 	str	r0, [sp, #12]
  204dbc:	e58d1008 	str	r1, [sp, #8]
  204dc0:	e58d2004 	str	r2, [sp, #4]

  tp->prio      = prio;
  204dc4:	e59d300c 	ldr	r3, [sp, #12]
  204dc8:	e59d2004 	ldr	r2, [sp, #4]
  204dcc:	e5832008 	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
  204dd0:	e59d300c 	ldr	r3, [sp, #12]
  204dd4:	e3a02002 	mov	r2, #2
  204dd8:	e5c32020 	strb	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
  204ddc:	e59d300c 	ldr	r3, [sp, #12]
  204de0:	e3a02000 	mov	r2, #0
  204de4:	e5c32021 	strb	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  204de8:	e59d300c 	ldr	r3, [sp, #12]
  204dec:	e59d2004 	ldr	r2, [sp, #4]
  204df0:	e5832040 	str	r2, [r3, #64]	; 0x40
  tp->mtxlist   = NULL;
  204df4:	e59d300c 	ldr	r3, [sp, #12]
  204df8:	e3a02000 	mov	r2, #0
  204dfc:	e583203c 	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
  204e00:	e59d300c 	ldr	r3, [sp, #12]
  204e04:	e3a02000 	mov	r2, #0
  204e08:	e5832038 	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
  204e0c:	e59d300c 	ldr	r3, [sp, #12]
  204e10:	e3a02000 	mov	r2, #0
  204e14:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  204e18:	e59d300c 	ldr	r3, [sp, #12]
  204e1c:	e3a02001 	mov	r2, #1
  204e20:	e5c32022 	strb	r2, [r3, #34]	; 0x22
  tp->name      = name;
  204e24:	e59d300c 	ldr	r3, [sp, #12]
  204e28:	e59d2008 	ldr	r2, [sp, #8]
  204e2c:	e5832018 	str	r2, [r3, #24]
  REG_INSERT(tp);
  204e30:	e59d200c 	ldr	r2, [sp, #12]
  204e34:	e3003938 	movw	r3, #2360	; 0x938
  204e38:	e3403021 	movt	r3, #33	; 0x21
  204e3c:	e5823010 	str	r3, [r2, #16]
  204e40:	e3003938 	movw	r3, #2360	; 0x938
  204e44:	e3403021 	movt	r3, #33	; 0x21
  204e48:	e5932014 	ldr	r2, [r3, #20]
  204e4c:	e59d300c 	ldr	r3, [sp, #12]
  204e50:	e5832014 	str	r2, [r3, #20]
  204e54:	e59d300c 	ldr	r3, [sp, #12]
  204e58:	e5933014 	ldr	r3, [r3, #20]
  204e5c:	e59d200c 	ldr	r2, [sp, #12]
  204e60:	e5832010 	str	r2, [r3, #16]
  204e64:	e3003938 	movw	r3, #2360	; 0x938
  204e68:	e3403021 	movt	r3, #33	; 0x21
  204e6c:	e59d200c 	ldr	r2, [sp, #12]
  204e70:	e5832014 	str	r2, [r3, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
  204e74:	e59d300c 	ldr	r3, [sp, #12]
  204e78:	e283302c 	add	r3, r3, #44	; 0x2c
  204e7c:	e1a00003 	mov	r0, r3
  204e80:	ebffff3e 	bl	204b80 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
  204e84:	e59d300c 	ldr	r3, [sp, #12]
  204e88:	e2833030 	add	r3, r3, #48	; 0x30
  204e8c:	e1a00003 	mov	r0, r3
  204e90:	ebffff4e 	bl	204bd0 <queue_init.lto_priv.141>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
  204e94:	e59d300c 	ldr	r3, [sp, #12]
}
  204e98:	e1a00003 	mov	r0, r3
  204e9c:	e28dd014 	add	sp, sp, #20
  204ea0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204eb0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  204eb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204eb4:	e24dd014 	sub	sp, sp, #20
  204eb8:	e58d0004 	str	r0, [sp, #4]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
  204ebc:	e59d3004 	ldr	r3, [sp, #4]
  204ec0:	e5933008 	ldr	r3, [r3, #8]
  204ec4:	e2433048 	sub	r3, r3, #72	; 0x48
  204ec8:	e58d300c 	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
  204ecc:	e59d3004 	ldr	r3, [sp, #4]
  204ed0:	e5932004 	ldr	r2, [r3, #4]
  204ed4:	e59d300c 	ldr	r3, [sp, #12]
  204ed8:	e583201c 	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204edc:	e59d300c 	ldr	r3, [sp, #12]
  204ee0:	e2432024 	sub	r2, r3, #36	; 0x24
  204ee4:	e59d300c 	ldr	r3, [sp, #12]
  204ee8:	e583200c 	str	r2, [r3, #12]
  204eec:	e59d300c 	ldr	r3, [sp, #12]
  204ef0:	e593300c 	ldr	r3, [r3, #12]
  204ef4:	e59d2004 	ldr	r2, [sp, #4]
  204ef8:	e5922010 	ldr	r2, [r2, #16]
  204efc:	e5832000 	str	r2, [r3]
  204f00:	e59d300c 	ldr	r3, [sp, #12]
  204f04:	e593300c 	ldr	r3, [r3, #12]
  204f08:	e59d2004 	ldr	r2, [sp, #4]
  204f0c:	e5922014 	ldr	r2, [r2, #20]
  204f10:	e5832004 	str	r2, [r3, #4]
  204f14:	e59d300c 	ldr	r3, [sp, #12]
  204f18:	e593200c 	ldr	r2, [r3, #12]
  204f1c:	e3003300 	movw	r3, #768	; 0x300
  204f20:	e3403020 	movt	r3, #32
  204f24:	e5823020 	str	r3, [r2, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
  204f28:	e59d3004 	ldr	r3, [sp, #4]
  204f2c:	e5931000 	ldr	r1, [r3]
  204f30:	e59d3004 	ldr	r3, [sp, #4]
  204f34:	e593300c 	ldr	r3, [r3, #12]
  204f38:	e1a02003 	mov	r2, r3
  204f3c:	e59d000c 	ldr	r0, [sp, #12]
  204f40:	ebffff9a 	bl	204db0 <_thread_init>
  204f44:	e1a03000 	mov	r3, r0
}
  204f48:	e1a00003 	mov	r0, r3
  204f4c:	e28dd014 	add	sp, sp, #20
  204f50:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204f60 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  204f60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204f64:	e24dd014 	sub	sp, sp, #20
  204f68:	e58d0004 	str	r0, [sp, #4]
  _thread_memfill((uint8_t *)tdp->wbase,
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  204f6c:	ebffff67 	bl	204d10 <chSysLock.lto_priv.125>
  tp = chThdCreateSuspendedI(tdp);
  204f70:	e59d0004 	ldr	r0, [sp, #4]
  204f74:	ebffffcd 	bl	204eb0 <chThdCreateSuspendedI>
  204f78:	e58d000c 	str	r0, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
  204f7c:	e3a01000 	mov	r1, #0
  204f80:	e59d000c 	ldr	r0, [sp, #12]
  204f84:	ebfffe9d 	bl	204a00 <chSchWakeupS>
  chSysUnlock();
  204f88:	ebffff64 	bl	204d20 <chSysUnlock.lto_priv.119>

  return tp;
  204f8c:	e59d300c 	ldr	r3, [sp, #12]
}
  204f90:	e1a00003 	mov	r0, r3
  204f94:	e28dd014 	add	sp, sp, #20
  204f98:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  204f9c:	00000000 	andeq	r0, r0, r0

00204fa0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
  204fa0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204fa4:	e24dd01c 	sub	sp, sp, #28
  204fa8:	e58d000c 	str	r0, [sp, #12]
  204fac:	e58d1008 	str	r1, [sp, #8]
  204fb0:	e58d2004 	str	r2, [sp, #4]
  204fb4:	e58d3000 	str	r3, [sp]
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  204fb8:	ebffff54 	bl	204d10 <chSysLock.lto_priv.125>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
  204fbc:	e59d3008 	ldr	r3, [sp, #8]
  204fc0:	e2433048 	sub	r3, r3, #72	; 0x48
  204fc4:	e59d200c 	ldr	r2, [sp, #12]
  204fc8:	e0823003 	add	r3, r2, r3
  204fcc:	e58d3014 	str	r3, [sp, #20]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
  204fd0:	e59d3014 	ldr	r3, [sp, #20]
  204fd4:	e59d200c 	ldr	r2, [sp, #12]
  204fd8:	e583201c 	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  204fdc:	e59d3014 	ldr	r3, [sp, #20]
  204fe0:	e2432024 	sub	r2, r3, #36	; 0x24
  204fe4:	e59d3014 	ldr	r3, [sp, #20]
  204fe8:	e583200c 	str	r2, [r3, #12]
  204fec:	e59d3014 	ldr	r3, [sp, #20]
  204ff0:	e593300c 	ldr	r3, [r3, #12]
  204ff4:	e59d2000 	ldr	r2, [sp]
  204ff8:	e5832000 	str	r2, [r3]
  204ffc:	e59d3014 	ldr	r3, [sp, #20]
  205000:	e593300c 	ldr	r3, [r3, #12]
  205004:	e59d2020 	ldr	r2, [sp, #32]
  205008:	e5832004 	str	r2, [r3, #4]
  20500c:	e59d3014 	ldr	r3, [sp, #20]
  205010:	e593200c 	ldr	r2, [r3, #12]
  205014:	e3003300 	movw	r3, #768	; 0x300
  205018:	e3403020 	movt	r3, #32
  20501c:	e5823020 	str	r3, [r2, #32]

  tp = _thread_init(tp, "noname", prio);
  205020:	e59d2004 	ldr	r2, [sp, #4]
  205024:	e30514d0 	movw	r1, #21712	; 0x54d0
  205028:	e3401020 	movt	r1, #32
  20502c:	e59d0014 	ldr	r0, [sp, #20]
  205030:	ebffff5e 	bl	204db0 <_thread_init>
  205034:	e58d0014 	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
  205038:	e3a01000 	mov	r1, #0
  20503c:	e59d0014 	ldr	r0, [sp, #20]
  205040:	ebfffe6e 	bl	204a00 <chSchWakeupS>
  chSysUnlock();
  205044:	ebffff35 	bl	204d20 <chSysUnlock.lto_priv.119>

  return tp;
  205048:	e59d3014 	ldr	r3, [sp, #20]
}
  20504c:	e1a00003 	mov	r0, r3
  205050:	e28dd01c 	add	sp, sp, #28
  205054:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00205060 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
  205060:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205064:	e24dd00c 	sub	sp, sp, #12
  205068:	e58d0004 	str	r0, [sp, #4]

  chSysLock();
  20506c:	ebffff27 	bl	204d10 <chSysLock.lto_priv.125>
  chThdExitS(msg);
  205070:	e59d0004 	ldr	r0, [sp, #4]
  205074:	eb000001 	bl	205080 <chThdExitS>
  /* The thread never returns here.*/
}
  205078:	e28dd00c 	add	sp, sp, #12
  20507c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00205080 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  205080:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205084:	e24dd014 	sub	sp, sp, #20
  205088:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = currp;
  20508c:	e3003938 	movw	r3, #2360	; 0x938
  205090:	e3403021 	movt	r3, #33	; 0x21
  205094:	e5933018 	ldr	r3, [r3, #24]
  205098:	e58d300c 	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
  20509c:	e59d300c 	ldr	r3, [sp, #12]
  2050a0:	e59d2004 	ldr	r2, [sp, #4]
  2050a4:	e5832028 	str	r2, [r3, #40]	; 0x28
  2050a8:	ea000006 	b	2050c8 <chThdExitS+0x48>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
  2050ac:	e59d300c 	ldr	r3, [sp, #12]
  2050b0:	e283302c 	add	r3, r3, #44	; 0x2c
  2050b4:	e1a00003 	mov	r0, r3
  2050b8:	ebfffedc 	bl	204c30 <list_remove>
  2050bc:	e1a03000 	mov	r3, r0
  2050c0:	e1a00003 	mov	r0, r3
  2050c4:	ebfffd95 	bl	204720 <chSchReadyI>
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
  2050c8:	e59d300c 	ldr	r3, [sp, #12]
  2050cc:	e283302c 	add	r3, r3, #44	; 0x2c
  2050d0:	e1a00003 	mov	r0, r3
  2050d4:	ebfffeb1 	bl	204ba0 <list_notempty>
  2050d8:	e1a03000 	mov	r3, r0
  2050dc:	e3530000 	cmp	r3, #0
  2050e0:	1afffff1 	bne	2050ac <chThdExitS+0x2c>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
  2050e4:	e59d300c 	ldr	r3, [sp, #12]
  2050e8:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
  2050ec:	e3530000 	cmp	r3, #0
  2050f0:	1a00000e 	bne	205130 <chThdExitS+0xb0>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
  2050f4:	e59d300c 	ldr	r3, [sp, #12]
  2050f8:	e5d33021 	ldrb	r3, [r3, #33]	; 0x21
  2050fc:	e2033003 	and	r3, r3, #3

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
  205100:	e3530000 	cmp	r3, #0
  205104:	1a000009 	bne	205130 <chThdExitS+0xb0>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
  205108:	e59d300c 	ldr	r3, [sp, #12]
  20510c:	e5933014 	ldr	r3, [r3, #20]
  205110:	e59d200c 	ldr	r2, [sp, #12]
  205114:	e5922010 	ldr	r2, [r2, #16]
  205118:	e5832010 	str	r2, [r3, #16]
  20511c:	e59d300c 	ldr	r3, [sp, #12]
  205120:	e5933010 	ldr	r3, [r3, #16]
  205124:	e59d200c 	ldr	r2, [sp, #12]
  205128:	e5922014 	ldr	r2, [r2, #20]
  20512c:	e5832014 	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
  205130:	e3a0000f 	mov	r0, #15
  205134:	ebfffdc1 	bl	204840 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
  205138:	e28dd014 	add	sp, sp, #20
  20513c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00205140 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
  205140:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205144:	e24dd00c 	sub	sp, sp, #12
  205148:	e58d0004 	str	r0, [sp, #4]

  chSysLock();
  20514c:	ebfffeef 	bl	204d10 <chSysLock.lto_priv.125>
  chThdSleepS(time);
  205150:	e59d0004 	ldr	r0, [sp, #4]
  205154:	ebfffefd 	bl	204d50 <chThdSleepS>
  chSysUnlock();
  205158:	ebfffef0 	bl	204d20 <chSysUnlock.lto_priv.119>
}
  20515c:	e28dd00c 	add	sp, sp, #12
  205160:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00205170 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
  205170:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205174:	e24dd014 	sub	sp, sp, #20
  205178:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
  20517c:	ebfffeeb 	bl	204d30 <chThdGetSelfX.lto_priv.116>
  205180:	e58d000c 	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  205184:	e59d3004 	ldr	r3, [sp, #4]
  205188:	e59d200c 	ldr	r2, [sp, #12]
  20518c:	e5832000 	str	r2, [r3]
  tp->u.wttrp = trp;
  205190:	e59d300c 	ldr	r3, [sp, #12]
  205194:	e59d2004 	ldr	r2, [sp, #4]
  205198:	e5832028 	str	r2, [r3, #40]	; 0x28
  chSchGoSleepS(CH_STATE_SUSPENDED);
  20519c:	e3a00003 	mov	r0, #3
  2051a0:	ebfffda6 	bl	204840 <chSchGoSleepS>

  return chThdGetSelfX()->u.rdymsg;
  2051a4:	ebfffee1 	bl	204d30 <chThdGetSelfX.lto_priv.116>
  2051a8:	e1a03000 	mov	r3, r0
  2051ac:	e5933028 	ldr	r3, [r3, #40]	; 0x28
}
  2051b0:	e1a00003 	mov	r0, r3
  2051b4:	e28dd014 	add	sp, sp, #20
  2051b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2051bc:	00000000 	andeq	r0, r0, r0

002051c0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
  2051c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2051c4:	e24dd014 	sub	sp, sp, #20
  2051c8:	e58d0004 	str	r0, [sp, #4]
  2051cc:	e58d1000 	str	r1, [sp]

  if (*trp != NULL) {
  2051d0:	e59d3004 	ldr	r3, [sp, #4]
  2051d4:	e5933000 	ldr	r3, [r3]
  2051d8:	e3530000 	cmp	r3, #0
  2051dc:	0a00000a 	beq	20520c <chThdResumeI+0x4c>
    thread_t *tp = *trp;
  2051e0:	e59d3004 	ldr	r3, [sp, #4]
  2051e4:	e5933000 	ldr	r3, [r3]
  2051e8:	e58d300c 	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
  2051ec:	e59d3004 	ldr	r3, [sp, #4]
  2051f0:	e3a02000 	mov	r2, #0
  2051f4:	e5832000 	str	r2, [r3]
    tp->u.rdymsg = msg;
  2051f8:	e59d300c 	ldr	r3, [sp, #12]
  2051fc:	e59d2000 	ldr	r2, [sp]
  205200:	e5832028 	str	r2, [r3, #40]	; 0x28
    (void) chSchReadyI(tp);
  205204:	e59d000c 	ldr	r0, [sp, #12]
  205208:	ebfffd44 	bl	204720 <chSchReadyI>
  }
}
  20520c:	e28dd014 	add	sp, sp, #20
  205210:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00205220 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
  205220:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205224:	e24dd00c 	sub	sp, sp, #12
  205228:	e58d0004 	str	r0, [sp, #4]
  20522c:	e58d1000 	str	r1, [sp]

  if (TIME_IMMEDIATE == timeout) {
  205230:	e59d3000 	ldr	r3, [sp]
  205234:	e3530000 	cmp	r3, #0
  205238:	1a000001 	bne	205244 <chThdEnqueueTimeoutS+0x24>
    return MSG_TIMEOUT;
  20523c:	e3e03000 	mvn	r3, #0
  205240:	ea000009 	b	20526c <chThdEnqueueTimeoutS+0x4c>
  }

  queue_insert(currp, tqp);
  205244:	e3003938 	movw	r3, #2360	; 0x938
  205248:	e3403021 	movt	r3, #33	; 0x21
  20524c:	e5933018 	ldr	r3, [r3, #24]
  205250:	e59d1004 	ldr	r1, [sp, #4]
  205254:	e1a00003 	mov	r0, r3
  205258:	ebfffe84 	bl	204c70 <queue_insert.lto_priv.147>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  20525c:	e59d1000 	ldr	r1, [sp]
  205260:	e3a00004 	mov	r0, #4
  205264:	ebfffdbd 	bl	204960 <chSchGoSleepTimeoutS>
  205268:	e1a03000 	mov	r3, r0
}
  20526c:	e1a00003 	mov	r0, r3
  205270:	e28dd00c 	add	sp, sp, #12
  205274:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00205280 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  205280:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205284:	e24dd00c 	sub	sp, sp, #12
  205288:	e58d0004 	str	r0, [sp, #4]
  20528c:	e58d1000 	str	r1, [sp]

  if (queue_notempty(tqp)) {
  205290:	e59d0004 	ldr	r0, [sp, #4]
  205294:	ebfffe59 	bl	204c00 <queue_notempty.lto_priv.137>
  205298:	e1a03000 	mov	r3, r0
  20529c:	e3530000 	cmp	r3, #0
  2052a0:	0a000002 	beq	2052b0 <chThdDequeueNextI+0x30>
    chThdDoDequeueNextI(tqp, msg);
  2052a4:	e59d1000 	ldr	r1, [sp]
  2052a8:	e59d0004 	ldr	r0, [sp, #4]
  2052ac:	ebfffeaf 	bl	204d70 <chThdDoDequeueNextI>
  }
}
  2052b0:	e28dd00c 	add	sp, sp, #12
  2052b4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002052c0 <queue_init.lto_priv.143>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  2052c0:	e24dd008 	sub	sp, sp, #8
  2052c4:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  2052c8:	e59d3004 	ldr	r3, [sp, #4]
  2052cc:	e59d2004 	ldr	r2, [sp, #4]
  2052d0:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  2052d4:	e59d3004 	ldr	r3, [sp, #4]
  2052d8:	e59d2004 	ldr	r2, [sp, #4]
  2052dc:	e5832004 	str	r2, [r3, #4]
}
  2052e0:	e28dd008 	add	sp, sp, #8
  2052e4:	e12fff1e 	bx	lr
	...

002052f0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
  2052f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2052f4:	e24dd00c 	sub	sp, sp, #12
  2052f8:	e58d0004 	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  2052fc:	e59d3004 	ldr	r3, [sp, #4]
  205300:	e1a00003 	mov	r0, r3
  205304:	ebffffed 	bl	2052c0 <queue_init.lto_priv.143>
  mp->owner = NULL;
  205308:	e59d3004 	ldr	r3, [sp, #4]
  20530c:	e3a02000 	mov	r2, #0
  205310:	e5832008 	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
  205314:	e28dd00c 	add	sp, sp, #12
  205318:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20531c:	00000000 	andeq	r0, r0, r0

00205320 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  205320:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205324:	e24dd014 	sub	sp, sp, #20
  205328:	e58d0004 	str	r0, [sp, #4]
  20532c:	e58d1000 	str	r1, [sp]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  205330:	e59d3004 	ldr	r3, [sp, #4]
  205334:	e5933000 	ldr	r3, [r3]
  205338:	e58d300c 	str	r3, [sp, #12]
  20533c:	ea000019 	b	2053a8 <chEvtBroadcastFlagsI+0x88>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
  205340:	e59d300c 	ldr	r3, [sp, #12]
  205344:	e593200c 	ldr	r2, [r3, #12]
  205348:	e59d3000 	ldr	r3, [sp]
  20534c:	e1822003 	orr	r2, r2, r3
  205350:	e59d300c 	ldr	r3, [sp, #12]
  205354:	e583200c 	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
  205358:	e59d3000 	ldr	r3, [sp]
  20535c:	e3530000 	cmp	r3, #0
  205360:	0a000006 	beq	205380 <chEvtBroadcastFlagsI+0x60>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
  205364:	e59d300c 	ldr	r3, [sp, #12]
  205368:	e593200c 	ldr	r2, [r3, #12]
  20536c:	e59d300c 	ldr	r3, [sp, #12]
  205370:	e5933010 	ldr	r3, [r3, #16]
  205374:	e0033002 	and	r3, r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
  205378:	e3530000 	cmp	r3, #0
  20537c:	0a000006 	beq	20539c <chEvtBroadcastFlagsI+0x7c>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
  205380:	e59d300c 	ldr	r3, [sp, #12]
  205384:	e5932004 	ldr	r2, [r3, #4]
  205388:	e59d300c 	ldr	r3, [sp, #12]
  20538c:	e5933008 	ldr	r3, [r3, #8]
  205390:	e1a01003 	mov	r1, r3
  205394:	e1a00002 	mov	r0, r2
  205398:	ebfffab8 	bl	203e80 <chEvtSignalI>
    }
    elp = elp->next;
  20539c:	e59d300c 	ldr	r3, [sp, #12]
  2053a0:	e5933000 	ldr	r3, [r3]
  2053a4:	e58d300c 	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  2053a8:	e59d200c 	ldr	r2, [sp, #12]
  2053ac:	e59d3004 	ldr	r3, [sp, #4]
  2053b0:	e1520003 	cmp	r2, r3
  2053b4:	1affffe1 	bne	205340 <chEvtBroadcastFlagsI+0x20>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
  2053b8:	e28dd014 	add	sp, sp, #20
  2053bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

002053c0 <memcmp>:
  2053c0:	e3520003 	cmp	r2, #3
  2053c4:	e92d4010 	push	{r4, lr}
  2053c8:	9a000011 	bls	205414 <memcmp+0x54>
  2053cc:	e1803001 	orr	r3, r0, r1
  2053d0:	e3130003 	tst	r3, #3
  2053d4:	1a000010 	bne	20541c <memcmp+0x5c>
  2053d8:	e1a0c001 	mov	ip, r1
  2053dc:	e1a03000 	mov	r3, r0
  2053e0:	e5934000 	ldr	r4, [r3]
  2053e4:	e1a00003 	mov	r0, r3
  2053e8:	e59ce000 	ldr	lr, [ip]
  2053ec:	e1a0100c 	mov	r1, ip
  2053f0:	e2833004 	add	r3, r3, #4
  2053f4:	e28cc004 	add	ip, ip, #4
  2053f8:	e154000e 	cmp	r4, lr
  2053fc:	1a000006 	bne	20541c <memcmp+0x5c>
  205400:	e2422004 	sub	r2, r2, #4
  205404:	e1a00003 	mov	r0, r3
  205408:	e3520003 	cmp	r2, #3
  20540c:	e1a0100c 	mov	r1, ip
  205410:	8afffff2 	bhi	2053e0 <memcmp+0x20>
  205414:	e3520000 	cmp	r2, #0
  205418:	0a000010 	beq	205460 <memcmp+0xa0>
  20541c:	e5d0c000 	ldrb	ip, [r0]
  205420:	e5d1e000 	ldrb	lr, [r1]
  205424:	e15c000e 	cmp	ip, lr
  205428:	00802002 	addeq	r2, r0, r2
  20542c:	02803001 	addeq	r3, r0, #1
  205430:	0a000004 	beq	205448 <memcmp+0x88>
  205434:	ea000007 	b	205458 <memcmp+0x98>
  205438:	e4d3c001 	ldrb	ip, [r3], #1
  20543c:	e5f1e001 	ldrb	lr, [r1, #1]!
  205440:	e15c000e 	cmp	ip, lr
  205444:	1a000003 	bne	205458 <memcmp+0x98>
  205448:	e1530002 	cmp	r3, r2
  20544c:	1afffff9 	bne	205438 <memcmp+0x78>
  205450:	e3a00000 	mov	r0, #0
  205454:	e8bd8010 	pop	{r4, pc}
  205458:	e06e000c 	rsb	r0, lr, ip
  20545c:	e8bd8010 	pop	{r4, pc}
  205460:	e1a00002 	mov	r0, r2
  205464:	e8bd8010 	pop	{r4, pc}
	...
  205470:	656c6469 	.word	0x656c6469
  205474:	00000000 	.word	0x00000000
  205478:	20414d44 	.word	0x20414d44
  20547c:	6c696166 	.word	0x6c696166
  205480:	00657275 	.word	0x00657275
  205484:	6c756e28 	.word	0x6c756e28
  205488:	0000296c 	.word	0x0000296c
  20548c:	6e696c62 	.word	0x6e696c62
  205490:	0072656b 	.word	0x0072656b
  205494:	6e617254 	.word	0x6e617254
  205498:	72656673 	.word	0x72656673
  20549c:	6d6f6320 	.word	0x6d6f6320
  2054a0:	74656c70 	.word	0x74656c70
  2054a4:	000d0a65 	.word	0x000d0a65
  2054a8:	4f525245 	.word	0x4f525245
  2054ac:	42203a52 	.word	0x42203a52
  2054b0:	65666675 	.word	0x65666675
  2054b4:	61207372 	.word	0x61207372
  2054b8:	6e206572 	.word	0x6e206572
  2054bc:	7420746f 	.word	0x7420746f
  2054c0:	73206568 	.word	0x73206568
  2054c4:	21656d61 	.word	0x21656d61
  2054c8:	00000d0a 	.word	0x00000d0a
  2054cc:	00000000 	.word	0x00000000
  2054d0:	616e6f6e 	.word	0x616e6f6e
  2054d4:	0000656d 	.word	0x0000656d
	...

002054e0 <idle_descriptor.7911.lto_priv.159>:
  2054e0:	00205470 00210868 00210938 00000001     pT .h.!.8.!.....
  2054f0:	002042a0 00000000 00000000 00000000     .B .............

00205500 <ch_debug>:
  205500:	6e69616d 28001600 08480404 1814100c     main...(..H.....
  205510:	2221201c 00002400 00000000 00000000     . !".$..........

00205520 <vmt.lto_priv.46>:
  205520:	00202840 00202880 002028c0 00202900     @( ..( ..( ..) .
  205530:	00202930 00202970 002029b0 002029f0     0) .p) ..) ..) .
  205540:	00202a30 00000000 00000000 00000000     0* .............

00205550 <default_config>:
  205550:	00009600 00000000 00000800 00000000     ................

00205560 <sama_inits>:
  205560:	00000001 00000061 00030100 00000001     ....a...........
  205570:	00000001 00000200 00008200 00000001     ................
  205580:	ffffffff 00000000 00000000 00000000     ................

00205590 <mst_spicfg>:
  205590:	00201f10 00000000 00000091 00000100     .. .............
