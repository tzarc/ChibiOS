
build/ch.elf:     file format elf32-littlearm


Disassembly of section startup:

00200000 <_start>:
/*
 * System entry points.
 */
                .global _start
_start:
                ldr     pc, _reset
  200000:	e59ff018 	ldr	pc, [pc, #24]	; 200020 <_reset>
                ldr     pc, _undefined
  200004:	e59ff018 	ldr	pc, [pc, #24]	; 200024 <_undefined>
                ldr     pc, _swi
  200008:	e59ff018 	ldr	pc, [pc, #24]	; 200028 <_swi>
                ldr     pc, _prefetch
  20000c:	e59ff018 	ldr	pc, [pc, #24]	; 20002c <_prefetch>
                ldr     pc, _abort
  200010:	e59ff018 	ldr	pc, [pc, #24]	; 200030 <_abort>
                nop
  200014:	e320f000 	nop	{0}
                ldr     pc, _irq
  200018:	e59ff018 	ldr	pc, [pc, #24]	; 200038 <_irq>
                ldr     pc, _fiq
  20001c:	e59ff010 	ldr	pc, [pc, #16]	; 200034 <_fiq>

00200020 <_reset>:
  200020:	00200040 	.word	0x00200040

00200024 <_undefined>:
  200024:	0020003c 	.word	0x0020003c

00200028 <_swi>:
  200028:	0020003c 	.word	0x0020003c

0020002c <_prefetch>:
  20002c:	0020003c 	.word	0x0020003c

00200030 <_abort>:
  200030:	0020003c 	.word	0x0020003c

00200034 <_fiq>:
  200034:	0020029c 	.word	0x0020029c

00200038 <_irq>:
  200038:	0020003c 	.word	0x0020003c

0020003c <Abort_Handler>:
Fiq_Handler:
                .weak   Irq_Handler
Irq_Handler:
                .weak   _unhandled_exception
_unhandled_exception:
                b       _unhandled_exception
  20003c:	eafffffe 	b	20003c <Abort_Handler>

00200040 <Boot_Handler>:
				.global Boot_Handler
Boot_Handler:
				/*
				 * Set VBAR to system vectors table
				 */
                ldr		r0, =_start
  200040:	e59f0058 	ldr	r0, [pc, #88]	; 2000a0 <Boot_Handler+0x60>
                mcr 	p15, 0, r0, c12, c0, 0
  200044:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
                /*
                 * Do not redirect secure interrupts to AIC
                 */
				ldr		r0, =AIC_REDIR_KEY
  200048:	e59f0054 	ldr	r0, [pc, #84]	; 2000a4 <Boot_Handler+0x64>
				ldr             r1, =SFR_SN1
  20004c:	e59f1054 	ldr	r1, [pc, #84]	; 2000a8 <Boot_Handler+0x68>
				ldr		r1, [r1]
  200050:	e5911000 	ldr	r1, [r1]
				eor		r0, r0, r1
  200054:	e0200001 	eor	r0, r0, r1
				bic		r0, r0, #0x1
  200058:	e3c00001 	bic	r0, r0, #1
				ldr		r1, =SFR_AICREDIR
  20005c:	e59f1048 	ldr	r1, [pc, #72]	; 2000ac <Boot_Handler+0x6c>
				str		r0, [r1]
  200060:	e5810000 	str	r0, [r1]
                /*
                 * Reset SCTLR Settings
                 */
                mrc     p15, 0, r0, c1, c0, 0       // Read CP15 System Control register
  200064:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
                bic     r0, r0, #(0x1 << 12)        // Clear I bit 12 to disable I Cache
  200068:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
                bic     r0, r0, #(0x1 <<  2)        // Clear C bit  2 to disable D Cache
  20006c:	e3c00004 	bic	r0, r0, #4
                bic     r0, r0, #0x1                // Clear M bit  0 to disable MMU
  200070:	e3c00001 	bic	r0, r0, #1
                bic     r0, r0, #(0x1 << 11)        // Clear Z bit 11 to disable branch prediction
  200074:	e3c00b02 	bic	r0, r0, #2048	; 0x800
                bic     r0, r0, #(0x1 << 13)        // Clear V bit 13 to disable hivecs
  200078:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
                mcr     p15, 0, r0, c1, c0, 0       // Write value back to CP15 System Control register
  20007c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
                isb
  200080:	f57ff06f 	isb	sy
                /*
                 * Turn off L2Cache
                 */
                bic     r0, r0, #0x1
  200084:	e3c00001 	bic	r0, r0, #1
                ldr     r1, =L2CC_CR
  200088:	e59f1020 	ldr	r1, [pc, #32]	; 2000b0 <Boot_Handler+0x70>
                str     r0, [r1]
  20008c:	e5810000 	str	r0, [r1]
                /*
                 * Configure the L2 cache to be used as an internal SRAM
                 */
                bic     r0, r0, #0x1
  200090:	e3c00001 	bic	r0, r0, #1
                ldr     r1, =SFR_L2CC_HRAMC
  200094:	e59f1018 	ldr	r1, [pc, #24]	; 2000b4 <Boot_Handler+0x74>
                str     r0, [r1]
  200098:	e5810000 	str	r0, [r1]
                b       Reset_Handler
  20009c:	ea00000b 	b	2000d0 <Reset_Handler>
				.global Boot_Handler
Boot_Handler:
				/*
				 * Set VBAR to system vectors table
				 */
                ldr		r0, =_start
  2000a0:	00200000 	.word	0x00200000
                mcr 	p15, 0, r0, c12, c0, 0
                /*
                 * Do not redirect secure interrupts to AIC
                 */
				ldr		r0, =AIC_REDIR_KEY
  2000a4:	b6d81c4c 	.word	0xb6d81c4c
				ldr             r1, =SFR_SN1
  2000a8:	f8030050 	.word	0xf8030050
				ldr		r1, [r1]
				eor		r0, r0, r1
				bic		r0, r0, #0x1
				ldr		r1, =SFR_AICREDIR
  2000ac:	f8030054 	.word	0xf8030054
                isb
                /*
                 * Turn off L2Cache
                 */
                bic     r0, r0, #0x1
                ldr     r1, =L2CC_CR
  2000b0:	00a00100 	.word	0x00a00100
                str     r0, [r1]
                /*
                 * Configure the L2 cache to be used as an internal SRAM
                 */
                bic     r0, r0, #0x1
                ldr     r1, =SFR_L2CC_HRAMC
  2000b4:	f8030058 	.word	0xf8030058
	...
 * Default boot handler. Jump to Reset_Handler.
 */
                .section .boot, "ax"
                .weak	Boot_Handler
Boot_Handler:
                b       Reset_Handler
  2000c0:	ea000002 	b	2000d0 <Reset_Handler>

Disassembly of section .text:

002000d0 <Reset_Handler>:
                .global Reset_Handler
Reset_Handler:
                /*
                 * Stack pointers initialization.
                 */
                ldr     r0, =__stacks_end__
  2000d0:	e59f0098 	ldr	r0, [pc, #152]	; 200170 <bssloop+0x18>
                /* Undefined */
                msr     CPSR_c, #MODE_UND | I_BIT | F_BIT
  2000d4:	e321f0db 	msr	CPSR_c, #219	; 0xdb
                mov     sp, r0
  2000d8:	e1a0d000 	mov	sp, r0
                ldr     r1, =__und_stack_size__
  2000dc:	e59f1090 	ldr	r1, [pc, #144]	; 200174 <bssloop+0x1c>
                sub     r0, r0, r1
  2000e0:	e0400001 	sub	r0, r0, r1
                /* Abort */
                msr     CPSR_c, #MODE_ABT | I_BIT | F_BIT
  2000e4:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
                mov     sp, r0
  2000e8:	e1a0d000 	mov	sp, r0
                ldr     r1, =__abt_stack_size__
  2000ec:	e59f1084 	ldr	r1, [pc, #132]	; 200178 <bssloop+0x20>
                sub     r0, r0, r1
  2000f0:	e0400001 	sub	r0, r0, r1
                /* FIQ */
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2000f4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                mov     sp, r0
  2000f8:	e1a0d000 	mov	sp, r0
                ldr     r1, =__fiq_stack_size__
  2000fc:	e59f1078 	ldr	r1, [pc, #120]	; 20017c <bssloop+0x24>
                sub     r0, r0, r1
  200100:	e0400001 	sub	r0, r0, r1
                /* IRQ */
                msr     CPSR_c, #MODE_IRQ | I_BIT | F_BIT
  200104:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
                mov     sp, r0
  200108:	e1a0d000 	mov	sp, r0
                ldr     r1, =__irq_stack_size__
  20010c:	e59f106c 	ldr	r1, [pc, #108]	; 200180 <bssloop+0x28>
                sub     r0, r0, r1
  200110:	e0400001 	sub	r0, r0, r1
                /* Supervisor */
                msr     CPSR_c, #MODE_SVC | I_BIT | F_BIT
  200114:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
                mov     sp, r0
  200118:	e1a0d000 	mov	sp, r0
                ldr     r1, =__svc_stack_size__
  20011c:	e59f1060 	ldr	r1, [pc, #96]	; 200184 <bssloop+0x2c>
                sub     r0, r0, r1
  200120:	e0400001 	sub	r0, r0, r1
                /* System */
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  200124:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                mov     sp, r0
  200128:	e1a0d000 	mov	sp, r0
//                sub     r0, r0, r1
                /*
                 * Early initialization.
                 */
#if !defined(THUMB_NO_INTERWORKING)
                bl      __early_init
  20012c:	eb0005cf 	bl	201870 <__early_init>

                /*
                 * Data initialization.
                 * NOTE: It assumes that the DATA size is a multiple of 4.
                 */
                ldr     r1, =_textdata
  200130:	e59f1050 	ldr	r1, [pc, #80]	; 200188 <bssloop+0x30>
                ldr     r2, =_data
  200134:	e59f2050 	ldr	r2, [pc, #80]	; 20018c <bssloop+0x34>
                ldr     r3, =_edata
  200138:	e59f3050 	ldr	r3, [pc, #80]	; 200190 <bssloop+0x38>

0020013c <dataloop>:
dataloop:
                cmp     r2, r3
  20013c:	e1520003 	cmp	r2, r3
                ldrlo   r0, [r1], #4
  200140:	34910004 	ldrcc	r0, [r1], #4
                strlo   r0, [r2], #4
  200144:	34820004 	strcc	r0, [r2], #4
                blo     dataloop
  200148:	3afffffb 	bcc	20013c <dataloop>
                /*
                 * BSS initialization.
                 * NOTE: It assumes that the BSS size is a multiple of 4.
                 */
                mov     r0, #0
  20014c:	e3a00000 	mov	r0, #0
                ldr     r1, =_bss_start
  200150:	e59f103c 	ldr	r1, [pc, #60]	; 200194 <bssloop+0x3c>
                ldr     r2, =_bss_end
  200154:	e59f203c 	ldr	r2, [pc, #60]	; 200198 <bssloop+0x40>

00200158 <bssloop>:
bssloop:
                cmp     r1, r2
  200158:	e1510002 	cmp	r1, r2
                strlo   r0, [r1], #4
  20015c:	34810004 	strcc	r0, [r1], #4
                blo     bssloop
  200160:	3afffffc 	bcc	200158 <bssloop>
                /*
                 * Late initialization.
                 */
#if !defined(THUMB_NO_INTERWORKING)
                bl      __late_init
  200164:	eb000fd5 	bl	2040c0 <__late_init>
                bl      main
                ldr     r1, =__default_exit
                bx      r1
                .code   32
#else /* !defined(THUMB_NO_INTERWORKING) */
                bl      main
  200168:	eb00074c 	bl	201ea0 <main>
                b       __default_exit
  20016c:	ea000fd7 	b	2040d0 <__default_exit>
                .global Reset_Handler
Reset_Handler:
                /*
                 * Stack pointers initialization.
                 */
                ldr     r0, =__stacks_end__
  200170:	00210858 	.word	0x00210858
                /* Undefined */
                msr     CPSR_c, #MODE_UND | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__und_stack_size__
  200174:	00000008 	.word	0x00000008
                sub     r0, r0, r1
                /* Abort */
                msr     CPSR_c, #MODE_ABT | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__abt_stack_size__
  200178:	00000008 	.word	0x00000008
                sub     r0, r0, r1
                /* FIQ */
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__fiq_stack_size__
  20017c:	00000040 	.word	0x00000040
                sub     r0, r0, r1
                /* IRQ */
                msr     CPSR_c, #MODE_IRQ | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__irq_stack_size__
  200180:	00000400 	.word	0x00000400
                sub     r0, r0, r1
                /* Supervisor */
                msr     CPSR_c, #MODE_SVC | I_BIT | F_BIT
                mov     sp, r0
                ldr     r1, =__svc_stack_size__
  200184:	00000008 	.word	0x00000008

                /*
                 * Data initialization.
                 * NOTE: It assumes that the DATA size is a multiple of 4.
                 */
                ldr     r1, =_textdata
  200188:	002052c8 	.word	0x002052c8
                ldr     r2, =_data
  20018c:	00210858 	.word	0x00210858
                ldr     r3, =_edata
  200190:	00210880 	.word	0x00210880
                /*
                 * BSS initialization.
                 * NOTE: It assumes that the BSS size is a multiple of 4.
                 */
                mov     r0, #0
                ldr     r1, =_bss_start
  200194:	00210880 	.word	0x00210880
                ldr     r2, =_bss_end
  200198:	00210cec 	.word	0x00210cec
  20019c:	00000000 	.word	0x00000000

002001a0 <_port_switch_arm>:
                .balign 16

                .code   32
                .global _port_switch_arm
_port_switch_arm:
                stmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  2001a0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
                str     sp, [r1, #12]
  2001a4:	e581d00c 	str	sp, [r1, #12]
                ldr     sp, [r0, #12]
  2001a8:	e590d00c 	ldr	sp, [r0, #12]
                ldmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  2001ac:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

002001b0 <Mon_Irq_Handler>:
                // secure context. The non secure IRQ handler has
                // the responsibility to return into secure state via a smc.
                //
                // The thread is interrupted in the same way that local FIQ.
                // The frame is created in the system stack of the current thread
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2001b0:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0-r3, r12, lr}
  2001b4:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  2001b8:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                mrs     r0, SPSR
  2001bc:	e14f0000 	mrs	r0, SPSR
                mov     r1, lr
  2001c0:	e1a0100e 	mov	r1, lr
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2001c4:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
  2001c8:	e92d0003 	push	{r0, r1}

                /* Save the s_ctx e recover the ns_ctx */

                // Re-establish the original conditions
                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
  2001cc:	e8bd0003 	pop	{r0, r1}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  2001d0:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                msr     SPSR_fsxc, r0
  2001d4:	e16ff000 	msr	SPSR_fsxc, r0
                mov     lr, r1
  2001d8:	e1a0e001 	mov	lr, r1
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2001dc:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                ldmfd   sp!, {r0-r3, r12, lr}
  2001e0:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  2001e4:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                stmfd   sp!, {lr}               // save lr into monitor stack
  2001e8:	e92d4000 	stmfd	sp!, {lr}
                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
  2001ec:	e3a0e005 	mov	lr, #5
                mrc     p15, 0, lr, c1, c1, 0
  2001f0:	ee11ef11 	mrc	15, 0, lr, cr1, cr1, {0}
                ldmfd   sp!, {lr}
  2001f4:	e8bd4000 	ldmfd	sp!, {lr}
                subs    pc, lr, #4              // return into non-secure world
  2001f8:	e25ef004 	subs	pc, lr, #4

002001fc <Mon_Fiq_Handler>:
                // Here the fiq is taken from non-secure state, via the FIQ vector
                // that is in the mon vector table.
                // Current mode is monitor (so current state is secure).
                // Note also that we never leave secure state while sec FIQ was disabled,
                // then it's always safe to process the FIQ here.
                stmfd   sp!, {lr}               // save lr into monitor stack
  2001fc:	e92d4000 	stmfd	sp!, {lr}
                ldr     lr, =MON_S_SCR          // set secure SCR before to switch to FIQ mode
  200200:	e3a0e002 	mov	lr, #2
                mrc     p15, 0, lr, c1, c1, 0
  200204:	ee11ef11 	mrc	15, 0, lr, cr1, cr1, {0}
                cpsid   if, #MODE_FIQ           // secure FIQ mode
  200208:	f10e00d1 	cpsid	if,#17
                stmfd   sp!, {r0-r3, r12}       // IRQ frame, save scratch registers
  20020c:	e92d100f 	push	{r0, r1, r2, r3, ip}
                ldr     r0, =ARM_IRQ_VECTOR_REG
  200210:	e59f0104 	ldr	r0, [pc, #260]	; 20031c <_zombies+0x4>
                ldr     r0, [r0]
  200214:	e5900000 	ldr	r0, [r0]
                ldr     lr, =_mon_fiq_ret_arm   // ISR return point.
  200218:	e59fe100 	ldr	lr, [pc, #256]	; 200320 <_zombies+0x8>
                bx      r0                      // Calling the ISR.
  20021c:	e12fff10 	bx	r0

00200220 <_mon_fiq_ret_arm>:
_mon_fiq_ret_arm:
                cmp     r0, #0
  200220:	e3500000 	cmp	r0, #0
                ldmfd   sp!, {r0-r3, r12}
  200224:	e8bd100f 	pop	{r0, r1, r2, r3, ip}
                cpsid   if, #MODE_MON
  200228:	f10e00d6 	cpsid	if,#22
                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
  20022c:	e3a0e005 	mov	lr, #5
                mrceq   p15, 0, lr, c1, c1, 0   // only if it will return
  200230:	0e11ef11 	mrceq	15, 0, lr, cr1, cr1, {0}
                ldmfd   sp!, {lr}
  200234:	e8bd4000 	ldmfd	sp!, {lr}
                subeqs  pc, lr, #4              // No reschedule, returns.
  200238:	025ef004 	subseq	pc, lr, #4

                // Now the frame is created in the system stack
                // relative to non secure context,
                // the IRQ and monitor stacks are empty,
                // the state is secure.
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  20023c:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0-r3, r12, lr}
  200240:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                mov		r0, sp
  200244:	e1a0000d 	mov	r0, sp
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  200248:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                stmfd	sp!, {r0}				// address of ns_ctx in mon stack
  20024c:	e92d0001 	stmfd	sp!, {r0}
                mrs     r0, SPSR
  200250:	e14f0000 	mrs	r0, SPSR
                mov     r1, lr
  200254:	e1a0100e 	mov	r1, lr
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  200258:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
  20025c:	e92d0003 	push	{r0, r1}
                mov		r0, sp
  200260:	e1a0000d 	mov	r0, sp

                // Context switch.
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
  200264:	eb00120d 	bl	204aa0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
#endif

                // Re-establish the IRQ conditions again.
                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
  200268:	e8bd0003 	pop	{r0, r1}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  20026c:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                msr     SPSR_fsxc, r0
  200270:	e16ff000 	msr	SPSR_fsxc, r0
                mov     lr, r1
  200274:	e1a0e001 	mov	lr, r1
                ldmfd	sp!, {r0}				// ns_ctx no longer exists, cleanup mon stack
  200278:	e8bd0001 	ldmfd	sp!, {r0}
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  20027c:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                ldmfd   sp!, {r0-r3, r12, lr}
  200280:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
  200284:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
                stmfd   sp!, {lr}               // save lr into mon stack
  200288:	e92d4000 	stmfd	sp!, {lr}
                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
  20028c:	e3a0e005 	mov	lr, #5
                mrc     p15, 0, lr, c1, c1, 0
  200290:	ee11ef11 	mrc	15, 0, lr, cr1, cr1, {0}
                ldmfd   sp!, {lr}
  200294:	e8bd4000 	ldmfd	sp!, {lr}
                subs    pc, lr, #4              // return into non-secure world
  200298:	e25ef004 	subs	pc, lr, #4

0020029c <Fiq_Handler>:
 *
 */
Fiq_Handler:
                // the fiq is taken locally from secure state
                // current mode is fiq
                stmfd   sp!, {r0-r3, r12, lr}   // save scratch registers and lr
  20029c:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                ldr     r0, =ARM_IRQ_VECTOR_REG
  2002a0:	e59f0074 	ldr	r0, [pc, #116]	; 20031c <_zombies+0x4>
                ldr     r0, [r0]
  2002a4:	e5900000 	ldr	r0, [r0]
                ldr     lr, =_fiq_ret_arm       // ISR return point.
  2002a8:	e59fe074 	ldr	lr, [pc, #116]	; 200324 <_zombies+0xc>
                bx      r0                      // Calling the ISR.
  2002ac:	e12fff10 	bx	r0

002002b0 <_fiq_ret_arm>:
_fiq_ret_arm:
                cmp     r0, #0
  2002b0:	e3500000 	cmp	r0, #0
                ldmfd   sp!, {r0-r3, r12, lr}
  2002b4:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                subeqs  pc, lr, #4              // No reschedule, returns.
  2002b8:	025ef004 	subseq	pc, lr, #4

                // Now the frame is created in the system stack of the current
                // thread, the IRQ stack is empty.
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2002bc:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0-r3, r12, lr}
  2002c0:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2002c4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                mrs     r0, SPSR
  2002c8:	e14f0000 	mrs	r0, SPSR
                mov     r1, lr
  2002cc:	e1a0100e 	mov	r1, lr
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2002d0:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
  2002d4:	e92d0003 	push	{r0, r1}

                // Context switch.
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
  2002d8:	eb0011f0 	bl	204aa0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
#endif

                // Re-establish the IRQ conditions again.
                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
  2002dc:	e8bd0003 	pop	{r0, r1}
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2002e0:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                msr     SPSR_fsxc, r0
  2002e4:	e16ff000 	msr	SPSR_fsxc, r0
                mov     lr, r1
  2002e8:	e1a0e001 	mov	lr, r1
                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
  2002ec:	e321f0df 	msr	CPSR_c, #223	; 0xdf
                ldmfd   sp!, {r0-r3, r12, lr}
  2002f0:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
  2002f4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                subs    pc, lr, #4
  2002f8:	e25ef004 	subs	pc, lr, #4
  2002fc:	e320f000 	nop	{0}

00200300 <_port_thread_start>:
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
#endif
				msr     CPSR_c, #MODE_SYS | I_BIT
  200300:	e321f09f 	msr	CPSR_c, #159	; 0x9f
                mov     r0, r5
  200304:	e1a00005 	mov	r0, r5
                mov     lr, pc
  200308:	e1a0e00f 	mov	lr, pc
                bx      r4
  20030c:	e12fff14 	bx	r4
#if defined(_CHIBIOS_RT_CONF_)
                mov     r0, #0              /* MSG_OK */
  200310:	e3a00000 	mov	r0, #0
                bl      chThdExit
  200314:	eb001309 	bl	204f40 <chThdExit>

00200318 <_zombies>:
_zombies:       b       _zombies
  200318:	eafffffe 	b	200318 <_zombies>
                stmfd   sp!, {lr}               // save lr into monitor stack
                ldr     lr, =MON_S_SCR          // set secure SCR before to switch to FIQ mode
                mrc     p15, 0, lr, c1, c1, 0
                cpsid   if, #MODE_FIQ           // secure FIQ mode
                stmfd   sp!, {r0-r3, r12}       // IRQ frame, save scratch registers
                ldr     r0, =ARM_IRQ_VECTOR_REG
  20031c:	f803c010 	.word	0xf803c010
                ldr     r0, [r0]
                ldr     lr, =_mon_fiq_ret_arm   // ISR return point.
  200320:	00200220 	.word	0x00200220
                // the fiq is taken locally from secure state
                // current mode is fiq
                stmfd   sp!, {r0-r3, r12, lr}   // save scratch registers and lr
                ldr     r0, =ARM_IRQ_VECTOR_REG
                ldr     r0, [r0]
                ldr     lr, =_fiq_ret_arm       // ISR return point.
  200324:	002002b0 	.word	0x002002b0
	...

00200330 <__aeabi_uidiv>:
  200330:	e2512001 	subs	r2, r1, #1
  200334:	012fff1e 	bxeq	lr
  200338:	3a000074 	bcc	200510 <__aeabi_uidiv+0x1e0>
  20033c:	e1500001 	cmp	r0, r1
  200340:	9a00006b 	bls	2004f4 <__aeabi_uidiv+0x1c4>
  200344:	e1110002 	tst	r1, r2
  200348:	0a00006c 	beq	200500 <__aeabi_uidiv+0x1d0>
  20034c:	e16f3f10 	clz	r3, r0
  200350:	e16f2f11 	clz	r2, r1
  200354:	e0423003 	sub	r3, r2, r3
  200358:	e273301f 	rsbs	r3, r3, #31
  20035c:	10833083 	addne	r3, r3, r3, lsl #1
  200360:	e3a02000 	mov	r2, #0
  200364:	108ff103 	addne	pc, pc, r3, lsl #2
  200368:	e320f000 	nop	{0}
  20036c:	e1500f81 	cmp	r0, r1, lsl #31
  200370:	e0a22002 	adc	r2, r2, r2
  200374:	20400f81 	subcs	r0, r0, r1, lsl #31
  200378:	e1500f01 	cmp	r0, r1, lsl #30
  20037c:	e0a22002 	adc	r2, r2, r2
  200380:	20400f01 	subcs	r0, r0, r1, lsl #30
  200384:	e1500e81 	cmp	r0, r1, lsl #29
  200388:	e0a22002 	adc	r2, r2, r2
  20038c:	20400e81 	subcs	r0, r0, r1, lsl #29
  200390:	e1500e01 	cmp	r0, r1, lsl #28
  200394:	e0a22002 	adc	r2, r2, r2
  200398:	20400e01 	subcs	r0, r0, r1, lsl #28
  20039c:	e1500d81 	cmp	r0, r1, lsl #27
  2003a0:	e0a22002 	adc	r2, r2, r2
  2003a4:	20400d81 	subcs	r0, r0, r1, lsl #27
  2003a8:	e1500d01 	cmp	r0, r1, lsl #26
  2003ac:	e0a22002 	adc	r2, r2, r2
  2003b0:	20400d01 	subcs	r0, r0, r1, lsl #26
  2003b4:	e1500c81 	cmp	r0, r1, lsl #25
  2003b8:	e0a22002 	adc	r2, r2, r2
  2003bc:	20400c81 	subcs	r0, r0, r1, lsl #25
  2003c0:	e1500c01 	cmp	r0, r1, lsl #24
  2003c4:	e0a22002 	adc	r2, r2, r2
  2003c8:	20400c01 	subcs	r0, r0, r1, lsl #24
  2003cc:	e1500b81 	cmp	r0, r1, lsl #23
  2003d0:	e0a22002 	adc	r2, r2, r2
  2003d4:	20400b81 	subcs	r0, r0, r1, lsl #23
  2003d8:	e1500b01 	cmp	r0, r1, lsl #22
  2003dc:	e0a22002 	adc	r2, r2, r2
  2003e0:	20400b01 	subcs	r0, r0, r1, lsl #22
  2003e4:	e1500a81 	cmp	r0, r1, lsl #21
  2003e8:	e0a22002 	adc	r2, r2, r2
  2003ec:	20400a81 	subcs	r0, r0, r1, lsl #21
  2003f0:	e1500a01 	cmp	r0, r1, lsl #20
  2003f4:	e0a22002 	adc	r2, r2, r2
  2003f8:	20400a01 	subcs	r0, r0, r1, lsl #20
  2003fc:	e1500981 	cmp	r0, r1, lsl #19
  200400:	e0a22002 	adc	r2, r2, r2
  200404:	20400981 	subcs	r0, r0, r1, lsl #19
  200408:	e1500901 	cmp	r0, r1, lsl #18
  20040c:	e0a22002 	adc	r2, r2, r2
  200410:	20400901 	subcs	r0, r0, r1, lsl #18
  200414:	e1500881 	cmp	r0, r1, lsl #17
  200418:	e0a22002 	adc	r2, r2, r2
  20041c:	20400881 	subcs	r0, r0, r1, lsl #17
  200420:	e1500801 	cmp	r0, r1, lsl #16
  200424:	e0a22002 	adc	r2, r2, r2
  200428:	20400801 	subcs	r0, r0, r1, lsl #16
  20042c:	e1500781 	cmp	r0, r1, lsl #15
  200430:	e0a22002 	adc	r2, r2, r2
  200434:	20400781 	subcs	r0, r0, r1, lsl #15
  200438:	e1500701 	cmp	r0, r1, lsl #14
  20043c:	e0a22002 	adc	r2, r2, r2
  200440:	20400701 	subcs	r0, r0, r1, lsl #14
  200444:	e1500681 	cmp	r0, r1, lsl #13
  200448:	e0a22002 	adc	r2, r2, r2
  20044c:	20400681 	subcs	r0, r0, r1, lsl #13
  200450:	e1500601 	cmp	r0, r1, lsl #12
  200454:	e0a22002 	adc	r2, r2, r2
  200458:	20400601 	subcs	r0, r0, r1, lsl #12
  20045c:	e1500581 	cmp	r0, r1, lsl #11
  200460:	e0a22002 	adc	r2, r2, r2
  200464:	20400581 	subcs	r0, r0, r1, lsl #11
  200468:	e1500501 	cmp	r0, r1, lsl #10
  20046c:	e0a22002 	adc	r2, r2, r2
  200470:	20400501 	subcs	r0, r0, r1, lsl #10
  200474:	e1500481 	cmp	r0, r1, lsl #9
  200478:	e0a22002 	adc	r2, r2, r2
  20047c:	20400481 	subcs	r0, r0, r1, lsl #9
  200480:	e1500401 	cmp	r0, r1, lsl #8
  200484:	e0a22002 	adc	r2, r2, r2
  200488:	20400401 	subcs	r0, r0, r1, lsl #8
  20048c:	e1500381 	cmp	r0, r1, lsl #7
  200490:	e0a22002 	adc	r2, r2, r2
  200494:	20400381 	subcs	r0, r0, r1, lsl #7
  200498:	e1500301 	cmp	r0, r1, lsl #6
  20049c:	e0a22002 	adc	r2, r2, r2
  2004a0:	20400301 	subcs	r0, r0, r1, lsl #6
  2004a4:	e1500281 	cmp	r0, r1, lsl #5
  2004a8:	e0a22002 	adc	r2, r2, r2
  2004ac:	20400281 	subcs	r0, r0, r1, lsl #5
  2004b0:	e1500201 	cmp	r0, r1, lsl #4
  2004b4:	e0a22002 	adc	r2, r2, r2
  2004b8:	20400201 	subcs	r0, r0, r1, lsl #4
  2004bc:	e1500181 	cmp	r0, r1, lsl #3
  2004c0:	e0a22002 	adc	r2, r2, r2
  2004c4:	20400181 	subcs	r0, r0, r1, lsl #3
  2004c8:	e1500101 	cmp	r0, r1, lsl #2
  2004cc:	e0a22002 	adc	r2, r2, r2
  2004d0:	20400101 	subcs	r0, r0, r1, lsl #2
  2004d4:	e1500081 	cmp	r0, r1, lsl #1
  2004d8:	e0a22002 	adc	r2, r2, r2
  2004dc:	20400081 	subcs	r0, r0, r1, lsl #1
  2004e0:	e1500001 	cmp	r0, r1
  2004e4:	e0a22002 	adc	r2, r2, r2
  2004e8:	20400001 	subcs	r0, r0, r1
  2004ec:	e1a00002 	mov	r0, r2
  2004f0:	e12fff1e 	bx	lr
  2004f4:	03a00001 	moveq	r0, #1
  2004f8:	13a00000 	movne	r0, #0
  2004fc:	e12fff1e 	bx	lr
  200500:	e16f2f11 	clz	r2, r1
  200504:	e262201f 	rsb	r2, r2, #31
  200508:	e1a00230 	lsr	r0, r0, r2
  20050c:	e12fff1e 	bx	lr
  200510:	e3500000 	cmp	r0, #0
  200514:	13e00000 	mvnne	r0, #0
  200518:	ea000008 	b	200540 <__aeabi_idiv0>

0020051c <__aeabi_uidivmod>:
  20051c:	e3510000 	cmp	r1, #0
  200520:	0afffffa 	beq	200510 <__aeabi_uidiv+0x1e0>
  200524:	e92d4003 	push	{r0, r1, lr}
  200528:	ebffff80 	bl	200330 <__aeabi_uidiv>
  20052c:	e8bd4006 	pop	{r1, r2, lr}
  200530:	e0030092 	mul	r3, r2, r0
  200534:	e0411003 	sub	r1, r1, r3
  200538:	e12fff1e 	bx	lr
  20053c:	00000000 	andeq	r0, r0, r0

00200540 <__aeabi_idiv0>:
  200540:	e12fff1e 	bx	lr
	...

00200550 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  200550:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200554:	e24dd014 	sub	sp, sp, #20
  200558:	e58d0004 	str	r0, [sp, #4]
  20055c:	e58d1000 	str	r1, [sp]
  eventflags_t sts = 0;
  200560:	e3a03000 	mov	r3, #0
  200564:	e58d300c 	str	r3, [sp, #12]

  if (isr & (UART_SR_OVRE | US_CSR_OVRE))
  200568:	e59d3000 	ldr	r3, [sp]
  20056c:	e2033020 	and	r3, r3, #32
  200570:	e3530000 	cmp	r3, #0
  200574:	0a000002 	beq	200584 <set_error+0x34>
    sts |= SD_OVERRUN_ERROR;
  200578:	e59d300c 	ldr	r3, [sp, #12]
  20057c:	e3833080 	orr	r3, r3, #128	; 0x80
  200580:	e58d300c 	str	r3, [sp, #12]
  if (isr & (UART_SR_PARE | US_CSR_PARE))
  200584:	e59d3000 	ldr	r3, [sp]
  200588:	e2033080 	and	r3, r3, #128	; 0x80
  20058c:	e3530000 	cmp	r3, #0
  200590:	0a000002 	beq	2005a0 <set_error+0x50>
    sts |= SD_PARITY_ERROR;
  200594:	e59d300c 	ldr	r3, [sp, #12]
  200598:	e3833020 	orr	r3, r3, #32
  20059c:	e58d300c 	str	r3, [sp, #12]
  if (isr & (UART_SR_FRAME | US_CSR_FRAME))
  2005a0:	e59d3000 	ldr	r3, [sp]
  2005a4:	e2033040 	and	r3, r3, #64	; 0x40
  2005a8:	e3530000 	cmp	r3, #0
  2005ac:	0a000002 	beq	2005bc <set_error+0x6c>
    sts |= UART_SR_FRAME;
  2005b0:	e59d300c 	ldr	r3, [sp, #12]
  2005b4:	e3833040 	orr	r3, r3, #64	; 0x40
  2005b8:	e58d300c 	str	r3, [sp, #12]
  osalSysLockFromISR();
  2005bc:	eb000d0f 	bl	203a00 <osalSysLockFromISR.lto_priv.14>
  chnAddFlagsI(sdp, sts);
  2005c0:	e59d3004 	ldr	r3, [sp, #4]
  2005c4:	e2833004 	add	r3, r3, #4
  2005c8:	e59d100c 	ldr	r1, [sp, #12]
  2005cc:	e1a00003 	mov	r0, r3
  2005d0:	eb000d12 	bl	203a20 <osalEventBroadcastFlagsI.lto_priv.13>
  osalSysUnlockFromISR();
  2005d4:	eb000d0d 	bl	203a10 <osalSysUnlockFromISR.lto_priv.12>
}
  2005d8:	e28dd014 	add	sp, sp, #20
  2005dc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

002005e0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the UART
 */
static void serve_interrupt(SerialDriver *sdp) {
  2005e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2005e4:	e24dd01c 	sub	sp, sp, #28
  2005e8:	e58d0004 	str	r0, [sp, #4]
  Uart *u = sdp->uart;
  2005ec:	e59d3004 	ldr	r3, [sp, #4]
  2005f0:	e5933054 	ldr	r3, [r3, #84]	; 0x54
  2005f4:	e58d3014 	str	r3, [sp, #20]
  uint32_t imr = u->UART_IMR;
  2005f8:	e59d3014 	ldr	r3, [sp, #20]
  2005fc:	e5933010 	ldr	r3, [r3, #16]
  200600:	e58d3010 	str	r3, [sp, #16]
  uint32_t sr;

  /* Reading and clearing status.*/
  sr = u->UART_SR;
  200604:	e59d3014 	ldr	r3, [sp, #20]
  200608:	e5933014 	ldr	r3, [r3, #20]
  20060c:	e58d300c 	str	r3, [sp, #12]
  u->UART_CR |= UART_CR_RSTSTA;
  200610:	e59d3014 	ldr	r3, [sp, #20]
  200614:	e5933000 	ldr	r3, [r3]
  200618:	e3832c01 	orr	r2, r3, #256	; 0x100
  20061c:	e59d3014 	ldr	r3, [sp, #20]
  200620:	e5832000 	str	r2, [r3]

  /* Error condition detection.*/
  if (sr & (UART_SR_OVRE | UART_SR_FRAME  | UART_SR_PARE)){
  200624:	e59d300c 	ldr	r3, [sp, #12]
  200628:	e20330e0 	and	r3, r3, #224	; 0xe0
  20062c:	e3530000 	cmp	r3, #0
  200630:	0a000002 	beq	200640 <serve_interrupt+0x60>
    set_error(sdp, sr);
  200634:	e59d100c 	ldr	r1, [sp, #12]
  200638:	e59d0004 	ldr	r0, [sp, #4]
  20063c:	ebffffc3 	bl	200550 <set_error>
  }

  /* Data available.*/
  if (sr & UART_SR_RXRDY) {
  200640:	e59d300c 	ldr	r3, [sp, #12]
  200644:	e2033001 	and	r3, r3, #1
  200648:	e3530000 	cmp	r3, #0
  20064c:	0a000007 	beq	200670 <serve_interrupt+0x90>
    osalSysLockFromISR();
  200650:	eb000cea 	bl	203a00 <osalSysLockFromISR.lto_priv.14>
    sdIncomingDataI(sdp, (uint8_t)u->UART_RHR);
  200654:	e59d3014 	ldr	r3, [sp, #20]
  200658:	e5933018 	ldr	r3, [r3, #24]
  20065c:	e6ef3073 	uxtb	r3, r3
  200660:	e1a01003 	mov	r1, r3
  200664:	e59d0004 	ldr	r0, [sp, #4]
  200668:	eb0008c4 	bl	202980 <sdIncomingDataI>
    osalSysUnlockFromISR();
  20066c:	eb000ce7 	bl	203a10 <osalSysUnlockFromISR.lto_priv.12>
  }

  /* Transmission buffer empty.*/
  if ((imr & UART_IMR_TXRDY) && (sr & UART_SR_TXRDY)) {
  200670:	e59d3010 	ldr	r3, [sp, #16]
  200674:	e2033002 	and	r3, r3, #2
  200678:	e3530000 	cmp	r3, #0
  20067c:	0a00001e 	beq	2006fc <serve_interrupt+0x11c>
  200680:	e59d300c 	ldr	r3, [sp, #12]
  200684:	e2033002 	and	r3, r3, #2
  200688:	e3530000 	cmp	r3, #0
  20068c:	0a00001a 	beq	2006fc <serve_interrupt+0x11c>
    msg_t b;
    osalSysLockFromISR();
  200690:	eb000cda 	bl	203a00 <osalSysLockFromISR.lto_priv.14>
    b = oqGetI(&sdp->oqueue);
  200694:	e59d3004 	ldr	r3, [sp, #4]
  200698:	e2833030 	add	r3, r3, #48	; 0x30
  20069c:	e1a00003 	mov	r0, r3
  2006a0:	eb000736 	bl	202380 <oqGetI>
  2006a4:	e58d0008 	str	r0, [sp, #8]
    if (b < MSG_OK) {
  2006a8:	e59d3008 	ldr	r3, [sp, #8]
  2006ac:	e3530000 	cmp	r3, #0
  2006b0:	aa00000d 	bge	2006ec <serve_interrupt+0x10c>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  2006b4:	e59d3004 	ldr	r3, [sp, #4]
  2006b8:	e2833004 	add	r3, r3, #4
  2006bc:	e3a01008 	mov	r1, #8
  2006c0:	e1a00003 	mov	r0, r3
  2006c4:	eb000cd5 	bl	203a20 <osalEventBroadcastFlagsI.lto_priv.13>
      u->UART_IDR |= UART_IDR_TXRDY;
  2006c8:	e59d3014 	ldr	r3, [sp, #20]
  2006cc:	e593300c 	ldr	r3, [r3, #12]
  2006d0:	e3832002 	orr	r2, r3, #2
  2006d4:	e59d3014 	ldr	r3, [sp, #20]
  2006d8:	e583200c 	str	r2, [r3, #12]
      u->UART_IER = UART_IER_TXEMPTY;
  2006dc:	e59d3014 	ldr	r3, [sp, #20]
  2006e0:	e3a02c02 	mov	r2, #512	; 0x200
  2006e4:	e5832008 	str	r2, [r3, #8]
  2006e8:	ea000002 	b	2006f8 <serve_interrupt+0x118>
    }
    else
      u->UART_THR = b;
  2006ec:	e59d2008 	ldr	r2, [sp, #8]
  2006f0:	e59d3014 	ldr	r3, [sp, #20]
  2006f4:	e583201c 	str	r2, [r3, #28]
    osalSysUnlockFromISR();
  2006f8:	eb000cc4 	bl	203a10 <osalSysUnlockFromISR.lto_priv.12>
  }

  /* Physical transmission end.*/
  if ((imr & UART_IMR_TXEMPTY) && (sr & (UART_SR_TXRDY | UART_SR_TXEMPTY))) {
  2006fc:	e59d3010 	ldr	r3, [sp, #16]
  200700:	e2033c02 	and	r3, r3, #512	; 0x200
  200704:	e3530000 	cmp	r3, #0
  200708:	0a000021 	beq	200794 <serve_interrupt+0x1b4>
  20070c:	e59d200c 	ldr	r2, [sp, #12]
  200710:	e3003202 	movw	r3, #514	; 0x202
  200714:	e0033002 	and	r3, r3, r2
  200718:	e3530000 	cmp	r3, #0
  20071c:	0a00001c 	beq	200794 <serve_interrupt+0x1b4>
    osalSysLockFromISR();
  200720:	eb000cb6 	bl	203a00 <osalSysLockFromISR.lto_priv.14>
    if (oqIsEmptyI(&sdp->oqueue))
  200724:	e59d3004 	ldr	r3, [sp, #4]
  200728:	e5932044 	ldr	r2, [r3, #68]	; 0x44
  20072c:	e59d3004 	ldr	r3, [sp, #4]
  200730:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  200734:	e1520003 	cmp	r2, r3
  200738:	1a000005 	bne	200754 <serve_interrupt+0x174>
  20073c:	e59d3004 	ldr	r3, [sp, #4]
  200740:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  200744:	e3530000 	cmp	r3, #0
  200748:	0a000001 	beq	200754 <serve_interrupt+0x174>
  20074c:	e3a03001 	mov	r3, #1
  200750:	ea000000 	b	200758 <serve_interrupt+0x178>
  200754:	e3a03000 	mov	r3, #0
  200758:	e2033001 	and	r3, r3, #1
  20075c:	e3530000 	cmp	r3, #0
  200760:	0a000004 	beq	200778 <serve_interrupt+0x198>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
  200764:	e59d3004 	ldr	r3, [sp, #4]
  200768:	e2833004 	add	r3, r3, #4
  20076c:	e3a01010 	mov	r1, #16
  200770:	e1a00003 	mov	r0, r3
  200774:	eb000ca9 	bl	203a20 <osalEventBroadcastFlagsI.lto_priv.13>
    u->UART_IDR |= UART_IDR_TXRDY | UART_IDR_TXEMPTY;
  200778:	e59d3014 	ldr	r3, [sp, #20]
  20077c:	e593300c 	ldr	r3, [r3, #12]
  200780:	e3833c02 	orr	r3, r3, #512	; 0x200
  200784:	e3833002 	orr	r3, r3, #2
  200788:	e59d2014 	ldr	r2, [sp, #20]
  20078c:	e582300c 	str	r3, [r2, #12]
    osalSysUnlockFromISR();
  200790:	eb000c9e 	bl	203a10 <osalSysUnlockFromISR.lto_priv.12>
  }
}
  200794:	e28dd01c 	add	sp, sp, #28
  200798:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20079c:	00000000 	andeq	r0, r0, r0

002007a0 <notify0>:
  }
}
#endif

#if SAMA_SERIAL_USE_UART0 || defined(__DOXYGEN__)
static void notify0(io_queue_t *qp) {
  2007a0:	e24dd008 	sub	sp, sp, #8
  2007a4:	e58d0004 	str	r0, [sp, #4]

  (void)qp;
  UART0->UART_IER |= UART_IER_TXRDY;
  2007a8:	e3a03903 	mov	r3, #49152	; 0xc000
  2007ac:	e34f3801 	movt	r3, #63489	; 0xf801
  2007b0:	e3a02903 	mov	r2, #49152	; 0xc000
  2007b4:	e34f2801 	movt	r2, #63489	; 0xf801
  2007b8:	e5922008 	ldr	r2, [r2, #8]
  2007bc:	e3822002 	orr	r2, r2, #2
  2007c0:	e5832008 	str	r2, [r3, #8]
}
  2007c4:	e28dd008 	add	sp, sp, #8
  2007c8:	e12fff1e 	bx	lr
  2007cc:	00000000 	andeq	r0, r0, r0

002007d0 <SAMA_UART0_HANDLER>:
/**
 * @brief   UART0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SAMA_UART0_HANDLER) {
  2007d0:	e92d4010 	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD0);
  2007d4:	e3000bf0 	movw	r0, #3056	; 0xbf0
  2007d8:	e3400021 	movt	r0, #33	; 0x21
  2007dc:	ebffff7f 	bl	2005e0 <serve_interrupt>
  aicAckInt();
  2007e0:	e3a03903 	mov	r3, #49152	; 0xc000
  2007e4:	e34f3803 	movt	r3, #63491	; 0xf803
  2007e8:	e3a02001 	mov	r2, #1
  2007ec:	e5832038 	str	r2, [r3, #56]	; 0x38
  OSAL_IRQ_EPILOGUE();
  2007f0:	eb001096 	bl	204a50 <chSchIsPreemptionRequired>
  2007f4:	e1a03000 	mov	r3, r0
}
  2007f8:	e1a00003 	mov	r0, r3
  2007fc:	e8bd8010 	pop	{r4, pc}

00200800 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
  200800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200804:	e24dd00c 	sub	sp, sp, #12

#if SAMA_SERIAL_USE_UART0
  sdObjectInit(&SD0);
  200808:	e3000bf0 	movw	r0, #3056	; 0xbf0
  20080c:	e3400021 	movt	r0, #33	; 0x21
  200810:	eb00083a 	bl	202900 <sdObjectInit>
  iqObjectInit(&SD0.iqueue, sd_in_buf0, sizeof sd_in_buf0, NULL, &SD0);
  200814:	e3003bf0 	movw	r3, #3056	; 0xbf0
  200818:	e3403021 	movt	r3, #33	; 0x21
  20081c:	e58d3000 	str	r3, [sp]
  200820:	e3a03000 	mov	r3, #0
  200824:	e3a02010 	mov	r2, #16
  200828:	e3001c54 	movw	r1, #3156	; 0xc54
  20082c:	e3401021 	movt	r1, #33	; 0x21
  200830:	e3000bfc 	movw	r0, #3068	; 0xbfc
  200834:	e3400021 	movt	r0, #33	; 0x21
  200838:	eb000d24 	bl	203cd0 <iqObjectInit>
  oqObjectInit(&SD0.oqueue, sd_out_buf0, sizeof sd_out_buf0, notify0, &SD0);
  20083c:	e3003bf0 	movw	r3, #3056	; 0xbf0
  200840:	e3403021 	movt	r3, #33	; 0x21
  200844:	e58d3000 	str	r3, [sp]
  200848:	e30037a0 	movw	r3, #1952	; 0x7a0
  20084c:	e3403020 	movt	r3, #32
  200850:	e3a02010 	mov	r2, #16
  200854:	e3001c64 	movw	r1, #3172	; 0xc64
  200858:	e3401021 	movt	r1, #33	; 0x21
  20085c:	e3000c20 	movw	r0, #3104	; 0xc20
  200860:	e3400021 	movt	r0, #33	; 0x21
  200864:	eb000665 	bl	202200 <oqObjectInit>
  SD0.uart = UART0;
  200868:	e3002bf0 	movw	r2, #3056	; 0xbf0
  20086c:	e3402021 	movt	r2, #33	; 0x21
  200870:	e3a03903 	mov	r3, #49152	; 0xc000
  200874:	e34f3801 	movt	r3, #63489	; 0xf801
  200878:	e5823054 	str	r3, [r2, #84]	; 0x54
  SD0.clock = SAMA_UART0CLK;
  20087c:	e3002bf0 	movw	r2, #3056	; 0xbf0
  200880:	e3402021 	movt	r2, #33	; 0x21
  200884:	e3073ac0 	movw	r3, #31424	; 0x7ac0
  200888:	e34034f2 	movt	r3, #1266	; 0x4f2
  20088c:	e5823060 	str	r3, [r2, #96]	; 0x60

  aicSetSourcePriority(ID_UART0, SAMA_SERIAL_UART0_IRQ_PRIORITY);
  200890:	e3a01004 	mov	r1, #4
  200894:	e3a00018 	mov	r0, #24
  200898:	eb000a54 	bl	2031f0 <aicSetSourcePriority>
  aicSetSourceHandler(ID_UART0, SAMA_UART0_HANDLER);
  20089c:	e30017d0 	movw	r1, #2000	; 0x7d0
  2008a0:	e3401020 	movt	r1, #32
  2008a4:	e3a00018 	mov	r0, #24
  2008a8:	eb000a70 	bl	203270 <aicSetSourceHandler>
  aicEnableInt(ID_UART0);
  2008ac:	e3a00018 	mov	r0, #24
  2008b0:	eb000a86 	bl	2032d0 <aicEnableInt>

  aicSetSourcePriority(ID_USART4, SAMA_SERIAL_FLEXCOM4_IRQ_PRIORITY);
  aicSetSourceHandler(ID_USART4, SAMA_SERIAL_FLEXCOM4_HANDLER);
  aicEnableInt(ID_USART4);
#endif
}
  2008b4:	e28dd00c 	add	sp, sp, #12
  2008b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2008bc:	00000000 	andeq	r0, r0, r0

002008c0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
  2008c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2008c4:	e24dd00c 	sub	sp, sp, #12
  2008c8:	e58d0004 	str	r0, [sp, #4]
  2008cc:	e58d1000 	str	r1, [sp]

  if (config == NULL) {
  2008d0:	e59d3000 	ldr	r3, [sp]
  2008d4:	e3530000 	cmp	r3, #0
  2008d8:	1a000002 	bne	2008e8 <sd_lld_start+0x28>

    config = &default_config;
  2008dc:	e3053280 	movw	r3, #21120	; 0x5280
  2008e0:	e3403020 	movt	r3, #32
  2008e4:	e58d3000 	str	r3, [sp]
  }
  if (sdp->state == SD_STOP) {
  2008e8:	e59d3004 	ldr	r3, [sp, #4]
  2008ec:	e5d33008 	ldrb	r3, [r3, #8]
  2008f0:	e3530001 	cmp	r3, #1
  2008f4:	1a000015 	bne	200950 <sd_lld_start+0x90>
#if SAMA_SERIAL_USE_UART0
    if (&SD0 == sdp) {
  2008f8:	e59d2004 	ldr	r2, [sp, #4]
  2008fc:	e3003bf0 	movw	r3, #3056	; 0xbf0
  200900:	e3403021 	movt	r3, #33	; 0x21
  200904:	e1520003 	cmp	r2, r3
  200908:	1a000010 	bne	200950 <sd_lld_start+0x90>
      pmcEnableUART0();
  20090c:	e3a03901 	mov	r3, #16384	; 0x4000
  200910:	e34f3001 	movt	r3, #61441	; 0xf001
  200914:	e3a02c43 	mov	r2, #17152	; 0x4300
  200918:	e345204d 	movt	r2, #20557	; 0x504d
  20091c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  200920:	e3a03901 	mov	r3, #16384	; 0x4000
  200924:	e34f3001 	movt	r3, #61441	; 0xf001
  200928:	e3a02901 	mov	r2, #16384	; 0x4000
  20092c:	e34f2001 	movt	r2, #61441	; 0xf001
  200930:	e5922010 	ldr	r2, [r2, #16]
  200934:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
  200938:	e5832010 	str	r2, [r3, #16]
  20093c:	e3a03901 	mov	r3, #16384	; 0x4000
  200940:	e34f3001 	movt	r3, #61441	; 0xf001
  200944:	e3042301 	movw	r2, #17153	; 0x4301
  200948:	e345204d 	movt	r2, #20557	; 0x504d
  20094c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
    if (&FSD4 == sdp) {
      pmcEnableFLEXCOM4();
    }
#endif
  }
  uart_init(sdp, config);
  200950:	e59d1000 	ldr	r1, [sp]
  200954:	e59d0004 	ldr	r0, [sp, #4]
  200958:	eb000c3c 	bl	203a50 <uart_init.lto_priv.11>
}
  20095c:	e28dd00c 	add	sp, sp, #12
  200960:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00200970 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
  200970:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200974:	e24dd00c 	sub	sp, sp, #12
  200978:	e58d0004 	str	r0, [sp, #4]

  chSysHalt(reason);
  20097c:	e59d0004 	ldr	r0, [sp, #4]
  200980:	eb000e5e 	bl	204300 <chSysHalt>
}
  200984:	e28dd00c 	add	sp, sp, #12
  200988:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20098c:	00000000 	andeq	r0, r0, r0

00200990 <translate_errors>:
 *
 * @param[in] isr       UART ISR register value
 *
 * @return  The error flags.
 */
static uartflags_t translate_errors(uint32_t isr) {
  200990:	e24dd010 	sub	sp, sp, #16
  200994:	e58d0004 	str	r0, [sp, #4]
  uartflags_t sts = 0;
  200998:	e3a03000 	mov	r3, #0
  20099c:	e58d300c 	str	r3, [sp, #12]

  if (isr & (UART_SR_OVRE | US_CSR_OVRE))
  2009a0:	e59d3004 	ldr	r3, [sp, #4]
  2009a4:	e2033020 	and	r3, r3, #32
  2009a8:	e3530000 	cmp	r3, #0
  2009ac:	0a000002 	beq	2009bc <translate_errors+0x2c>
    sts |= UART_OVERRUN_ERROR;
  2009b0:	e59d300c 	ldr	r3, [sp, #12]
  2009b4:	e3833010 	orr	r3, r3, #16
  2009b8:	e58d300c 	str	r3, [sp, #12]
  if (isr & (UART_SR_PARE | US_CSR_PARE))
  2009bc:	e59d3004 	ldr	r3, [sp, #4]
  2009c0:	e2033080 	and	r3, r3, #128	; 0x80
  2009c4:	e3530000 	cmp	r3, #0
  2009c8:	0a000002 	beq	2009d8 <translate_errors+0x48>
    sts |= UART_PARITY_ERROR;
  2009cc:	e59d300c 	ldr	r3, [sp, #12]
  2009d0:	e3833004 	orr	r3, r3, #4
  2009d4:	e58d300c 	str	r3, [sp, #12]
  if (isr & (UART_SR_FRAME | US_CSR_FRAME))
  2009d8:	e59d3004 	ldr	r3, [sp, #4]
  2009dc:	e2033040 	and	r3, r3, #64	; 0x40
  2009e0:	e3530000 	cmp	r3, #0
  2009e4:	0a000002 	beq	2009f4 <translate_errors+0x64>
    sts |= UART_SR_FRAME;
  2009e8:	e59d300c 	ldr	r3, [sp, #12]
  2009ec:	e3833040 	orr	r3, r3, #64	; 0x40
  2009f0:	e58d300c 	str	r3, [sp, #12]
  return sts;
  2009f4:	e59d300c 	ldr	r3, [sp, #12]
}
  2009f8:	e1a00003 	mov	r0, r3
  2009fc:	e28dd010 	add	sp, sp, #16
  200a00:	e12fff1e 	bx	lr
	...

00200a10 <uart_enter_rx_idle_loop>:
/**
 * @brief   Puts the receiver in the UART_RX_IDLE state.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  200a10:	e24dd008 	sub	sp, sp, #8
  200a14:	e58d0004 	str	r0, [sp, #4]
  
  /* Disabling BIE interrupt if rx callback is null */
  if (uartp->config->rxchar_cb == NULL)
  200a18:	e59d3004 	ldr	r3, [sp, #4]
  200a1c:	e5933004 	ldr	r3, [r3, #4]
  200a20:	e593300c 	ldr	r3, [r3, #12]
  200a24:	e3530000 	cmp	r3, #0
  200a28:	1a000009 	bne	200a54 <uart_enter_rx_idle_loop+0x44>
    uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CID =  XDMAC_CID_BID;
  200a2c:	e59d3004 	ldr	r3, [sp, #4]
  200a30:	e593301c 	ldr	r3, [r3, #28]
  200a34:	e5932000 	ldr	r2, [r3]
  200a38:	e59d3004 	ldr	r3, [sp, #4]
  200a3c:	e593301c 	ldr	r3, [r3, #28]
  200a40:	e5d33004 	ldrb	r3, [r3, #4]
  200a44:	e1a03303 	lsl	r3, r3, #6
  200a48:	e0823003 	add	r3, r2, r3
  200a4c:	e3a02001 	mov	r2, #1
  200a50:	e5832054 	str	r2, [r3, #84]	; 0x54

  descriptor0.mbr_ubc = XDMA_UBC_NVIEW_NDV0 | XDMA_UBC_NDEN_UPDATED |
  200a54:	e3002c9c 	movw	r2, #3228	; 0xc9c
  200a58:	e3402021 	movt	r2, #33	; 0x21
  200a5c:	e3a03001 	mov	r3, #1
  200a60:	e3403500 	movt	r3, #1280	; 0x500
  200a64:	e5823004 	str	r3, [r2, #4]
                        XDMA_UBC_NDE_FETCH_EN | XDMA_UBC_UBLEN(1);
  descriptor0.mbr_nda = &descriptor0;
  200a68:	e3003c9c 	movw	r3, #3228	; 0xc9c
  200a6c:	e3403021 	movt	r3, #33	; 0x21
  200a70:	e3002c9c 	movw	r2, #3228	; 0xc9c
  200a74:	e3402021 	movt	r2, #33	; 0x21
  200a78:	e5832000 	str	r2, [r3]
  descriptor0.mbr_ta = (uint32_t*)&uartp->rxbuf;
  200a7c:	e59d3004 	ldr	r3, [sp, #4]
  200a80:	e2832024 	add	r2, r3, #36	; 0x24
  200a84:	e3003c9c 	movw	r3, #3228	; 0xc9c
  200a88:	e3403021 	movt	r3, #33	; 0x21
  200a8c:	e5832008 	str	r2, [r3, #8]

  /* Configure First Descriptor Address CNCDAx */
  uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CNDA =
  200a90:	e59d3004 	ldr	r3, [sp, #4]
  200a94:	e593301c 	ldr	r3, [r3, #28]
  200a98:	e5931000 	ldr	r1, [r3]
  200a9c:	e59d3004 	ldr	r3, [sp, #4]
  200aa0:	e593301c 	ldr	r3, [r3, #28]
  200aa4:	e5d33004 	ldrb	r3, [r3, #4]
  200aa8:	e1a00003 	mov	r0, r3
                                   (((uint32_t)&descriptor0) & 0xFFFFFFFC);
  200aac:	e3003c9c 	movw	r3, #3228	; 0xc9c
  200ab0:	e3403021 	movt	r3, #33	; 0x21
  200ab4:	e3c32003 	bic	r2, r3, #3
                        XDMA_UBC_NDE_FETCH_EN | XDMA_UBC_UBLEN(1);
  descriptor0.mbr_nda = &descriptor0;
  descriptor0.mbr_ta = (uint32_t*)&uartp->rxbuf;

  /* Configure First Descriptor Address CNCDAx */
  uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CNDA =
  200ab8:	e1a03300 	lsl	r3, r0, #6
  200abc:	e0813003 	add	r3, r1, r3
  200ac0:	e5832068 	str	r2, [r3, #104]	; 0x68
                                   (((uint32_t)&descriptor0) & 0xFFFFFFFC);
  /* Configure the XDMAC_CNDCx register */
  uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CNDC =
  200ac4:	e59d3004 	ldr	r3, [sp, #4]
  200ac8:	e593301c 	ldr	r3, [r3, #28]
  200acc:	e5932000 	ldr	r2, [r3]
  200ad0:	e59d3004 	ldr	r3, [sp, #4]
  200ad4:	e593301c 	ldr	r3, [r3, #28]
  200ad8:	e5d33004 	ldrb	r3, [r3, #4]
  200adc:	e1a03303 	lsl	r3, r3, #6
  200ae0:	e0823003 	add	r3, r2, r3
  200ae4:	e3a02005 	mov	r2, #5
  200ae8:	e583206c 	str	r2, [r3, #108]	; 0x6c
              XDMAC_CNDC_NDE_DSCR_FETCH_EN | XDMAC_CNDC_NDDUP_DST_PARAMS_UPDATED | XDMAC_CNDC_NDVIEW_NDV0;

  dmaChannelEnable(uartp->dmarx);
  200aec:	e59d3004 	ldr	r3, [sp, #4]
  200af0:	e593301c 	ldr	r3, [r3, #28]
  200af4:	e5933000 	ldr	r3, [r3]
  200af8:	e59d2004 	ldr	r2, [sp, #4]
  200afc:	e592201c 	ldr	r2, [r2, #28]
  200b00:	e5922000 	ldr	r2, [r2]
  200b04:	e592101c 	ldr	r1, [r2, #28]
  200b08:	e59d2004 	ldr	r2, [sp, #4]
  200b0c:	e592201c 	ldr	r2, [r2, #28]
  200b10:	e5d22004 	ldrb	r2, [r2, #4]
  200b14:	e1a00002 	mov	r0, r2
  200b18:	e3a02001 	mov	r2, #1
  200b1c:	e1a02012 	lsl	r2, r2, r0
  200b20:	e1812002 	orr	r2, r1, r2
  200b24:	e583201c 	str	r2, [r3, #28]
}
  200b28:	e28dd008 	add	sp, sp, #8
  200b2c:	e12fff1e 	bx	lr

00200b30 <uart_stop>:
 * @brief   UART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void uart_stop(UARTDriver *uartp) {
  200b30:	e24dd010 	sub	sp, sp, #16
  200b34:	e58d0004 	str	r0, [sp, #4]

  /* Stops RX and TX DMA channels.*/
  dmaChannelDisable(uartp->dmarx);
  200b38:	e59d3004 	ldr	r3, [sp, #4]
  200b3c:	e593301c 	ldr	r3, [r3, #28]
  200b40:	e5933000 	ldr	r3, [r3]
  200b44:	e59d2004 	ldr	r2, [sp, #4]
  200b48:	e592201c 	ldr	r2, [r2, #28]
  200b4c:	e5922000 	ldr	r2, [r2]
  200b50:	e5921020 	ldr	r1, [r2, #32]
  200b54:	e59d2004 	ldr	r2, [sp, #4]
  200b58:	e592201c 	ldr	r2, [r2, #28]
  200b5c:	e5d22004 	ldrb	r2, [r2, #4]
  200b60:	e1a00002 	mov	r0, r2
  200b64:	e3a02001 	mov	r2, #1
  200b68:	e1a02012 	lsl	r2, r2, r0
  200b6c:	e1812002 	orr	r2, r1, r2
  200b70:	e5832020 	str	r2, [r3, #32]
  200b74:	e59d3004 	ldr	r3, [sp, #4]
  200b78:	e593301c 	ldr	r3, [r3, #28]
  200b7c:	e5933000 	ldr	r3, [r3]
  200b80:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  200b84:	e59d3004 	ldr	r3, [sp, #4]
  200b88:	e593301c 	ldr	r3, [r3, #28]
  200b8c:	e5d33004 	ldrb	r3, [r3, #4]
  200b90:	e1a01003 	mov	r1, r3
  200b94:	e3a03001 	mov	r3, #1
  200b98:	e1a03113 	lsl	r3, r3, r1
  200b9c:	e0033002 	and	r3, r3, r2
  200ba0:	e3530001 	cmp	r3, #1
  200ba4:	0afffff2 	beq	200b74 <uart_stop+0x44>
  200ba8:	e59d3004 	ldr	r3, [sp, #4]
  200bac:	e593301c 	ldr	r3, [r3, #28]
  200bb0:	e5932000 	ldr	r2, [r3]
  200bb4:	e59d3004 	ldr	r3, [sp, #4]
  200bb8:	e593301c 	ldr	r3, [r3, #28]
  200bbc:	e5d33004 	ldrb	r3, [r3, #4]
  200bc0:	e1a03303 	lsl	r3, r3, #6
  200bc4:	e0823003 	add	r3, r2, r3
  200bc8:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
  dmaChannelDisable(uartp->dmatx);
  200bcc:	e59d3004 	ldr	r3, [sp, #4]
  200bd0:	e5933020 	ldr	r3, [r3, #32]
  200bd4:	e5933000 	ldr	r3, [r3]
  200bd8:	e59d2004 	ldr	r2, [sp, #4]
  200bdc:	e5922020 	ldr	r2, [r2, #32]
  200be0:	e5922000 	ldr	r2, [r2]
  200be4:	e5921020 	ldr	r1, [r2, #32]
  200be8:	e59d2004 	ldr	r2, [sp, #4]
  200bec:	e5922020 	ldr	r2, [r2, #32]
  200bf0:	e5d22004 	ldrb	r2, [r2, #4]
  200bf4:	e1a00002 	mov	r0, r2
  200bf8:	e3a02001 	mov	r2, #1
  200bfc:	e1a02012 	lsl	r2, r2, r0
  200c00:	e1812002 	orr	r2, r1, r2
  200c04:	e5832020 	str	r2, [r3, #32]
  200c08:	e59d3004 	ldr	r3, [sp, #4]
  200c0c:	e5933020 	ldr	r3, [r3, #32]
  200c10:	e5933000 	ldr	r3, [r3]
  200c14:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  200c18:	e59d3004 	ldr	r3, [sp, #4]
  200c1c:	e5933020 	ldr	r3, [r3, #32]
  200c20:	e5d33004 	ldrb	r3, [r3, #4]
  200c24:	e1a01003 	mov	r1, r3
  200c28:	e3a03001 	mov	r3, #1
  200c2c:	e1a03113 	lsl	r3, r3, r1
  200c30:	e0033002 	and	r3, r3, r2
  200c34:	e3530001 	cmp	r3, #1
  200c38:	0afffff2 	beq	200c08 <uart_stop+0xd8>
  200c3c:	e59d3004 	ldr	r3, [sp, #4]
  200c40:	e5933020 	ldr	r3, [r3, #32]
  200c44:	e5932000 	ldr	r2, [r3]
  200c48:	e59d3004 	ldr	r3, [sp, #4]
  200c4c:	e5933020 	ldr	r3, [r3, #32]
  200c50:	e5d33004 	ldrb	r3, [r3, #4]
  200c54:	e1a03303 	lsl	r3, r3, #6
  200c58:	e0823003 	add	r3, r2, r3
  200c5c:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
#if SAMA_UART_USE_UART && SAMA_UART_USE_FLEXCOM
  else if (uartp->usart != NULL)
#endif /* SAMA_UART_USE_UART && SAMA_UART_USE_FLEXCOM */
#if SAMA_UART_USE_FLEXCOM
  {
    Usart *us = uartp->usart;
  200c60:	e59d3004 	ldr	r3, [sp, #4]
  200c64:	e593300c 	ldr	r3, [r3, #12]
  200c68:	e58d300c 	str	r3, [sp, #12]

    /* Disabling write protection */
    uartFlexDisableWP(us);
  200c6c:	e59d200c 	ldr	r2, [sp, #12]
  200c70:	e3a03c41 	mov	r3, #16640	; 0x4100
  200c74:	e3453553 	movt	r3, #21843	; 0x5553
  200c78:	e58230e4 	str	r3, [r2, #228]	; 0xe4

    /* Stops UART operations.*/
    us->US_CR = US_CR_RSTRX | US_CR_RSTTX;
  200c7c:	e59d300c 	ldr	r3, [sp, #12]
  200c80:	e3a0200c 	mov	r2, #12
  200c84:	e5832000 	str	r2, [r3]

    /* Resets UART's register */
    us->US_MR = 0;
  200c88:	e59d300c 	ldr	r3, [sp, #12]
  200c8c:	e3a02000 	mov	r2, #0
  200c90:	e5832004 	str	r2, [r3, #4]

    /* Disabling write protection */
    uartFlexEnableWP(us);
  200c94:	e59d200c 	ldr	r2, [sp, #12]
  200c98:	e3043101 	movw	r3, #16641	; 0x4101
  200c9c:	e3453553 	movt	r3, #21843	; 0x5553
  200ca0:	e58230e4 	str	r3, [r2, #228]	; 0xe4
#if SAMA_UART_USE_UART && SAMA_UART_USE_FLEXCOM
  else {
    osalDbgAssert(FALSE, "invalid state");
  }
#endif /* SAMA_UART_USE_UART && SAMA_UART_USE_FLEXCOM */
}
  200ca4:	e28dd010 	add	sp, sp, #16
  200ca8:	e12fff1e 	bx	lr
  200cac:	00000000 	andeq	r0, r0, r0

00200cb0 <uart_start>:
 * @brief   UART initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void uart_start(UARTDriver *uartp) {
  200cb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200cb4:	e24dd01c 	sub	sp, sp, #28
  200cb8:	e58d0004 	str	r0, [sp, #4]

  uint32_t cr;
  const uint32_t tmo = uartp->config->timeout;
  200cbc:	e59d3004 	ldr	r3, [sp, #4]
  200cc0:	e5933004 	ldr	r3, [r3, #4]
  200cc4:	e5933018 	ldr	r3, [r3, #24]
  200cc8:	e58d3014 	str	r3, [sp, #20]
#if SAMA_UART_USE_UART && SAMA_UART_USE_FLEXCOM
  else if (uartp->usart != NULL)
#endif /* SAMA_UART_USE_UART && SAMA_UART_USE_FLEXCOM */
#if SAMA_UART_USE_FLEXCOM
  {
    Usart *us = uartp->usart;
  200ccc:	e59d3004 	ldr	r3, [sp, #4]
  200cd0:	e593300c 	ldr	r3, [r3, #12]
  200cd4:	e58d3010 	str	r3, [sp, #16]

    /* Defensive programming, starting from a clean state.*/
    uart_stop(uartp);
  200cd8:	e59d0004 	ldr	r0, [sp, #4]
  200cdc:	ebffff93 	bl	200b30 <uart_stop>

    /* Disabling write protection */
    uartFlexDisableWP(us);
  200ce0:	e59d2010 	ldr	r2, [sp, #16]
  200ce4:	e3a03c41 	mov	r3, #16640	; 0x4100
  200ce8:	e3453553 	movt	r3, #21843	; 0x5553
  200cec:	e58230e4 	str	r3, [r2, #228]	; 0xe4

    /* Baud rate setting.*/
    us->US_BRGR = US_BRGR_CD(uartp->clock / (16 * uartp->config->speed));
  200cf0:	e59d3004 	ldr	r3, [sp, #4]
  200cf4:	e5932010 	ldr	r2, [r3, #16]
  200cf8:	e59d3004 	ldr	r3, [sp, #4]
  200cfc:	e5933004 	ldr	r3, [r3, #4]
  200d00:	e593301c 	ldr	r3, [r3, #28]
  200d04:	e1a03203 	lsl	r3, r3, #4
  200d08:	e1a01003 	mov	r1, r3
  200d0c:	e1a00002 	mov	r0, r2
  200d10:	ebfffd86 	bl	200330 <__aeabi_uidiv>
  200d14:	e1a03000 	mov	r3, r0
  200d18:	e6ff2073 	uxth	r2, r3
  200d1c:	e59d3010 	ldr	r3, [sp, #16]
  200d20:	e5832020 	str	r2, [r3, #32]

    /* Clearing pending flags */
    us->US_CR = US_CR_RSTSTA;
  200d24:	e59d3010 	ldr	r3, [sp, #16]
  200d28:	e3a02c01 	mov	r2, #256	; 0x100
  200d2c:	e5832000 	str	r2, [r3]

    /* Enabling interrupts */
    us->US_IER = US_IER_OVRE | US_IER_FRAME | US_IER_PARE;
  200d30:	e59d3010 	ldr	r3, [sp, #16]
  200d34:	e3a020e0 	mov	r2, #224	; 0xe0
  200d38:	e5832008 	str	r2, [r3, #8]

    cr = US_CR_RXEN | US_CR_TXEN;
  200d3c:	e3a03050 	mov	r3, #80	; 0x50
  200d40:	e58d300c 	str	r3, [sp, #12]
    us->US_CR = uartp->config->cr | cr;
  200d44:	e59d3004 	ldr	r3, [sp, #4]
  200d48:	e5933004 	ldr	r3, [r3, #4]
  200d4c:	e5932020 	ldr	r2, [r3, #32]
  200d50:	e59d300c 	ldr	r3, [sp, #12]
  200d54:	e1822003 	orr	r2, r2, r3
  200d58:	e59d3010 	ldr	r3, [sp, #16]
  200d5c:	e5832000 	str	r2, [r3]
    us->US_MR = uartp->config->mr;
  200d60:	e59d3004 	ldr	r3, [sp, #4]
  200d64:	e5933004 	ldr	r3, [r3, #4]
  200d68:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  200d6c:	e59d3010 	ldr	r3, [sp, #16]
  200d70:	e5832004 	str	r2, [r3, #4]

    /* Set receive timeout and checks if it is really applied.*/
    if (tmo > 0) {
  200d74:	e59d3014 	ldr	r3, [sp, #20]
  200d78:	e3530000 	cmp	r3, #0
  200d7c:	0a000002 	beq	200d8c <uart_start+0xdc>
      /*
       * TODO: insert Function parameters check
       */
      us->US_RTOR = tmo;
  200d80:	e59d3010 	ldr	r3, [sp, #16]
  200d84:	e59d2014 	ldr	r2, [sp, #20]
  200d88:	e5832024 	str	r2, [r3, #36]	; 0x24
    }

    /* Enabling write protection */
    uartFlexEnableWP(us);
  200d8c:	e59d2010 	ldr	r2, [sp, #16]
  200d90:	e3043101 	movw	r3, #16641	; 0x4101
  200d94:	e3453553 	movt	r3, #21843	; 0x5553
  200d98:	e58230e4 	str	r3, [r2, #228]	; 0xe4
    osalDbgAssert(FALSE, "invalid state");
  }
#endif /* SAMA_UART_USE_UART && SAMA_UART_USE_FLEXCOM */

  /* Starting the receiver idle loop.*/
  uart_enter_rx_idle_loop(uartp);
  200d9c:	e59d0004 	ldr	r0, [sp, #4]
  200da0:	ebffff1a 	bl	200a10 <uart_enter_rx_idle_loop>
}
  200da4:	e28dd01c 	add	sp, sp, #28
  200da8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  200dac:	00000000 	andeq	r0, r0, r0

00200db0 <uart_lld_serve_rx_end_irq>:
 * @brief   RX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_rx_end_irq(UARTDriver *uartp, uint32_t flags) {
  200db0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200db4:	e24dd00c 	sub	sp, sp, #12
  200db8:	e58d0004 	str	r0, [sp, #4]
  200dbc:	e58d1000 	str	r1, [sp]

  /* DMA errors handling.*/
#if defined(SAMA_UART_DMA_ERROR_HOOK)
  if ((flags & (XDMAC_CIS_RBEIS | XDMAC_CIS_ROIS)) != 0) {
  200dc0:	e59d3000 	ldr	r3, [sp]
  200dc4:	e2033050 	and	r3, r3, #80	; 0x50
  200dc8:	e3530000 	cmp	r3, #0
  200dcc:	0a000002 	beq	200ddc <uart_lld_serve_rx_end_irq+0x2c>
    SAMA_UART_DMA_ERROR_HOOK(uartp);
  200dd0:	e30501f8 	movw	r0, #20984	; 0x51f8
  200dd4:	e3400020 	movt	r0, #32
  200dd8:	ebfffee4 	bl	200970 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  if (uartp->rxstate == UART_RX_IDLE) {
  200ddc:	e59d3004 	ldr	r3, [sp, #4]
  200de0:	e5d33002 	ldrb	r3, [r3, #2]
  200de4:	e3530000 	cmp	r3, #0
  200de8:	1a00000e 	bne	200e28 <uart_lld_serve_rx_end_irq+0x78>
    /* Receiver in idle state, a callback is generated, if enabled, for each
       received character and then the driver stays in the same state.*/
    _uart_rx_idle_code(uartp);
  200dec:	e59d3004 	ldr	r3, [sp, #4]
  200df0:	e5933004 	ldr	r3, [r3, #4]
  200df4:	e593300c 	ldr	r3, [r3, #12]
  200df8:	e3530000 	cmp	r3, #0
  200dfc:	0a000044 	beq	200f14 <uart_lld_serve_rx_end_irq+0x164>
  200e00:	e59d3004 	ldr	r3, [sp, #4]
  200e04:	e5933004 	ldr	r3, [r3, #4]
  200e08:	e593300c 	ldr	r3, [r3, #12]
  200e0c:	e59d2004 	ldr	r2, [sp, #4]
  200e10:	e1d222b4 	ldrh	r2, [r2, #36]	; 0x24
  200e14:	e6ff2072 	uxth	r2, r2
  200e18:	e1a01002 	mov	r1, r2
  200e1c:	e59d0004 	ldr	r0, [sp, #4]
  200e20:	e12fff33 	blx	r3
  200e24:	ea00003a 	b	200f14 <uart_lld_serve_rx_end_irq+0x164>
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaChannelDisable(uartp->dmarx);
  200e28:	e59d3004 	ldr	r3, [sp, #4]
  200e2c:	e593301c 	ldr	r3, [r3, #28]
  200e30:	e5933000 	ldr	r3, [r3]
  200e34:	e59d2004 	ldr	r2, [sp, #4]
  200e38:	e592201c 	ldr	r2, [r2, #28]
  200e3c:	e5922000 	ldr	r2, [r2]
  200e40:	e5921020 	ldr	r1, [r2, #32]
  200e44:	e59d2004 	ldr	r2, [sp, #4]
  200e48:	e592201c 	ldr	r2, [r2, #28]
  200e4c:	e5d22004 	ldrb	r2, [r2, #4]
  200e50:	e1a00002 	mov	r0, r2
  200e54:	e3a02001 	mov	r2, #1
  200e58:	e1a02012 	lsl	r2, r2, r0
  200e5c:	e1812002 	orr	r2, r1, r2
  200e60:	e5832020 	str	r2, [r3, #32]
  200e64:	e59d3004 	ldr	r3, [sp, #4]
  200e68:	e593301c 	ldr	r3, [r3, #28]
  200e6c:	e5933000 	ldr	r3, [r3]
  200e70:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  200e74:	e59d3004 	ldr	r3, [sp, #4]
  200e78:	e593301c 	ldr	r3, [r3, #28]
  200e7c:	e5d33004 	ldrb	r3, [r3, #4]
  200e80:	e1a01003 	mov	r1, r3
  200e84:	e3a03001 	mov	r3, #1
  200e88:	e1a03113 	lsl	r3, r3, r1
  200e8c:	e0033002 	and	r3, r3, r2
  200e90:	e3530001 	cmp	r3, #1
  200e94:	0afffff2 	beq	200e64 <uart_lld_serve_rx_end_irq+0xb4>
  200e98:	e59d3004 	ldr	r3, [sp, #4]
  200e9c:	e593301c 	ldr	r3, [r3, #28]
  200ea0:	e5932000 	ldr	r2, [r3]
  200ea4:	e59d3004 	ldr	r3, [sp, #4]
  200ea8:	e593301c 	ldr	r3, [r3, #28]
  200eac:	e5d33004 	ldrb	r3, [r3, #4]
  200eb0:	e1a03303 	lsl	r3, r3, #6
  200eb4:	e0823003 	add	r3, r2, r3
  200eb8:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
    _uart_rx_complete_isr_code(uartp);
  200ebc:	e59d3004 	ldr	r3, [sp, #4]
  200ec0:	e3a02002 	mov	r2, #2
  200ec4:	e5c32002 	strb	r2, [r3, #2]
  200ec8:	e59d3004 	ldr	r3, [sp, #4]
  200ecc:	e5933004 	ldr	r3, [r3, #4]
  200ed0:	e5933008 	ldr	r3, [r3, #8]
  200ed4:	e3530000 	cmp	r3, #0
  200ed8:	0a000004 	beq	200ef0 <uart_lld_serve_rx_end_irq+0x140>
  200edc:	e59d3004 	ldr	r3, [sp, #4]
  200ee0:	e5933004 	ldr	r3, [r3, #4]
  200ee4:	e5933008 	ldr	r3, [r3, #8]
  200ee8:	e59d0004 	ldr	r0, [sp, #4]
  200eec:	e12fff33 	blx	r3
  200ef0:	e59d3004 	ldr	r3, [sp, #4]
  200ef4:	e5d33002 	ldrb	r3, [r3, #2]
  200ef8:	e3530002 	cmp	r3, #2
  200efc:	1a000004 	bne	200f14 <uart_lld_serve_rx_end_irq+0x164>
  200f00:	e59d3004 	ldr	r3, [sp, #4]
  200f04:	e3a02000 	mov	r2, #0
  200f08:	e5c32002 	strb	r2, [r3, #2]
  200f0c:	e59d0004 	ldr	r0, [sp, #4]
  200f10:	ebfffebe 	bl	200a10 <uart_enter_rx_idle_loop>
  }
}
  200f14:	e28dd00c 	add	sp, sp, #12
  200f18:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  200f1c:	00000000 	andeq	r0, r0, r0

00200f20 <uart_lld_serve_tx_end_irq>:
 * @brief   TX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_tx_end_irq(UARTDriver *uartp, uint32_t flags) {
  200f20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  200f24:	e24dd00c 	sub	sp, sp, #12
  200f28:	e58d0004 	str	r0, [sp, #4]
  200f2c:	e58d1000 	str	r1, [sp]
  }
#else
  (void)flags;
#endif

  dmaChannelDisable(uartp->dmatx);
  200f30:	e59d3004 	ldr	r3, [sp, #4]
  200f34:	e5933020 	ldr	r3, [r3, #32]
  200f38:	e5933000 	ldr	r3, [r3]
  200f3c:	e59d2004 	ldr	r2, [sp, #4]
  200f40:	e5922020 	ldr	r2, [r2, #32]
  200f44:	e5922000 	ldr	r2, [r2]
  200f48:	e5921020 	ldr	r1, [r2, #32]
  200f4c:	e59d2004 	ldr	r2, [sp, #4]
  200f50:	e5922020 	ldr	r2, [r2, #32]
  200f54:	e5d22004 	ldrb	r2, [r2, #4]
  200f58:	e1a00002 	mov	r0, r2
  200f5c:	e3a02001 	mov	r2, #1
  200f60:	e1a02012 	lsl	r2, r2, r0
  200f64:	e1812002 	orr	r2, r1, r2
  200f68:	e5832020 	str	r2, [r3, #32]
  200f6c:	e59d3004 	ldr	r3, [sp, #4]
  200f70:	e5933020 	ldr	r3, [r3, #32]
  200f74:	e5933000 	ldr	r3, [r3]
  200f78:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  200f7c:	e59d3004 	ldr	r3, [sp, #4]
  200f80:	e5933020 	ldr	r3, [r3, #32]
  200f84:	e5d33004 	ldrb	r3, [r3, #4]
  200f88:	e1a01003 	mov	r1, r3
  200f8c:	e3a03001 	mov	r3, #1
  200f90:	e1a03113 	lsl	r3, r3, r1
  200f94:	e0033002 	and	r3, r3, r2
  200f98:	e3530001 	cmp	r3, #1
  200f9c:	0afffff2 	beq	200f6c <uart_lld_serve_tx_end_irq+0x4c>
  200fa0:	e59d3004 	ldr	r3, [sp, #4]
  200fa4:	e5933020 	ldr	r3, [r3, #32]
  200fa8:	e5932000 	ldr	r2, [r3]
  200fac:	e59d3004 	ldr	r3, [sp, #4]
  200fb0:	e5933020 	ldr	r3, [r3, #32]
  200fb4:	e5d33004 	ldrb	r3, [r3, #4]
  200fb8:	e1a03303 	lsl	r3, r3, #6
  200fbc:	e0823003 	add	r3, r2, r3
  200fc0:	e593305c 	ldr	r3, [r3, #92]	; 0x5c

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
  200fc4:	e59d3004 	ldr	r3, [sp, #4]
  200fc8:	e3a02002 	mov	r2, #2
  200fcc:	e5c32001 	strb	r2, [r3, #1]
  200fd0:	e59d3004 	ldr	r3, [sp, #4]
  200fd4:	e5933004 	ldr	r3, [r3, #4]
  200fd8:	e5933000 	ldr	r3, [r3]
  200fdc:	e3530000 	cmp	r3, #0
  200fe0:	0a000004 	beq	200ff8 <uart_lld_serve_tx_end_irq+0xd8>
  200fe4:	e59d3004 	ldr	r3, [sp, #4]
  200fe8:	e5933004 	ldr	r3, [r3, #4]
  200fec:	e5933000 	ldr	r3, [r3]
  200ff0:	e59d0004 	ldr	r0, [sp, #4]
  200ff4:	e12fff33 	blx	r3
  200ff8:	e59d3004 	ldr	r3, [sp, #4]
  200ffc:	e5d33001 	ldrb	r3, [r3, #1]
  201000:	e3530002 	cmp	r3, #2
  201004:	1a000002 	bne	201014 <uart_lld_serve_tx_end_irq+0xf4>
  201008:	e59d3004 	ldr	r3, [sp, #4]
  20100c:	e3a02000 	mov	r2, #0
  201010:	e5c32001 	strb	r2, [r3, #1]
}
  201014:	e28dd00c 	add	sp, sp, #12
  201018:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20101c:	00000000 	andeq	r0, r0, r0

00201020 <serve_uartFlex_irq>:
/**
 * @brief   UART common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_uartFlex_irq(UARTDriver *uartp) {
  201020:	e92d4010 	push	{r4, lr}
  201024:	e24dd018 	sub	sp, sp, #24
  201028:	e58d0004 	str	r0, [sp, #4]
  Usart *us = uartp->usart;
  20102c:	e59d3004 	ldr	r3, [sp, #4]
  201030:	e593300c 	ldr	r3, [r3, #12]
  201034:	e58d3014 	str	r3, [sp, #20]
  uint32_t imr = us->US_IMR;
  201038:	e59d3014 	ldr	r3, [sp, #20]
  20103c:	e5933010 	ldr	r3, [r3, #16]
  201040:	e58d3010 	str	r3, [sp, #16]
  uint32_t sr;

  /* Reading and clearing status.*/
  sr = us->US_CSR;
  201044:	e59d3014 	ldr	r3, [sp, #20]
  201048:	e5933014 	ldr	r3, [r3, #20]
  20104c:	e58d300c 	str	r3, [sp, #12]
  us->US_CR |= US_CR_RSTSTA;
  201050:	e59d3014 	ldr	r3, [sp, #20]
  201054:	e5933000 	ldr	r3, [r3]
  201058:	e3832c01 	orr	r2, r3, #256	; 0x100
  20105c:	e59d3014 	ldr	r3, [sp, #20]
  201060:	e5832000 	str	r2, [r3]

  if (sr & (US_CSR_OVRE | US_CSR_FRAME  | US_CSR_PARE)) {
  201064:	e59d300c 	ldr	r3, [sp, #12]
  201068:	e20330e0 	and	r3, r3, #224	; 0xe0
  20106c:	e3530000 	cmp	r3, #0
  201070:	0a00000d 	beq	2010ac <serve_uartFlex_irq+0x8c>
    _uart_rx_error_isr_code(uartp, translate_errors(sr));
  201074:	e59d3004 	ldr	r3, [sp, #4]
  201078:	e5933004 	ldr	r3, [r3, #4]
  20107c:	e5933010 	ldr	r3, [r3, #16]
  201080:	e3530000 	cmp	r3, #0
  201084:	0a000008 	beq	2010ac <serve_uartFlex_irq+0x8c>
  201088:	e59d3004 	ldr	r3, [sp, #4]
  20108c:	e5933004 	ldr	r3, [r3, #4]
  201090:	e5934010 	ldr	r4, [r3, #16]
  201094:	e59d000c 	ldr	r0, [sp, #12]
  201098:	ebfffe3c 	bl	200990 <translate_errors>
  20109c:	e1a03000 	mov	r3, r0
  2010a0:	e1a01003 	mov	r1, r3
  2010a4:	e59d0004 	ldr	r0, [sp, #4]
  2010a8:	e12fff34 	blx	r4
  }

  if ((imr & US_IMR_TXEMPTY) && (sr & (US_CSR_TXRDY | US_CSR_TXEMPTY))) {
  2010ac:	e59d3010 	ldr	r3, [sp, #16]
  2010b0:	e2033c02 	and	r3, r3, #512	; 0x200
  2010b4:	e3530000 	cmp	r3, #0
  2010b8:	0a000013 	beq	20110c <serve_uartFlex_irq+0xec>
  2010bc:	e59d200c 	ldr	r2, [sp, #12]
  2010c0:	e3003202 	movw	r3, #514	; 0x202
  2010c4:	e0033002 	and	r3, r3, r2
  2010c8:	e3530000 	cmp	r3, #0
  2010cc:	0a00000e 	beq	20110c <serve_uartFlex_irq+0xec>
    /* TC interrupt disabled.*/
    us->US_IDR |= US_IDR_TXEMPTY;
  2010d0:	e59d3014 	ldr	r3, [sp, #20]
  2010d4:	e593300c 	ldr	r3, [r3, #12]
  2010d8:	e3832c02 	orr	r2, r3, #512	; 0x200
  2010dc:	e59d3014 	ldr	r3, [sp, #20]
  2010e0:	e583200c 	str	r2, [r3, #12]

    /* End of transmission, a callback is generated.*/
    _uart_tx2_isr_code(uartp);
  2010e4:	e59d3004 	ldr	r3, [sp, #4]
  2010e8:	e5933004 	ldr	r3, [r3, #4]
  2010ec:	e5933004 	ldr	r3, [r3, #4]
  2010f0:	e3530000 	cmp	r3, #0
  2010f4:	0a000004 	beq	20110c <serve_uartFlex_irq+0xec>
  2010f8:	e59d3004 	ldr	r3, [sp, #4]
  2010fc:	e5933004 	ldr	r3, [r3, #4]
  201100:	e5933004 	ldr	r3, [r3, #4]
  201104:	e59d0004 	ldr	r0, [sp, #4]
  201108:	e12fff33 	blx	r3
  }
}
  20110c:	e28dd018 	add	sp, sp, #24
  201110:	e8bd8010 	pop	{r4, pc}
	...

00201120 <SAMA_UART_FLEXCOM0_HANDLER>:
/**
 * @brief   FLEXCOM0 IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SAMA_UART_FLEXCOM0_HANDLER) {
  201120:	e92d4010 	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  serve_uartFlex_irq(&FUARTD0);
  201124:	e3000c74 	movw	r0, #3188	; 0xc74
  201128:	e3400021 	movt	r0, #33	; 0x21
  20112c:	ebffffbb 	bl	201020 <serve_uartFlex_irq>
  aicAckInt();
  201130:	e3a03903 	mov	r3, #49152	; 0xc000
  201134:	e34f3803 	movt	r3, #63491	; 0xf803
  201138:	e3a02001 	mov	r2, #1
  20113c:	e5832038 	str	r2, [r3, #56]	; 0x38
  OSAL_IRQ_EPILOGUE();
  201140:	eb000e42 	bl	204a50 <chSchIsPreemptionRequired>
  201144:	e1a03000 	mov	r3, r0
}
  201148:	e1a00003 	mov	r0, r3
  20114c:	e8bd8010 	pop	{r4, pc}

00201150 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
  201150:	e92d4010 	push	{r4, lr}
  UARTD4.dmarx     = 0;
  UARTD4.dmatx     = 0;
#endif

#if SAMA_UART_USE_FLEXCOM0
  uartObjectInit(&FUARTD0);
  201154:	e3000c74 	movw	r0, #3188	; 0xc74
  201158:	e3400021 	movt	r0, #33	; 0x21
  20115c:	eb000643 	bl	202a70 <uartObjectInit>
  FUARTD0.flexcom   = FLEXCOM0;
  201160:	e3002c74 	movw	r2, #3188	; 0xc74
  201164:	e3402021 	movt	r2, #33	; 0x21
  201168:	e3a03901 	mov	r3, #16384	; 0x4000
  20116c:	e34f3803 	movt	r3, #63491	; 0xf803
  201170:	e5823008 	str	r3, [r2, #8]
  FUARTD0.usart     = USART0;
  201174:	e3002c74 	movw	r2, #3188	; 0xc74
  201178:	e3402021 	movt	r2, #33	; 0x21
  20117c:	e3a03c42 	mov	r3, #16896	; 0x4200
  201180:	e34f3803 	movt	r3, #63491	; 0xf803
  201184:	e582300c 	str	r3, [r2, #12]
  FUARTD0.clock     = SAMA_FLEXCOM0CLK;
  201188:	e3002c74 	movw	r2, #3188	; 0xc74
  20118c:	e3402021 	movt	r2, #33	; 0x21
  201190:	e3073ac0 	movw	r3, #31424	; 0x7ac0
  201194:	e34034f2 	movt	r3, #1266	; 0x4f2
  201198:	e5823010 	str	r3, [r2, #16]
  FUARTD0.rxdmamode = XDMAC_CC_TYPE_PER_TRAN |
  20119c:	e3002c74 	movw	r2, #3188	; 0xc74
  2011a0:	e3402021 	movt	r2, #33	; 0x21
  2011a4:	e3023001 	movw	r3, #8193	; 0x2001
  2011a8:	e3403c04 	movt	r3, #3076	; 0xc04
  2011ac:	e5823014 	str	r3, [r2, #20]
                      XDMAC_CC_SIF_AHB_IF1 |
                      XDMAC_CC_DIF_AHB_IF0 |
                      XDMAC_CC_SAM_FIXED_AM |
                      XDMAC_CC_DAM_INCREMENTED_AM |
                      XDMAC_CC_PERID(PERID_FLEXCOM0_RX);
  FUARTD0.txdmamode = XDMAC_CC_TYPE_PER_TRAN |
  2011b0:	e3002c74 	movw	r2, #3188	; 0xc74
  2011b4:	e3402021 	movt	r2, #33	; 0x21
  2011b8:	e3043011 	movw	r3, #16401	; 0x4011
  2011bc:	e3403b01 	movt	r3, #2817	; 0xb01
  2011c0:	e5823018 	str	r3, [r2, #24]
                      XDMAC_CC_SIF_AHB_IF0 |
                      XDMAC_CC_DIF_AHB_IF1 |
                      XDMAC_CC_SAM_INCREMENTED_AM |
                      XDMAC_CC_DAM_FIXED_AM |
                      XDMAC_CC_PERID(PERID_FLEXCOM0_TX);
  FUARTD0.dmarx     = 0;
  2011c4:	e3003c74 	movw	r3, #3188	; 0xc74
  2011c8:	e3403021 	movt	r3, #33	; 0x21
  2011cc:	e3a02000 	mov	r2, #0
  2011d0:	e583201c 	str	r2, [r3, #28]
  FUARTD0.dmatx     = 0;
  2011d4:	e3003c74 	movw	r3, #3188	; 0xc74
  2011d8:	e3403021 	movt	r3, #33	; 0x21
  2011dc:	e3a02000 	mov	r2, #0
  2011e0:	e5832020 	str	r2, [r3, #32]
                      XDMAC_CC_PERID(PERID_FLEXCOM4_TX);
  FUARTD4.dmarx     = 0;
  FUARTD4.dmatx     = 0;
#endif

}
  2011e4:	e8bd8010 	pop	{r4, pc}
	...

002011f0 <uart_lld_start>:
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
  2011f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2011f4:	e24dd00c 	sub	sp, sp, #12
  2011f8:	e58d0004 	str	r0, [sp, #4]

  if (uartp->state == UART_STOP) {
  2011fc:	e59d3004 	ldr	r3, [sp, #4]
  201200:	e5d33000 	ldrb	r3, [r3]
  201204:	e3530001 	cmp	r3, #1
  201208:	1a000069 	bne	2013b4 <uart_lld_start+0x1c4>
      dmaChannelSetMode(uartp->dmarx, uartp->rxdmamode);
    }
#endif

#if SAMA_UART_USE_FLEXCOM0
    if (&FUARTD0 == uartp) {
  20120c:	e59d2004 	ldr	r2, [sp, #4]
  201210:	e3003c74 	movw	r3, #3188	; 0xc74
  201214:	e3403021 	movt	r3, #33	; 0x21
  201218:	e1520003 	cmp	r2, r3
  20121c:	1a000061 	bne	2013a8 <uart_lld_start+0x1b8>
      uartp->dmarx = dmaChannelAllocate(SAMA_UART_FLEXCOM0_DMA_IRQ_PRIORITY,
  201220:	e59d2004 	ldr	r2, [sp, #4]
  201224:	e3001db0 	movw	r1, #3504	; 0xdb0
  201228:	e3401020 	movt	r1, #32
  20122c:	e3a00004 	mov	r0, #4
  201230:	eb00094a 	bl	203760 <dmaChannelAllocate>
  201234:	e1a02000 	mov	r2, r0
  201238:	e59d3004 	ldr	r3, [sp, #4]
  20123c:	e583201c 	str	r2, [r3, #28]
                                       (sama_dmaisr_t)uart_lld_serve_rx_end_irq,
                                       (void *)uartp);

      uartp->dmatx = dmaChannelAllocate(SAMA_UART_FLEXCOM0_DMA_IRQ_PRIORITY,
  201240:	e59d2004 	ldr	r2, [sp, #4]
  201244:	e3001f20 	movw	r1, #3872	; 0xf20
  201248:	e3401020 	movt	r1, #32
  20124c:	e3a00004 	mov	r0, #4
  201250:	eb000942 	bl	203760 <dmaChannelAllocate>
  201254:	e1a02000 	mov	r2, r0
  201258:	e59d3004 	ldr	r3, [sp, #4]
  20125c:	e5832020 	str	r2, [r3, #32]
                                       (sama_dmaisr_t)uart_lld_serve_tx_end_irq,
                                       (void *)uartp);
      /* Enabling USART on FLEXCOM */
      uartp->flexcom->FLEX_MR = FLEX_MR_OPMODE_USART;
  201260:	e59d3004 	ldr	r3, [sp, #4]
  201264:	e5933008 	ldr	r3, [r3, #8]
  201268:	e3a02001 	mov	r2, #1
  20126c:	e5832000 	str	r2, [r3]
      pmcEnableFLEXCOM0();
  201270:	e3a03901 	mov	r3, #16384	; 0x4000
  201274:	e34f3001 	movt	r3, #61441	; 0xf001
  201278:	e3a02c43 	mov	r2, #17152	; 0x4300
  20127c:	e345204d 	movt	r2, #20557	; 0x504d
  201280:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  201284:	e3a03901 	mov	r3, #16384	; 0x4000
  201288:	e34f3001 	movt	r3, #61441	; 0xf001
  20128c:	e3a02901 	mov	r2, #16384	; 0x4000
  201290:	e34f2001 	movt	r2, #61441	; 0xf001
  201294:	e5922010 	ldr	r2, [r2, #16]
  201298:	e3822702 	orr	r2, r2, #524288	; 0x80000
  20129c:	e5832010 	str	r2, [r3, #16]
  2012a0:	e3a03901 	mov	r3, #16384	; 0x4000
  2012a4:	e34f3001 	movt	r3, #61441	; 0xf001
  2012a8:	e3042301 	movw	r2, #17153	; 0x4301
  2012ac:	e345204d 	movt	r2, #20557	; 0x504d
  2012b0:	e58320e4 	str	r2, [r3, #228]	; 0xe4
      aicSetSourcePriority(ID_USART0, SAMA_UART_FLEXCOM0_IRQ_PRIORITY);
  2012b4:	e3a01004 	mov	r1, #4
  2012b8:	e3a00013 	mov	r0, #19
  2012bc:	eb0007cb 	bl	2031f0 <aicSetSourcePriority>
      aicSetSourceHandler(ID_USART0, SAMA_UART_FLEXCOM0_HANDLER);
  2012c0:	e3011120 	movw	r1, #4384	; 0x1120
  2012c4:	e3401020 	movt	r1, #32
  2012c8:	e3a00013 	mov	r0, #19
  2012cc:	eb0007e7 	bl	203270 <aicSetSourceHandler>
      aicEnableInt(ID_USART0);
  2012d0:	e3a00013 	mov	r0, #19
  2012d4:	eb0007fd 	bl	2032d0 <aicEnableInt>

      /* Configuring destination and mode of txdma channel*/
      dmaChannelSetDestination(uartp->dmatx, &uartp->usart->US_THR);
  2012d8:	e59d3004 	ldr	r3, [sp, #4]
  2012dc:	e5933020 	ldr	r3, [r3, #32]
  2012e0:	e5932000 	ldr	r2, [r3]
  2012e4:	e59d3004 	ldr	r3, [sp, #4]
  2012e8:	e5933020 	ldr	r3, [r3, #32]
  2012ec:	e5d33004 	ldrb	r3, [r3, #4]
  2012f0:	e1a00003 	mov	r0, r3
  2012f4:	e59d3004 	ldr	r3, [sp, #4]
  2012f8:	e593300c 	ldr	r3, [r3, #12]
  2012fc:	e283301c 	add	r3, r3, #28
  201300:	e1a01003 	mov	r1, r3
  201304:	e1a03300 	lsl	r3, r0, #6
  201308:	e0823003 	add	r3, r2, r3
  20130c:	e5831064 	str	r1, [r3, #100]	; 0x64
      dmaChannelSetMode(uartp->dmatx, uartp->txdmamode);
  201310:	e59d3004 	ldr	r3, [sp, #4]
  201314:	e5933020 	ldr	r3, [r3, #32]
  201318:	e5931000 	ldr	r1, [r3]
  20131c:	e59d3004 	ldr	r3, [sp, #4]
  201320:	e5933020 	ldr	r3, [r3, #32]
  201324:	e5d33004 	ldrb	r3, [r3, #4]
  201328:	e1a00003 	mov	r0, r3
  20132c:	e59d3004 	ldr	r3, [sp, #4]
  201330:	e5932018 	ldr	r2, [r3, #24]
  201334:	e1a03300 	lsl	r3, r0, #6
  201338:	e0813003 	add	r3, r1, r3
  20133c:	e5832078 	str	r2, [r3, #120]	; 0x78

      /* Configuring source and mode of rxdma channel*/
      dmaChannelSetSource(uartp->dmarx, &uartp->usart->US_RHR);
  201340:	e59d3004 	ldr	r3, [sp, #4]
  201344:	e593301c 	ldr	r3, [r3, #28]
  201348:	e5932000 	ldr	r2, [r3]
  20134c:	e59d3004 	ldr	r3, [sp, #4]
  201350:	e593301c 	ldr	r3, [r3, #28]
  201354:	e5d33004 	ldrb	r3, [r3, #4]
  201358:	e1a00003 	mov	r0, r3
  20135c:	e59d3004 	ldr	r3, [sp, #4]
  201360:	e593300c 	ldr	r3, [r3, #12]
  201364:	e2833018 	add	r3, r3, #24
  201368:	e1a01003 	mov	r1, r3
  20136c:	e1a03300 	lsl	r3, r0, #6
  201370:	e0823003 	add	r3, r2, r3
  201374:	e5831060 	str	r1, [r3, #96]	; 0x60
      dmaChannelSetMode(uartp->dmarx, uartp->rxdmamode);
  201378:	e59d3004 	ldr	r3, [sp, #4]
  20137c:	e593301c 	ldr	r3, [r3, #28]
  201380:	e5931000 	ldr	r1, [r3]
  201384:	e59d3004 	ldr	r3, [sp, #4]
  201388:	e593301c 	ldr	r3, [r3, #28]
  20138c:	e5d33004 	ldrb	r3, [r3, #4]
  201390:	e1a00003 	mov	r0, r3
  201394:	e59d3004 	ldr	r3, [sp, #4]
  201398:	e5932014 	ldr	r2, [r3, #20]
  20139c:	e1a03300 	lsl	r3, r0, #6
  2013a0:	e0813003 	add	r3, r1, r3
  2013a4:	e5832078 	str	r2, [r3, #120]	; 0x78

/*
 * TODO: Configure DMA for bit > 9
 */

    uartp->rxbuf = 0;
  2013a8:	e59d3004 	ldr	r3, [sp, #4]
  2013ac:	e3a02000 	mov	r2, #0
  2013b0:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
  }

  uartp->rxstate = UART_RX_IDLE;
  2013b4:	e59d3004 	ldr	r3, [sp, #4]
  2013b8:	e3a02000 	mov	r2, #0
  2013bc:	e5c32002 	strb	r2, [r3, #2]
  uartp->txstate = UART_TX_IDLE;
  2013c0:	e59d3004 	ldr	r3, [sp, #4]
  2013c4:	e3a02000 	mov	r2, #0
  2013c8:	e5c32001 	strb	r2, [r3, #1]
  uart_start(uartp);
  2013cc:	e59d0004 	ldr	r0, [sp, #4]
  2013d0:	ebfffe36 	bl	200cb0 <uart_start>
}
  2013d4:	e28dd00c 	add	sp, sp, #12
  2013d8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2013dc:	00000000 	andeq	r0, r0, r0

002013e0 <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
  2013e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2013e4:	e24dd014 	sub	sp, sp, #20
  2013e8:	e58d000c 	str	r0, [sp, #12]
  2013ec:	e58d1008 	str	r1, [sp, #8]
  2013f0:	e58d2004 	str	r2, [sp, #4]

  /* Only enable TC interrupt if there's a callback attached to it.
     Also we need to clear TC flag which could be set before. */
  if (uartp->config->txend2_cb != NULL) {
  2013f4:	e59d300c 	ldr	r3, [sp, #12]
  2013f8:	e5933004 	ldr	r3, [r3, #4]
  2013fc:	e5933004 	ldr	r3, [r3, #4]
  201400:	e3530000 	cmp	r3, #0
  201404:	0a000007 	beq	201428 <uart_lld_start_send+0x48>
#if SAMA_UART_USE_UART
    if (uartp->uart != NULL)
      uartp->uart->UART_IER = UART_IER_TXEMPTY;
#endif
#if SAMA_UART_USE_FLEXCOM
    if (uartp->usart != NULL)
  201408:	e59d300c 	ldr	r3, [sp, #12]
  20140c:	e593300c 	ldr	r3, [r3, #12]
  201410:	e3530000 	cmp	r3, #0
  201414:	0a000003 	beq	201428 <uart_lld_start_send+0x48>
      uartp->usart->US_IER = US_IER_TXEMPTY;
  201418:	e59d300c 	ldr	r3, [sp, #12]
  20141c:	e593300c 	ldr	r3, [r3, #12]
  201420:	e3a02c02 	mov	r2, #512	; 0x200
  201424:	e5832008 	str	r2, [r3, #8]
#endif
  }

  /* TX DMA channel preparation.*/
  dmaChannelSetSource(uartp->dmatx, txbuf);
  201428:	e59d300c 	ldr	r3, [sp, #12]
  20142c:	e5933020 	ldr	r3, [r3, #32]
  201430:	e5931000 	ldr	r1, [r3]
  201434:	e59d300c 	ldr	r3, [sp, #12]
  201438:	e5933020 	ldr	r3, [r3, #32]
  20143c:	e5d33004 	ldrb	r3, [r3, #4]
  201440:	e59d2004 	ldr	r2, [sp, #4]
  201444:	e1a03303 	lsl	r3, r3, #6
  201448:	e0813003 	add	r3, r1, r3
  20144c:	e5832060 	str	r2, [r3, #96]	; 0x60
  dmaChannelSetTransactionSize(uartp->dmatx, n);
  201450:	e59d300c 	ldr	r3, [sp, #12]
  201454:	e5933020 	ldr	r3, [r3, #32]
  201458:	e59d1008 	ldr	r1, [sp, #8]
  20145c:	e1a00003 	mov	r0, r3
  201460:	eb000872 	bl	203630 <dmaChannelSetTransactionSize>

  /* Starting transfer.*/
  dmaChannelEnable(uartp->dmatx);
  201464:	e59d300c 	ldr	r3, [sp, #12]
  201468:	e5933020 	ldr	r3, [r3, #32]
  20146c:	e5933000 	ldr	r3, [r3]
  201470:	e59d200c 	ldr	r2, [sp, #12]
  201474:	e5922020 	ldr	r2, [r2, #32]
  201478:	e5922000 	ldr	r2, [r2]
  20147c:	e592101c 	ldr	r1, [r2, #28]
  201480:	e59d200c 	ldr	r2, [sp, #12]
  201484:	e5922020 	ldr	r2, [r2, #32]
  201488:	e5d22004 	ldrb	r2, [r2, #4]
  20148c:	e1a00002 	mov	r0, r2
  201490:	e3a02001 	mov	r2, #1
  201494:	e1a02012 	lsl	r2, r2, r0
  201498:	e1812002 	orr	r2, r1, r2
  20149c:	e583201c 	str	r2, [r3, #28]
}
  2014a0:	e28dd014 	add	sp, sp, #20
  2014a4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002014b0 <uart_lld_stop_send>:
 * @return              The number of data frames not transmitted by the
 *                      stopped transmit operation.
 *
 * @notapi
 */
size_t uart_lld_stop_send(UARTDriver *uartp) {
  2014b0:	e24dd008 	sub	sp, sp, #8
  2014b4:	e58d0004 	str	r0, [sp, #4]

  dmaChannelDisable(uartp->dmatx);
  2014b8:	e59d3004 	ldr	r3, [sp, #4]
  2014bc:	e5933020 	ldr	r3, [r3, #32]
  2014c0:	e5933000 	ldr	r3, [r3]
  2014c4:	e59d2004 	ldr	r2, [sp, #4]
  2014c8:	e5922020 	ldr	r2, [r2, #32]
  2014cc:	e5922000 	ldr	r2, [r2]
  2014d0:	e5921020 	ldr	r1, [r2, #32]
  2014d4:	e59d2004 	ldr	r2, [sp, #4]
  2014d8:	e5922020 	ldr	r2, [r2, #32]
  2014dc:	e5d22004 	ldrb	r2, [r2, #4]
  2014e0:	e1a00002 	mov	r0, r2
  2014e4:	e3a02001 	mov	r2, #1
  2014e8:	e1a02012 	lsl	r2, r2, r0
  2014ec:	e1812002 	orr	r2, r1, r2
  2014f0:	e5832020 	str	r2, [r3, #32]
  2014f4:	e59d3004 	ldr	r3, [sp, #4]
  2014f8:	e5933020 	ldr	r3, [r3, #32]
  2014fc:	e5933000 	ldr	r3, [r3]
  201500:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  201504:	e59d3004 	ldr	r3, [sp, #4]
  201508:	e5933020 	ldr	r3, [r3, #32]
  20150c:	e5d33004 	ldrb	r3, [r3, #4]
  201510:	e1a01003 	mov	r1, r3
  201514:	e3a03001 	mov	r3, #1
  201518:	e1a03113 	lsl	r3, r3, r1
  20151c:	e0033002 	and	r3, r3, r2
  201520:	e3530001 	cmp	r3, #1
  201524:	0afffff2 	beq	2014f4 <uart_lld_stop_send+0x44>
  201528:	e59d3004 	ldr	r3, [sp, #4]
  20152c:	e5933020 	ldr	r3, [r3, #32]
  201530:	e5932000 	ldr	r2, [r3]
  201534:	e59d3004 	ldr	r3, [sp, #4]
  201538:	e5933020 	ldr	r3, [r3, #32]
  20153c:	e5d33004 	ldrb	r3, [r3, #4]
  201540:	e1a03303 	lsl	r3, r3, #6
  201544:	e0823003 	add	r3, r2, r3
  201548:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
  /* number of data frames not transmitted is always zero */
  return 0;
  20154c:	e3a03000 	mov	r3, #0
}
  201550:	e1a00003 	mov	r0, r3
  201554:	e28dd008 	add	sp, sp, #8
  201558:	e12fff1e 	bx	lr
  20155c:	00000000 	andeq	r0, r0, r0

00201560 <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
  201560:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201564:	e24dd014 	sub	sp, sp, #20
  201568:	e58d000c 	str	r0, [sp, #12]
  20156c:	e58d1008 	str	r1, [sp, #8]
  201570:	e58d2004 	str	r2, [sp, #4]

  /* Stopping previous activity (idle state).*/
  dmaChannelDisable(uartp->dmarx);
  201574:	e59d300c 	ldr	r3, [sp, #12]
  201578:	e593301c 	ldr	r3, [r3, #28]
  20157c:	e5933000 	ldr	r3, [r3]
  201580:	e59d200c 	ldr	r2, [sp, #12]
  201584:	e592201c 	ldr	r2, [r2, #28]
  201588:	e5922000 	ldr	r2, [r2]
  20158c:	e5921020 	ldr	r1, [r2, #32]
  201590:	e59d200c 	ldr	r2, [sp, #12]
  201594:	e592201c 	ldr	r2, [r2, #28]
  201598:	e5d22004 	ldrb	r2, [r2, #4]
  20159c:	e1a00002 	mov	r0, r2
  2015a0:	e3a02001 	mov	r2, #1
  2015a4:	e1a02012 	lsl	r2, r2, r0
  2015a8:	e1812002 	orr	r2, r1, r2
  2015ac:	e5832020 	str	r2, [r3, #32]
  2015b0:	e59d300c 	ldr	r3, [sp, #12]
  2015b4:	e593301c 	ldr	r3, [r3, #28]
  2015b8:	e5933000 	ldr	r3, [r3]
  2015bc:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  2015c0:	e59d300c 	ldr	r3, [sp, #12]
  2015c4:	e593301c 	ldr	r3, [r3, #28]
  2015c8:	e5d33004 	ldrb	r3, [r3, #4]
  2015cc:	e1a01003 	mov	r1, r3
  2015d0:	e3a03001 	mov	r3, #1
  2015d4:	e1a03113 	lsl	r3, r3, r1
  2015d8:	e0033002 	and	r3, r3, r2
  2015dc:	e3530001 	cmp	r3, #1
  2015e0:	0afffff2 	beq	2015b0 <uart_lld_start_receive+0x50>
  2015e4:	e59d300c 	ldr	r3, [sp, #12]
  2015e8:	e593301c 	ldr	r3, [r3, #28]
  2015ec:	e5932000 	ldr	r2, [r3]
  2015f0:	e59d300c 	ldr	r3, [sp, #12]
  2015f4:	e593301c 	ldr	r3, [r3, #28]
  2015f8:	e5d33004 	ldrb	r3, [r3, #4]
  2015fc:	e1a03303 	lsl	r3, r3, #6
  201600:	e0823003 	add	r3, r2, r3
  201604:	e593305c 	ldr	r3, [r3, #92]	; 0x5c

  /* Enabling BIE interrupt if disabled */
  if ((uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CIM & XDMAC_CIM_BIM) == 0) {
  201608:	e59d300c 	ldr	r3, [sp, #12]
  20160c:	e593301c 	ldr	r3, [r3, #28]
  201610:	e5932000 	ldr	r2, [r3]
  201614:	e59d300c 	ldr	r3, [sp, #12]
  201618:	e593301c 	ldr	r3, [r3, #28]
  20161c:	e5d33004 	ldrb	r3, [r3, #4]
  201620:	e1a03303 	lsl	r3, r3, #6
  201624:	e0823003 	add	r3, r2, r3
  201628:	e5933058 	ldr	r3, [r3, #88]	; 0x58
  20162c:	e2033001 	and	r3, r3, #1
  201630:	e3530000 	cmp	r3, #0
  201634:	1a000009 	bne	201660 <uart_lld_start_receive+0x100>
  uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CIE =  XDMAC_CIE_BIE;
  201638:	e59d300c 	ldr	r3, [sp, #12]
  20163c:	e593301c 	ldr	r3, [r3, #28]
  201640:	e5932000 	ldr	r2, [r3]
  201644:	e59d300c 	ldr	r3, [sp, #12]
  201648:	e593301c 	ldr	r3, [r3, #28]
  20164c:	e5d33004 	ldrb	r3, [r3, #4]
  201650:	e1a03303 	lsl	r3, r3, #6
  201654:	e0823003 	add	r3, r2, r3
  201658:	e3a02001 	mov	r2, #1
  20165c:	e5832050 	str	r2, [r3, #80]	; 0x50
  }

  /* Resetting the XDMAC_CNCDAx */
  uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CNDA = 0;
  201660:	e59d300c 	ldr	r3, [sp, #12]
  201664:	e593301c 	ldr	r3, [r3, #28]
  201668:	e5932000 	ldr	r2, [r3]
  20166c:	e59d300c 	ldr	r3, [sp, #12]
  201670:	e593301c 	ldr	r3, [r3, #28]
  201674:	e5d33004 	ldrb	r3, [r3, #4]
  201678:	e1a03303 	lsl	r3, r3, #6
  20167c:	e0823003 	add	r3, r2, r3
  201680:	e3a02000 	mov	r2, #0
  201684:	e5832068 	str	r2, [r3, #104]	; 0x68
  /* resetting the XDMAC_CNDCx register */
  uartp->dmarx->xdmac->XDMAC_CHID[uartp->dmarx->chid].XDMAC_CNDC = 0;
  201688:	e59d300c 	ldr	r3, [sp, #12]
  20168c:	e593301c 	ldr	r3, [r3, #28]
  201690:	e5932000 	ldr	r2, [r3]
  201694:	e59d300c 	ldr	r3, [sp, #12]
  201698:	e593301c 	ldr	r3, [r3, #28]
  20169c:	e5d33004 	ldrb	r3, [r3, #4]
  2016a0:	e1a03303 	lsl	r3, r3, #6
  2016a4:	e0823003 	add	r3, r2, r3
  2016a8:	e3a02000 	mov	r2, #0
  2016ac:	e583206c 	str	r2, [r3, #108]	; 0x6c
#if SAMA_UART_USE_UART
  if (uartp->uart != NULL)
    dmaChannelSetSource(uartp->dmarx, &uartp->uart->UART_RHR);
#endif
#if SAMA_UART_USE_FLEXCOM
  if (uartp->usart != NULL)
  2016b0:	e59d300c 	ldr	r3, [sp, #12]
  2016b4:	e593300c 	ldr	r3, [r3, #12]
  2016b8:	e3530000 	cmp	r3, #0
  2016bc:	0a00000d 	beq	2016f8 <uart_lld_start_receive+0x198>
    dmaChannelSetSource(uartp->dmarx, &uartp->usart->US_RHR);
  2016c0:	e59d300c 	ldr	r3, [sp, #12]
  2016c4:	e593301c 	ldr	r3, [r3, #28]
  2016c8:	e5932000 	ldr	r2, [r3]
  2016cc:	e59d300c 	ldr	r3, [sp, #12]
  2016d0:	e593301c 	ldr	r3, [r3, #28]
  2016d4:	e5d33004 	ldrb	r3, [r3, #4]
  2016d8:	e1a00003 	mov	r0, r3
  2016dc:	e59d300c 	ldr	r3, [sp, #12]
  2016e0:	e593300c 	ldr	r3, [r3, #12]
  2016e4:	e2833018 	add	r3, r3, #24
  2016e8:	e1a01003 	mov	r1, r3
  2016ec:	e1a03300 	lsl	r3, r0, #6
  2016f0:	e0823003 	add	r3, r2, r3
  2016f4:	e5831060 	str	r1, [r3, #96]	; 0x60
#endif
  dmaChannelSetDestination(uartp->dmarx, rxbuf);
  2016f8:	e59d300c 	ldr	r3, [sp, #12]
  2016fc:	e593301c 	ldr	r3, [r3, #28]
  201700:	e5931000 	ldr	r1, [r3]
  201704:	e59d300c 	ldr	r3, [sp, #12]
  201708:	e593301c 	ldr	r3, [r3, #28]
  20170c:	e5d33004 	ldrb	r3, [r3, #4]
  201710:	e59d2004 	ldr	r2, [sp, #4]
  201714:	e1a03303 	lsl	r3, r3, #6
  201718:	e0813003 	add	r3, r1, r3
  20171c:	e5832064 	str	r2, [r3, #100]	; 0x64
  dmaChannelSetTransactionSize(uartp->dmarx, n);
  201720:	e59d300c 	ldr	r3, [sp, #12]
  201724:	e593301c 	ldr	r3, [r3, #28]
  201728:	e59d1008 	ldr	r1, [sp, #8]
  20172c:	e1a00003 	mov	r0, r3
  201730:	eb0007be 	bl	203630 <dmaChannelSetTransactionSize>
  dmaChannelSetMode(uartp->dmarx, uartp->rxdmamode);
  201734:	e59d300c 	ldr	r3, [sp, #12]
  201738:	e593301c 	ldr	r3, [r3, #28]
  20173c:	e5931000 	ldr	r1, [r3]
  201740:	e59d300c 	ldr	r3, [sp, #12]
  201744:	e593301c 	ldr	r3, [r3, #28]
  201748:	e5d33004 	ldrb	r3, [r3, #4]
  20174c:	e1a00003 	mov	r0, r3
  201750:	e59d300c 	ldr	r3, [sp, #12]
  201754:	e5932014 	ldr	r2, [r3, #20]
  201758:	e1a03300 	lsl	r3, r0, #6
  20175c:	e0813003 	add	r3, r1, r3
  201760:	e5832078 	str	r2, [r3, #120]	; 0x78

  /* Starting transfer.*/
  dmaChannelEnable(uartp->dmarx);
  201764:	e59d300c 	ldr	r3, [sp, #12]
  201768:	e593301c 	ldr	r3, [r3, #28]
  20176c:	e5933000 	ldr	r3, [r3]
  201770:	e59d200c 	ldr	r2, [sp, #12]
  201774:	e592201c 	ldr	r2, [r2, #28]
  201778:	e5922000 	ldr	r2, [r2]
  20177c:	e592101c 	ldr	r1, [r2, #28]
  201780:	e59d200c 	ldr	r2, [sp, #12]
  201784:	e592201c 	ldr	r2, [r2, #28]
  201788:	e5d22004 	ldrb	r2, [r2, #4]
  20178c:	e1a00002 	mov	r0, r2
  201790:	e3a02001 	mov	r2, #1
  201794:	e1a02012 	lsl	r2, r2, r0
  201798:	e1812002 	orr	r2, r1, r2
  20179c:	e583201c 	str	r2, [r3, #28]
}
  2017a0:	e28dd014 	add	sp, sp, #20
  2017a4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002017b0 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  2017b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2017b4:	e24dd014 	sub	sp, sp, #20
  2017b8:	e58d0004 	str	r0, [sp, #4]
  size_t n;

  dmaChannelDisable(uartp->dmarx);
  2017bc:	e59d3004 	ldr	r3, [sp, #4]
  2017c0:	e593301c 	ldr	r3, [r3, #28]
  2017c4:	e5933000 	ldr	r3, [r3]
  2017c8:	e59d2004 	ldr	r2, [sp, #4]
  2017cc:	e592201c 	ldr	r2, [r2, #28]
  2017d0:	e5922000 	ldr	r2, [r2]
  2017d4:	e5921020 	ldr	r1, [r2, #32]
  2017d8:	e59d2004 	ldr	r2, [sp, #4]
  2017dc:	e592201c 	ldr	r2, [r2, #28]
  2017e0:	e5d22004 	ldrb	r2, [r2, #4]
  2017e4:	e1a00002 	mov	r0, r2
  2017e8:	e3a02001 	mov	r2, #1
  2017ec:	e1a02012 	lsl	r2, r2, r0
  2017f0:	e1812002 	orr	r2, r1, r2
  2017f4:	e5832020 	str	r2, [r3, #32]
  2017f8:	e59d3004 	ldr	r3, [sp, #4]
  2017fc:	e593301c 	ldr	r3, [r3, #28]
  201800:	e5933000 	ldr	r3, [r3]
  201804:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  201808:	e59d3004 	ldr	r3, [sp, #4]
  20180c:	e593301c 	ldr	r3, [r3, #28]
  201810:	e5d33004 	ldrb	r3, [r3, #4]
  201814:	e1a01003 	mov	r1, r3
  201818:	e3a03001 	mov	r3, #1
  20181c:	e1a03113 	lsl	r3, r3, r1
  201820:	e0033002 	and	r3, r3, r2
  201824:	e3530001 	cmp	r3, #1
  201828:	0afffff2 	beq	2017f8 <uart_lld_stop_receive+0x48>
  20182c:	e59d3004 	ldr	r3, [sp, #4]
  201830:	e593301c 	ldr	r3, [r3, #28]
  201834:	e5932000 	ldr	r2, [r3]
  201838:	e59d3004 	ldr	r3, [sp, #4]
  20183c:	e593301c 	ldr	r3, [r3, #28]
  201840:	e5d33004 	ldrb	r3, [r3, #4]
  201844:	e1a03303 	lsl	r3, r3, #6
  201848:	e0823003 	add	r3, r2, r3
  20184c:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
  n = 0;
  201850:	e3a03000 	mov	r3, #0
  201854:	e58d300c 	str	r3, [sp, #12]
  uart_enter_rx_idle_loop(uartp);
  201858:	e59d0004 	ldr	r0, [sp, #4]
  20185c:	ebfffc6b 	bl	200a10 <uart_enter_rx_idle_loop>

  return n;
  201860:	e59d300c 	ldr	r3, [sp, #12]
}
  201864:	e1a00003 	mov	r0, r3
  201868:	e28dd014 	add	sp, sp, #20
  20186c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00201870 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
  201870:	e92d4010 	push	{r4, lr}

  sama_clock_init();
  201874:	eb00051d 	bl	202cf0 <sama_clock_init>
}
  201878:	e8bd8010 	pop	{r4, pc}
  20187c:	00000000 	andeq	r0, r0, r0

00201880 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 */
void boardInit(void) {
  201880:	e24dd008 	sub	sp, sp, #8
  unsigned i;

#if SAMA_HAL_IS_SECURE
  /* Disabling PMC write protection. */
  pmcDisableWP();
  201884:	e3a03901 	mov	r3, #16384	; 0x4000
  201888:	e34f3001 	movt	r3, #61441	; 0xf001
  20188c:	e3a02c43 	mov	r2, #17152	; 0x4300
  201890:	e345204d 	movt	r2, #20557	; 0x504d
  201894:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling port clock. */
  pmcEnablePIO();
  201898:	e3a03901 	mov	r3, #16384	; 0x4000
  20189c:	e34f3001 	movt	r3, #61441	; 0xf001
  2018a0:	e3a02c43 	mov	r2, #17152	; 0x4300
  2018a4:	e345204d 	movt	r2, #20557	; 0x504d
  2018a8:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  2018ac:	e3a03901 	mov	r3, #16384	; 0x4000
  2018b0:	e34f3001 	movt	r3, #61441	; 0xf001
  2018b4:	e3a02901 	mov	r2, #16384	; 0x4000
  2018b8:	e34f2001 	movt	r2, #61441	; 0xf001
  2018bc:	e5922010 	ldr	r2, [r2, #16]
  2018c0:	e3822701 	orr	r2, r2, #262144	; 0x40000
  2018c4:	e5832010 	str	r2, [r3, #16]
  2018c8:	e3a03901 	mov	r3, #16384	; 0x4000
  2018cc:	e34f3001 	movt	r3, #61441	; 0xf001
  2018d0:	e3042301 	movw	r2, #17153	; 0x4301
  2018d4:	e345204d 	movt	r2, #20557	; 0x504d
  2018d8:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling write protection.  */
  pmcEnableWP();
  2018dc:	e3a03901 	mov	r3, #16384	; 0x4000
  2018e0:	e34f3001 	movt	r3, #61441	; 0xf001
  2018e4:	e3042301 	movw	r2, #17153	; 0x4301
  2018e8:	e345204d 	movt	r2, #20557	; 0x504d
  2018ec:	e58320e4 	str	r2, [r3, #228]	; 0xe4
#endif /* SAMA_HAL_IS_SECURE */

  /* Configuring all PIO A pads with default configuration.  */
#if SAMA_HAS_PIOA
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  2018f0:	e3a03902 	mov	r3, #32768	; 0x8000
  2018f4:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2018f8:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2018fc:	e1a02003 	mov	r2, r3
  201900:	e3a03000 	mov	r3, #0
  201904:	e5823034 	str	r3, [r2, #52]	; 0x34
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  201908:	e3a03902 	mov	r3, #32768	; 0x8000
  20190c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201910:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201914:	e1a02003 	mov	r2, r3
  201918:	e3e03000 	mvn	r3, #0
  20191c:	e5823030 	str	r3, [r2, #48]	; 0x30
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  201920:	e3a03902 	mov	r3, #32768	; 0x8000
  201924:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201928:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20192c:	e1a02003 	mov	r2, r3
  201930:	e3e03000 	mvn	r3, #0
  201934:	e5823000 	str	r3, [r2]
  _PIOA->PIO_PIO_[SAMA_PIOA].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  201938:	e3a03902 	mov	r3, #32768	; 0x8000
  20193c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201940:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201944:	e1a02003 	mov	r2, r3
  201948:	e3a03c82 	mov	r3, #33280	; 0x8200
  20194c:	e5823004 	str	r3, [r2, #4]
#endif /* SAMA_HAS_PIOA */

  /* Configuring all PIO B pads with default configuration.  */
#if SAMA_HAS_PIOB
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  201950:	e3a03902 	mov	r3, #32768	; 0x8000
  201954:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201958:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20195c:	e1a02003 	mov	r2, r3
  201960:	e3a03000 	mov	r3, #0
  201964:	e5823074 	str	r3, [r2, #116]	; 0x74
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  201968:	e3a03902 	mov	r3, #32768	; 0x8000
  20196c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201970:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201974:	e1a02003 	mov	r2, r3
  201978:	e3e03000 	mvn	r3, #0
  20197c:	e5823070 	str	r3, [r2, #112]	; 0x70
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  201980:	e3a03902 	mov	r3, #32768	; 0x8000
  201984:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201988:	e2833a01 	add	r3, r3, #4096	; 0x1000
  20198c:	e1a02003 	mov	r2, r3
  201990:	e3e03000 	mvn	r3, #0
  201994:	e5823040 	str	r3, [r2, #64]	; 0x40
  _PIOA->PIO_PIO_[SAMA_PIOB].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  201998:	e3a03902 	mov	r3, #32768	; 0x8000
  20199c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2019a0:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2019a4:	e1a02003 	mov	r2, r3
  2019a8:	e3a03c82 	mov	r3, #33280	; 0x8200
  2019ac:	e5823044 	str	r3, [r2, #68]	; 0x44
#endif /* SAMA_HAS_PIOB */

  /* Configuring all PIO C pads with default configuration.  */
#if SAMA_HAS_PIOC
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  2019b0:	e3a03902 	mov	r3, #32768	; 0x8000
  2019b4:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2019b8:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2019bc:	e1a02003 	mov	r2, r3
  2019c0:	e3a03000 	mov	r3, #0
  2019c4:	e58230b4 	str	r3, [r2, #180]	; 0xb4
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  2019c8:	e3a03902 	mov	r3, #32768	; 0x8000
  2019cc:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2019d0:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2019d4:	e1a02003 	mov	r2, r3
  2019d8:	e3e03000 	mvn	r3, #0
  2019dc:	e58230b0 	str	r3, [r2, #176]	; 0xb0
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  2019e0:	e3a03902 	mov	r3, #32768	; 0x8000
  2019e4:	e34f3c03 	movt	r3, #64515	; 0xfc03
  2019e8:	e2833a01 	add	r3, r3, #4096	; 0x1000
  2019ec:	e1a02003 	mov	r2, r3
  2019f0:	e3e03000 	mvn	r3, #0
  2019f4:	e5823080 	str	r3, [r2, #128]	; 0x80
  _PIOA->PIO_PIO_[SAMA_PIOC].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  2019f8:	e3a03902 	mov	r3, #32768	; 0x8000
  2019fc:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201a00:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201a04:	e1a02003 	mov	r2, r3
  201a08:	e3a03c82 	mov	r3, #33280	; 0x8200
  201a0c:	e5823084 	str	r3, [r2, #132]	; 0x84
#endif /* SAMA_HAS_PIOC */

  /* Configuring all PIO D pads with default configuration.  */
#if SAMA_HAS_PIOD
#if SAMA_HAL_IS_SECURE
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_SIOSR = SAMA_DEFAULT_SIOSR;
  201a10:	e3a03902 	mov	r3, #32768	; 0x8000
  201a14:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201a18:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201a1c:	e1a02003 	mov	r2, r3
  201a20:	e3a03000 	mov	r3, #0
  201a24:	e58230f4 	str	r3, [r2, #244]	; 0xf4
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_SIONR = SAMA_DEFAULT_SIONR;
  201a28:	e3a03902 	mov	r3, #32768	; 0x8000
  201a2c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201a30:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201a34:	e1a02003 	mov	r2, r3
  201a38:	e3e03000 	mvn	r3, #0
  201a3c:	e58230f0 	str	r3, [r2, #240]	; 0xf0
#endif /* SAMA_HAL_IS_SECURE */
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_MSKR = SAMA_DEFAULT_MSKR;
  201a40:	e3a03902 	mov	r3, #32768	; 0x8000
  201a44:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201a48:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201a4c:	e1a02003 	mov	r2, r3
  201a50:	e3e03000 	mvn	r3, #0
  201a54:	e58230c0 	str	r3, [r2, #192]	; 0xc0
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
  201a58:	e3a03902 	mov	r3, #32768	; 0x8000
  201a5c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201a60:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201a64:	e1a02003 	mov	r2, r3
  201a68:	e3a03c82 	mov	r3, #33280	; 0x8200
  201a6c:	e58230c4 	str	r3, [r2, #196]	; 0xc4
#endif /* SAMA_HAS_PIOD */

  /* Initialize PIO registers for defined pads.*/
  i = 0;
  201a70:	e3a03000 	mov	r3, #0
  201a74:	e58d3004 	str	r3, [sp, #4]
  201a78:	ea00005c 	b	201bf0 <boardInit+0x370>
  while (sama_inits[i].pio_id != -1) {
#if SAMA_HAL_IS_SECURE
    _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_SIOSR = sama_inits[i].pio_msk;
  201a7c:	e3a02902 	mov	r2, #32768	; 0x8000
  201a80:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201a84:	e3053290 	movw	r3, #21136	; 0x5290
  201a88:	e3403020 	movt	r3, #32
  201a8c:	e59d1004 	ldr	r1, [sp, #4]
  201a90:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  201a94:	e3051290 	movw	r1, #21136	; 0x5290
  201a98:	e3401020 	movt	r1, #32
  201a9c:	e59d3004 	ldr	r3, [sp, #4]
  201aa0:	e1a03203 	lsl	r3, r3, #4
  201aa4:	e0813003 	add	r3, r1, r3
  201aa8:	e5931004 	ldr	r1, [r3, #4]
  201aac:	e1a03300 	lsl	r3, r0, #6
  201ab0:	e0823003 	add	r3, r2, r3
  201ab4:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201ab8:	e2833034 	add	r3, r3, #52	; 0x34
  201abc:	e5831000 	str	r1, [r3]
    _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_MSKR = sama_inits[i].pio_msk;
  201ac0:	e3a02902 	mov	r2, #32768	; 0x8000
  201ac4:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201ac8:	e3053290 	movw	r3, #21136	; 0x5290
  201acc:	e3403020 	movt	r3, #32
  201ad0:	e59d1004 	ldr	r1, [sp, #4]
  201ad4:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  201ad8:	e3051290 	movw	r1, #21136	; 0x5290
  201adc:	e3401020 	movt	r1, #32
  201ae0:	e59d3004 	ldr	r3, [sp, #4]
  201ae4:	e1a03203 	lsl	r3, r3, #4
  201ae8:	e0813003 	add	r3, r1, r3
  201aec:	e5931004 	ldr	r1, [r3, #4]
  201af0:	e2803040 	add	r3, r0, #64	; 0x40
  201af4:	e7821303 	str	r1, [r2, r3, lsl #6]
    _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_CFGR = sama_inits[i].pio_cfg;
  201af8:	e3a02902 	mov	r2, #32768	; 0x8000
  201afc:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201b00:	e3053290 	movw	r3, #21136	; 0x5290
  201b04:	e3403020 	movt	r3, #32
  201b08:	e59d1004 	ldr	r1, [sp, #4]
  201b0c:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  201b10:	e3051290 	movw	r1, #21136	; 0x5290
  201b14:	e3401020 	movt	r1, #32
  201b18:	e59d3004 	ldr	r3, [sp, #4]
  201b1c:	e1a03203 	lsl	r3, r3, #4
  201b20:	e0813003 	add	r3, r1, r3
  201b24:	e5931008 	ldr	r1, [r3, #8]
  201b28:	e2803040 	add	r3, r0, #64	; 0x40
  201b2c:	e1a03303 	lsl	r3, r3, #6
  201b30:	e0823003 	add	r3, r2, r3
  201b34:	e5831004 	str	r1, [r3, #4]
    if(sama_inits[i].pio_ods == SAMA_PIO_HIGH) {
  201b38:	e3052290 	movw	r2, #21136	; 0x5290
  201b3c:	e3402020 	movt	r2, #32
  201b40:	e59d3004 	ldr	r3, [sp, #4]
  201b44:	e1a03203 	lsl	r3, r3, #4
  201b48:	e0823003 	add	r3, r2, r3
  201b4c:	e593300c 	ldr	r3, [r3, #12]
  201b50:	e3530001 	cmp	r3, #1
  201b54:	1a000011 	bne	201ba0 <boardInit+0x320>
      _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_SODR = sama_inits[i].pio_msk;
  201b58:	e3a02902 	mov	r2, #32768	; 0x8000
  201b5c:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201b60:	e3053290 	movw	r3, #21136	; 0x5290
  201b64:	e3403020 	movt	r3, #32
  201b68:	e59d1004 	ldr	r1, [sp, #4]
  201b6c:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  201b70:	e3051290 	movw	r1, #21136	; 0x5290
  201b74:	e3401020 	movt	r1, #32
  201b78:	e59d3004 	ldr	r3, [sp, #4]
  201b7c:	e1a03203 	lsl	r3, r3, #4
  201b80:	e0813003 	add	r3, r1, r3
  201b84:	e5931004 	ldr	r1, [r3, #4]
  201b88:	e1a03300 	lsl	r3, r0, #6
  201b8c:	e0823003 	add	r3, r2, r3
  201b90:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201b94:	e2833010 	add	r3, r3, #16
  201b98:	e5831000 	str	r1, [r3]
  201b9c:	ea000010 	b	201be4 <boardInit+0x364>
    }
    else {
      _PIOA->PIO_PIO_[sama_inits[i].pio_id].S_PIO_CODR = sama_inits[i].pio_msk;
  201ba0:	e3a02902 	mov	r2, #32768	; 0x8000
  201ba4:	e34f2c03 	movt	r2, #64515	; 0xfc03
  201ba8:	e3053290 	movw	r3, #21136	; 0x5290
  201bac:	e3403020 	movt	r3, #32
  201bb0:	e59d1004 	ldr	r1, [sp, #4]
  201bb4:	e7930201 	ldr	r0, [r3, r1, lsl #4]
  201bb8:	e3051290 	movw	r1, #21136	; 0x5290
  201bbc:	e3401020 	movt	r1, #32
  201bc0:	e59d3004 	ldr	r3, [sp, #4]
  201bc4:	e1a03203 	lsl	r3, r3, #4
  201bc8:	e0813003 	add	r3, r1, r3
  201bcc:	e5931004 	ldr	r1, [r3, #4]
  201bd0:	e1a03300 	lsl	r3, r0, #6
  201bd4:	e0823003 	add	r3, r2, r3
  201bd8:	e2833a01 	add	r3, r3, #4096	; 0x1000
  201bdc:	e2833014 	add	r3, r3, #20
  201be0:	e5831000 	str	r1, [r3]
    }
    else {
      _PIOA->PIO_IO_GROUP[sama_inits[i].pio_id].PIO_CODR = sama_inits[i].pio_msk;
    }
#endif /* SAMA_HAL_IS_SECURE */
    i++;
  201be4:	e59d3004 	ldr	r3, [sp, #4]
  201be8:	e2833001 	add	r3, r3, #1
  201bec:	e58d3004 	str	r3, [sp, #4]
  _PIOA->PIO_PIO_[SAMA_PIOD].S_PIO_CFGR = SAMA_DEFAULT_CFGR;
#endif /* SAMA_HAS_PIOD */

  /* Initialize PIO registers for defined pads.*/
  i = 0;
  while (sama_inits[i].pio_id != -1) {
  201bf0:	e3053290 	movw	r3, #21136	; 0x5290
  201bf4:	e3403020 	movt	r3, #32
  201bf8:	e59d2004 	ldr	r2, [sp, #4]
  201bfc:	e7933202 	ldr	r3, [r3, r2, lsl #4]
  201c00:	e3730001 	cmn	r3, #1
  201c04:	1affff9c 	bne	201a7c <boardInit+0x1fc>
      _PIOA->PIO_IO_GROUP[sama_inits[i].pio_id].PIO_CODR = sama_inits[i].pio_msk;
    }
#endif /* SAMA_HAL_IS_SECURE */
    i++;
  }
}
  201c08:	e28dd008 	add	sp, sp, #8
  201c0c:	e12fff1e 	bx	lr

00201c10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  201c10:	e12fff1e 	bx	lr
	...

00201c20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  201c20:	e12fff1e 	bx	lr
	...

00201c30 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  201c30:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  201c34:	ebfffff5 	bl	201c10 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  201c38:	e8bd8010 	pop	{r4, pc}
  201c3c:	00000000 	andeq	r0, r0, r0

00201c40 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  201c40:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  201c44:	ebfffff5 	bl	201c20 <port_unlock_from_isr>
}
  201c48:	e8bd8010 	pop	{r4, pc}
  201c4c:	00000000 	andeq	r0, r0, r0

00201c50 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
  201c50:	e24dd008 	sub	sp, sp, #8
  201c54:	e58d0004 	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->func != NULL);
  201c58:	e59d3004 	ldr	r3, [sp, #4]
  201c5c:	e593300c 	ldr	r3, [r3, #12]
  201c60:	e3530000 	cmp	r3, #0
  201c64:	13a03001 	movne	r3, #1
  201c68:	03a03000 	moveq	r3, #0
  201c6c:	e6ef3073 	uxtb	r3, r3
}
  201c70:	e1a00003 	mov	r0, r3
  201c74:	e28dd008 	add	sp, sp, #8
  201c78:	e12fff1e 	bx	lr
  201c7c:	00000000 	andeq	r0, r0, r0

00201c80 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
  201c80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201c84:	e24dd00c 	sub	sp, sp, #12
  201c88:	e58d0004 	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
  201c8c:	e59d0004 	ldr	r0, [sp, #4]
  201c90:	ebffffee 	bl	201c50 <chVTIsArmedI>
  201c94:	e1a03000 	mov	r3, r0
  201c98:	e3530000 	cmp	r3, #0
  201c9c:	0a000001 	beq	201ca8 <chVTResetI+0x28>
    chVTDoResetI(vtp);
  201ca0:	e59d0004 	ldr	r0, [sp, #4]
  201ca4:	eb000a01 	bl	2044b0 <chVTDoResetI>
  }
}
  201ca8:	e28dd00c 	add	sp, sp, #12
  201cac:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00201cb0 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
  201cb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201cb4:	e24dd014 	sub	sp, sp, #20
  201cb8:	e58d000c 	str	r0, [sp, #12]
  201cbc:	e58d1008 	str	r1, [sp, #8]
  201cc0:	e58d2004 	str	r2, [sp, #4]
  201cc4:	e58d3000 	str	r3, [sp]

  chVTResetI(vtp);
  201cc8:	e59d000c 	ldr	r0, [sp, #12]
  201ccc:	ebffffeb 	bl	201c80 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
  201cd0:	e59d3000 	ldr	r3, [sp]
  201cd4:	e59d2004 	ldr	r2, [sp, #4]
  201cd8:	e59d1008 	ldr	r1, [sp, #8]
  201cdc:	e59d000c 	ldr	r0, [sp, #12]
  201ce0:	eb0009b2 	bl	2043b0 <chVTDoSetI>
}
  201ce4:	e28dd014 	add	sp, sp, #20
  201ce8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  201cec:	00000000 	andeq	r0, r0, r0

00201cf0 <led3off>:

static virtual_timer_t vt3, vt4, vt5;
static const uint8_t message[] = "ABCDE";
static uint8_t buffer[BUFFER_SIZE];

static void led3off(void *p) {
  201cf0:	e24dd008 	sub	sp, sp, #8
  201cf4:	e58d0004 	str	r0, [sp, #4]

  (void)p;
  palSetLine(LINE_LED_RED);
  201cf8:	e3093040 	movw	r3, #36928	; 0x9040
  201cfc:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201d00:	e3a02040 	mov	r2, #64	; 0x40
  201d04:	e5832010 	str	r2, [r3, #16]
}
  201d08:	e28dd008 	add	sp, sp, #8
  201d0c:	e12fff1e 	bx	lr

00201d10 <led4off>:

static void led4off(void *p) {
  201d10:	e24dd008 	sub	sp, sp, #8
  201d14:	e58d0004 	str	r0, [sp, #4]

  (void)p;
  palSetLine(LINE_LED_GREEN);
  201d18:	e3093040 	movw	r3, #36928	; 0x9040
  201d1c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201d20:	e3a02020 	mov	r2, #32
  201d24:	e5832010 	str	r2, [r3, #16]
}
  201d28:	e28dd008 	add	sp, sp, #8
  201d2c:	e12fff1e 	bx	lr

00201d30 <led5off>:

static void led5off(void *p) {
  201d30:	e24dd008 	sub	sp, sp, #8
  201d34:	e58d0004 	str	r0, [sp, #4]

  (void)p;
  palSetLine(LINE_LED_BLUE);
  201d38:	e3093040 	movw	r3, #36928	; 0x9040
  201d3c:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201d40:	e3a02001 	mov	r2, #1
  201d44:	e5832010 	str	r2, [r3, #16]
}
  201d48:	e28dd008 	add	sp, sp, #8
  201d4c:	e12fff1e 	bx	lr

00201d50 <txend1>:

/*
 * This callback is invoked when a transmission buffer has been completely
 * read by the driver.
 */
static void txend1(UARTDriver *uartp) {
  201d50:	e24dd008 	sub	sp, sp, #8
  201d54:	e58d0004 	str	r0, [sp, #4]

  (void)uartp;
}
  201d58:	e28dd008 	add	sp, sp, #8
  201d5c:	e12fff1e 	bx	lr

00201d60 <txend2>:

/*
 * This callback is invoked when a transmission has physically completed.
 */
static void txend2(UARTDriver *uartp) {
  201d60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201d64:	e24dd00c 	sub	sp, sp, #12
  201d68:	e58d0004 	str	r0, [sp, #4]

  (void)uartp;
  palClearLine(LINE_LED_BLUE);
  201d6c:	e3093040 	movw	r3, #36928	; 0x9040
  201d70:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201d74:	e3a02001 	mov	r2, #1
  201d78:	e5832014 	str	r2, [r3, #20]
  chSysLockFromISR();
  201d7c:	ebffffab 	bl	201c30 <chSysLockFromISR>
  chVTResetI(&vt5);
  201d80:	e3000cd0 	movw	r0, #3280	; 0xcd0
  201d84:	e3400021 	movt	r0, #33	; 0x21
  201d88:	ebffffbc 	bl	201c80 <chVTResetI>
  chVTSetI(&vt5, MS2ST(200), led5off, NULL);
  201d8c:	e3a03000 	mov	r3, #0
  201d90:	e3012d30 	movw	r2, #7472	; 0x1d30
  201d94:	e3402020 	movt	r2, #32
  201d98:	e3a010c8 	mov	r1, #200	; 0xc8
  201d9c:	e3000cd0 	movw	r0, #3280	; 0xcd0
  201da0:	e3400021 	movt	r0, #33	; 0x21
  201da4:	ebffffc1 	bl	201cb0 <chVTSetI>
  chSysUnlockFromISR();
  201da8:	ebffffa4 	bl	201c40 <chSysUnlockFromISR>
}
  201dac:	e28dd00c 	add	sp, sp, #12
  201db0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00201dc0 <rxerr>:

/*
 * This callback is invoked on a receive error, the errors mask is passed
 * as parameter.
 */
static void rxerr(UARTDriver *uartp, uartflags_t e) {
  201dc0:	e24dd008 	sub	sp, sp, #8
  201dc4:	e58d0004 	str	r0, [sp, #4]
  201dc8:	e58d1000 	str	r1, [sp]

  (void)uartp;
  (void)e;
}
  201dcc:	e28dd008 	add	sp, sp, #8
  201dd0:	e12fff1e 	bx	lr
	...

00201de0 <rxchar>:

/*
 * This callback is invoked when a character is received but the application
 * was not ready to receive it, the character is passed as parameter.
 */
static void rxchar(UARTDriver *uartp, uint16_t c) {
  201de0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201de4:	e24dd00c 	sub	sp, sp, #12
  201de8:	e58d0004 	str	r0, [sp, #4]
  201dec:	e1a03001 	mov	r3, r1
  201df0:	e1cd30b2 	strh	r3, [sp, #2]

  (void)uartp;
  (void)c;
  /* Flashing the LED each time a character is received.*/
  palClearLine(LINE_LED_GREEN);
  201df4:	e3093040 	movw	r3, #36928	; 0x9040
  201df8:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201dfc:	e3a02020 	mov	r2, #32
  201e00:	e5832014 	str	r2, [r3, #20]
  chSysLockFromISR();
  201e04:	ebffff89 	bl	201c30 <chSysLockFromISR>
  chVTResetI(&vt4);
  201e08:	e3000cbc 	movw	r0, #3260	; 0xcbc
  201e0c:	e3400021 	movt	r0, #33	; 0x21
  201e10:	ebffff9a 	bl	201c80 <chVTResetI>
  chVTSetI(&vt4, MS2ST(200), led4off, NULL);
  201e14:	e3a03000 	mov	r3, #0
  201e18:	e3012d10 	movw	r2, #7440	; 0x1d10
  201e1c:	e3402020 	movt	r2, #32
  201e20:	e3a010c8 	mov	r1, #200	; 0xc8
  201e24:	e3000cbc 	movw	r0, #3260	; 0xcbc
  201e28:	e3400021 	movt	r0, #33	; 0x21
  201e2c:	ebffff9f 	bl	201cb0 <chVTSetI>
  chSysUnlockFromISR();
  201e30:	ebffff82 	bl	201c40 <chSysUnlockFromISR>
}
  201e34:	e28dd00c 	add	sp, sp, #12
  201e38:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  201e3c:	00000000 	andeq	r0, r0, r0

00201e40 <rxend>:

/*
 * This callback is invoked when a receive buffer has been completely written.
 */
static void rxend(UARTDriver *uartp) {
  201e40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201e44:	e24dd00c 	sub	sp, sp, #12
  201e48:	e58d0004 	str	r0, [sp, #4]

  (void)uartp;

  palClearLine(LINE_LED_RED);
  201e4c:	e3093040 	movw	r3, #36928	; 0x9040
  201e50:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201e54:	e3a02040 	mov	r2, #64	; 0x40
  201e58:	e5832014 	str	r2, [r3, #20]
  chSysLockFromISR();
  201e5c:	ebffff73 	bl	201c30 <chSysLockFromISR>
  chVTResetI(&vt3);
  201e60:	e3000ca8 	movw	r0, #3240	; 0xca8
  201e64:	e3400021 	movt	r0, #33	; 0x21
  201e68:	ebffff84 	bl	201c80 <chVTResetI>
  chVTSetI(&vt3, MS2ST(200), led3off, NULL);
  201e6c:	e3a03000 	mov	r3, #0
  201e70:	e3012cf0 	movw	r2, #7408	; 0x1cf0
  201e74:	e3402020 	movt	r2, #32
  201e78:	e3a010c8 	mov	r1, #200	; 0xc8
  201e7c:	e3000ca8 	movw	r0, #3240	; 0xca8
  201e80:	e3400021 	movt	r0, #33	; 0x21
  201e84:	ebffff89 	bl	201cb0 <chVTSetI>
  chSysUnlockFromISR();
  201e88:	ebffff6c 	bl	201c40 <chSysUnlockFromISR>
}
  201e8c:	e28dd00c 	add	sp, sp, #12
  201e90:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00201ea0 <main>:
};

/*
 * Application entry point.
 */
int main(void) {
  201ea0:	e92d4010 	push	{r4, lr}
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */

  halInit();
  201ea4:	eb000721 	bl	203b30 <halInit>
  chSysInit();
  201ea8:	eb0008f4 	bl	204280 <chSysInit>

  /*
   * Activates the flexcom uart driver 0, PB28(RX) and PB29(RX) are routed to FLEXCOM0.
   */
  uartStart(&FUARTD0, &uart_cfg_1);
  201eac:	e3001858 	movw	r1, #2136	; 0x858
  201eb0:	e3401021 	movt	r1, #33	; 0x21
  201eb4:	e3000c74 	movw	r0, #3188	; 0xc74
  201eb8:	e3400021 	movt	r0, #33	; 0x21
  201ebc:	eb0002fb 	bl	202ab0 <uartStart>

  /*
   * Activates the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
  201ec0:	e3a01000 	mov	r1, #0
  201ec4:	e3000bf0 	movw	r0, #3056	; 0xbf0
  201ec8:	e3400021 	movt	r0, #33	; 0x21
  201ecc:	eb00029b 	bl	202940 <sdStart>

  /* Redirecting  SERIAL RX on PB26 and UART0 TX on PB27. */
  palSetGroupMode(PIOB, PAL_PORT_BIT(26) | PAL_PORT_BIT(27), 0U,
  201ed0:	e3a0210e 	mov	r2, #-2147483645	; 0x80000003
  201ed4:	e3a01303 	mov	r1, #201326592	; 0xc000000
  201ed8:	e3090040 	movw	r0, #36928	; 0x9040
  201edc:	e34f0c03 	movt	r0, #64515	; 0xfc03
  201ee0:	eb000696 	bl	203940 <_pal_lld_setgroupmode>
                  PAL_SAMA_FUNC_PERIPH_C | PAL_MODE_SECURE);

  /* Redirecting  UART FLEXCOM0 RX on PB28 and UART FLEXCOM0 TX on PB29. */
  palSetGroupMode(PIOB, PAL_PORT_BIT(28) | PAL_PORT_BIT(29), 0U,
  201ee4:	e3a0210e 	mov	r2, #-2147483645	; 0x80000003
  201ee8:	e3a01203 	mov	r1, #805306368	; 0x30000000
  201eec:	e3090040 	movw	r0, #36928	; 0x9040
  201ef0:	e34f0c03 	movt	r0, #64515	; 0xfc03
  201ef4:	eb000691 	bl	203940 <_pal_lld_setgroupmode>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * increasing the minutes counter.
   */
  while (true) {
    if (!palReadPad(PIOB, PIOB_USER_PB)) {
  201ef8:	e3093040 	movw	r3, #36928	; 0x9040
  201efc:	e34f3c03 	movt	r3, #64515	; 0xfc03
  201f00:	e5933008 	ldr	r3, [r3, #8]
  201f04:	e1a034a3 	lsr	r3, r3, #9
  201f08:	e2033001 	and	r3, r3, #1
  201f0c:	e3530000 	cmp	r3, #0
  201f10:	1a000011 	bne	201f5c <main+0xbc>
  /*
   * Starts both a transmission and a receive operations, both will be
   * handled entirely in background.
   */
      uartStopReceive(&FUARTD0);
  201f14:	e3000c74 	movw	r0, #3188	; 0xc74
  201f18:	e3400021 	movt	r0, #33	; 0x21
  201f1c:	eb00032b 	bl	202bd0 <uartStopReceive>
      uartStopSend(&FUARTD0);
  201f20:	e3000c74 	movw	r0, #3188	; 0xc74
  201f24:	e3400021 	movt	r0, #33	; 0x21
  201f28:	eb000300 	bl	202b30 <uartStopSend>
      uartStartReceive(&FUARTD0, BUFFER_SIZE, buffer);
  201f2c:	e3002ce4 	movw	r2, #3300	; 0xce4
  201f30:	e3402021 	movt	r2, #33	; 0x21
  201f34:	e3a01005 	mov	r1, #5
  201f38:	e3000c74 	movw	r0, #3188	; 0xc74
  201f3c:	e3400021 	movt	r0, #33	; 0x21
  201f40:	eb000312 	bl	202b90 <uartStartReceive>
      uartStartSend(&FUARTD0, BUFFER_SIZE, message);
  201f44:	e30522c0 	movw	r2, #21184	; 0x52c0
  201f48:	e3402020 	movt	r2, #32
  201f4c:	e3a01005 	mov	r1, #5
  201f50:	e3000c74 	movw	r0, #3188	; 0xc74
  201f54:	e3400021 	movt	r0, #33	; 0x21
  201f58:	eb0002e4 	bl	202af0 <uartStartSend>
    }
    chThdSleepMilliseconds(500);
  201f5c:	e3a00f7d 	mov	r0, #500	; 0x1f4
  201f60:	eb000c2e 	bl	205020 <chThdSleep>
  201f64:	eaffffe3 	b	201ef8 <main+0x58>
	...

00201f70 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
  201f70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  201f74:	e24dd014 	sub	sp, sp, #20
  201f78:	e58d0004 	str	r0, [sp, #4]
  201f7c:	e58d1000 	str	r1, [sp]
  uint8_t b;

  osalSysLock();
  201f80:	eb000722 	bl	203c10 <osalSysLock.lto_priv.26>
  201f84:	ea00000a 	b	201fb4 <iqGetTimeout+0x44>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
  201f88:	e59d3004 	ldr	r3, [sp, #4]
  201f8c:	e59d1000 	ldr	r1, [sp]
  201f90:	e1a00003 	mov	r0, r3
  201f94:	eb000735 	bl	203c70 <osalThreadEnqueueTimeoutS.lto_priv.38>
  201f98:	e58d000c 	str	r0, [sp, #12]
    if (msg < MSG_OK) {
  201f9c:	e59d300c 	ldr	r3, [sp, #12]
  201fa0:	e3530000 	cmp	r3, #0
  201fa4:	aa000002 	bge	201fb4 <iqGetTimeout+0x44>
      osalSysUnlock();
  201fa8:	eb00071c 	bl	203c20 <osalSysUnlock.lto_priv.23>
      return msg;
  201fac:	e59d300c 	ldr	r3, [sp, #12]
  201fb0:	ea000023 	b	202044 <iqGetTimeout+0xd4>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
  201fb4:	e59d3004 	ldr	r3, [sp, #4]
  201fb8:	e5933008 	ldr	r3, [r3, #8]
  201fbc:	e3530000 	cmp	r3, #0
  201fc0:	0afffff0 	beq	201f88 <iqGetTimeout+0x18>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  201fc4:	e59d3004 	ldr	r3, [sp, #4]
  201fc8:	e5933008 	ldr	r3, [r3, #8]
  201fcc:	e2432001 	sub	r2, r3, #1
  201fd0:	e59d3004 	ldr	r3, [sp, #4]
  201fd4:	e5832008 	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
  201fd8:	e59d3004 	ldr	r3, [sp, #4]
  201fdc:	e5933018 	ldr	r3, [r3, #24]
  201fe0:	e2831001 	add	r1, r3, #1
  201fe4:	e59d2004 	ldr	r2, [sp, #4]
  201fe8:	e5821018 	str	r1, [r2, #24]
  201fec:	e5d33000 	ldrb	r3, [r3]
  201ff0:	e5cd300b 	strb	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
  201ff4:	e59d3004 	ldr	r3, [sp, #4]
  201ff8:	e5932018 	ldr	r2, [r3, #24]
  201ffc:	e59d3004 	ldr	r3, [sp, #4]
  202000:	e5933010 	ldr	r3, [r3, #16]
  202004:	e1520003 	cmp	r2, r3
  202008:	3a000003 	bcc	20201c <iqGetTimeout+0xac>
    iqp->q_rdptr = iqp->q_buffer;
  20200c:	e59d3004 	ldr	r3, [sp, #4]
  202010:	e593200c 	ldr	r2, [r3, #12]
  202014:	e59d3004 	ldr	r3, [sp, #4]
  202018:	e5832018 	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
  20201c:	e59d3004 	ldr	r3, [sp, #4]
  202020:	e593301c 	ldr	r3, [r3, #28]
  202024:	e3530000 	cmp	r3, #0
  202028:	0a000003 	beq	20203c <iqGetTimeout+0xcc>
    iqp->q_notify(iqp);
  20202c:	e59d3004 	ldr	r3, [sp, #4]
  202030:	e593301c 	ldr	r3, [r3, #28]
  202034:	e59d0004 	ldr	r0, [sp, #4]
  202038:	e12fff33 	blx	r3
  }

  osalSysUnlock();
  20203c:	eb0006f7 	bl	203c20 <osalSysUnlock.lto_priv.23>

  return (msg_t)b;
  202040:	e5dd300b 	ldrb	r3, [sp, #11]
}
  202044:	e1a00003 	mov	r0, r3
  202048:	e28dd014 	add	sp, sp, #20
  20204c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202050 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  202050:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202054:	e24dd02c 	sub	sp, sp, #44	; 0x2c
  202058:	e58d000c 	str	r0, [sp, #12]
  20205c:	e58d1008 	str	r1, [sp, #8]
  202060:	e58d2004 	str	r2, [sp, #4]
  202064:	e58d3000 	str	r3, [sp]
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  202068:	e59d300c 	ldr	r3, [sp, #12]
  20206c:	e593301c 	ldr	r3, [r3, #28]
  202070:	e58d301c 	str	r3, [sp, #28]
  size_t r = 0;
  202074:	e3a03000 	mov	r3, #0
  202078:	e58d3024 	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
  20207c:	eb0006e3 	bl	203c10 <osalSysLock.lto_priv.26>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
  202080:	eb0006ea 	bl	203c30 <osalOsGetSystemTimeX.lto_priv.39>
  202084:	e1a02000 	mov	r2, r0
  202088:	e59d3000 	ldr	r3, [sp]
  20208c:	e0823003 	add	r3, r2, r3
  202090:	e58d3018 	str	r3, [sp, #24]
  202094:	ea000022 	b	202124 <iqReadTimeout+0xd4>
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202098:	e59d3000 	ldr	r3, [sp]
  20209c:	e3730001 	cmn	r3, #1
  2020a0:	0a000002 	beq	2020b0 <iqReadTimeout+0x60>
  2020a4:	e59d3000 	ldr	r3, [sp]
  2020a8:	e3530000 	cmp	r3, #0
  2020ac:	1a000005 	bne	2020c8 <iqReadTimeout+0x78>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
  2020b0:	e59d300c 	ldr	r3, [sp, #12]
  2020b4:	e59d1000 	ldr	r1, [sp]
  2020b8:	e1a00003 	mov	r0, r3
  2020bc:	eb0006eb 	bl	203c70 <osalThreadEnqueueTimeoutS.lto_priv.38>
  2020c0:	e58d0020 	str	r0, [sp, #32]
  2020c4:	ea000010 	b	20210c <iqReadTimeout+0xbc>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
  2020c8:	eb0006d8 	bl	203c30 <osalOsGetSystemTimeX.lto_priv.39>
  2020cc:	e1a02000 	mov	r2, r0
  2020d0:	e59d3018 	ldr	r3, [sp, #24]
  2020d4:	e0623003 	rsb	r3, r2, r3
  2020d8:	e58d3014 	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
  2020dc:	e59d2014 	ldr	r2, [sp, #20]
  2020e0:	e59d3000 	ldr	r3, [sp]
  2020e4:	e1520003 	cmp	r2, r3
  2020e8:	9a000002 	bls	2020f8 <iqReadTimeout+0xa8>
          osalSysUnlock();
  2020ec:	eb0006cb 	bl	203c20 <osalSysUnlock.lto_priv.23>
          return r;
  2020f0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  2020f4:	ea00003b 	b	2021e8 <iqReadTimeout+0x198>
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
  2020f8:	e59d300c 	ldr	r3, [sp, #12]
  2020fc:	e59d1014 	ldr	r1, [sp, #20]
  202100:	e1a00003 	mov	r0, r3
  202104:	eb0006d9 	bl	203c70 <osalThreadEnqueueTimeoutS.lto_priv.38>
  202108:	e58d0020 	str	r0, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  20210c:	e59d3020 	ldr	r3, [sp, #32]
  202110:	e3530000 	cmp	r3, #0
  202114:	0a000002 	beq	202124 <iqReadTimeout+0xd4>
        osalSysUnlock();
  202118:	eb0006c0 	bl	203c20 <osalSysUnlock.lto_priv.23>
        return r;
  20211c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202120:	ea000030 	b	2021e8 <iqReadTimeout+0x198>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
  202124:	e59d300c 	ldr	r3, [sp, #12]
  202128:	e5933008 	ldr	r3, [r3, #8]
  20212c:	e3530000 	cmp	r3, #0
  202130:	0affffd8 	beq	202098 <iqReadTimeout+0x48>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
  202134:	e59d300c 	ldr	r3, [sp, #12]
  202138:	e5933008 	ldr	r3, [r3, #8]
  20213c:	e2432001 	sub	r2, r3, #1
  202140:	e59d300c 	ldr	r3, [sp, #12]
  202144:	e5832008 	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
  202148:	e59d3008 	ldr	r3, [sp, #8]
  20214c:	e2832001 	add	r2, r3, #1
  202150:	e58d2008 	str	r2, [sp, #8]
  202154:	e59d200c 	ldr	r2, [sp, #12]
  202158:	e5922018 	ldr	r2, [r2, #24]
  20215c:	e2820001 	add	r0, r2, #1
  202160:	e59d100c 	ldr	r1, [sp, #12]
  202164:	e5810018 	str	r0, [r1, #24]
  202168:	e5d22000 	ldrb	r2, [r2]
  20216c:	e5c32000 	strb	r2, [r3]
    if (iqp->q_rdptr >= iqp->q_top) {
  202170:	e59d300c 	ldr	r3, [sp, #12]
  202174:	e5932018 	ldr	r2, [r3, #24]
  202178:	e59d300c 	ldr	r3, [sp, #12]
  20217c:	e5933010 	ldr	r3, [r3, #16]
  202180:	e1520003 	cmp	r2, r3
  202184:	3a000003 	bcc	202198 <iqReadTimeout+0x148>
      iqp->q_rdptr = iqp->q_buffer;
  202188:	e59d300c 	ldr	r3, [sp, #12]
  20218c:	e593200c 	ldr	r2, [r3, #12]
  202190:	e59d300c 	ldr	r3, [sp, #12]
  202194:	e5832018 	str	r2, [r3, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
  202198:	e59d301c 	ldr	r3, [sp, #28]
  20219c:	e3530000 	cmp	r3, #0
  2021a0:	0a000002 	beq	2021b0 <iqReadTimeout+0x160>
      nfy(iqp);
  2021a4:	e59d301c 	ldr	r3, [sp, #28]
  2021a8:	e59d000c 	ldr	r0, [sp, #12]
  2021ac:	e12fff33 	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
  2021b0:	eb00069a 	bl	203c20 <osalSysUnlock.lto_priv.23>

    r++;
  2021b4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  2021b8:	e2833001 	add	r3, r3, #1
  2021bc:	e58d3024 	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
  2021c0:	e59d3004 	ldr	r3, [sp, #4]
  2021c4:	e2433001 	sub	r3, r3, #1
  2021c8:	e58d3004 	str	r3, [sp, #4]
  2021cc:	e59d3004 	ldr	r3, [sp, #4]
  2021d0:	e3530000 	cmp	r3, #0
  2021d4:	1a000001 	bne	2021e0 <iqReadTimeout+0x190>
      return r;
  2021d8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  2021dc:	ea000001 	b	2021e8 <iqReadTimeout+0x198>
    }

    osalSysLock();
  2021e0:	eb00068a 	bl	203c10 <osalSysLock.lto_priv.26>
  2021e4:	eaffffce 	b	202124 <iqReadTimeout+0xd4>
  }
}
  2021e8:	e1a00003 	mov	r0, r3
  2021ec:	e28dd02c 	add	sp, sp, #44	; 0x2c
  2021f0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202200 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
  202200:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202204:	e24dd014 	sub	sp, sp, #20
  202208:	e58d000c 	str	r0, [sp, #12]
  20220c:	e58d1008 	str	r1, [sp, #8]
  202210:	e58d2004 	str	r2, [sp, #4]
  202214:	e58d3000 	str	r3, [sp]

  osalThreadQueueObjectInit(&oqp->q_waiting);
  202218:	e59d300c 	ldr	r3, [sp, #12]
  20221c:	e1a00003 	mov	r0, r3
  202220:	eb00068a 	bl	203c50 <osalThreadQueueObjectInit.lto_priv.42>
  oqp->q_counter = size;
  202224:	e59d300c 	ldr	r3, [sp, #12]
  202228:	e59d2004 	ldr	r2, [sp, #4]
  20222c:	e5832008 	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
  202230:	e59d300c 	ldr	r3, [sp, #12]
  202234:	e59d2008 	ldr	r2, [sp, #8]
  202238:	e583200c 	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
  20223c:	e59d300c 	ldr	r3, [sp, #12]
  202240:	e59d2008 	ldr	r2, [sp, #8]
  202244:	e5832018 	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
  202248:	e59d300c 	ldr	r3, [sp, #12]
  20224c:	e59d2008 	ldr	r2, [sp, #8]
  202250:	e5832014 	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
  202254:	e59d2008 	ldr	r2, [sp, #8]
  202258:	e59d3004 	ldr	r3, [sp, #4]
  20225c:	e0822003 	add	r2, r2, r3
  202260:	e59d300c 	ldr	r3, [sp, #12]
  202264:	e5832010 	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
  202268:	e59d300c 	ldr	r3, [sp, #12]
  20226c:	e59d2000 	ldr	r2, [sp]
  202270:	e583201c 	str	r2, [r3, #28]
  oqp->q_link    = link;
  202274:	e59d300c 	ldr	r3, [sp, #12]
  202278:	e59d2018 	ldr	r2, [sp, #24]
  20227c:	e5832020 	str	r2, [r3, #32]
}
  202280:	e28dd014 	add	sp, sp, #20
  202284:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202290 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
  202290:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202294:	e24dd01c 	sub	sp, sp, #28
  202298:	e58d000c 	str	r0, [sp, #12]
  20229c:	e1a03001 	mov	r3, r1
  2022a0:	e58d2004 	str	r2, [sp, #4]
  2022a4:	e5cd300b 	strb	r3, [sp, #11]

  osalSysLock();
  2022a8:	eb000658 	bl	203c10 <osalSysLock.lto_priv.26>
  2022ac:	ea00000a 	b	2022dc <oqPutTimeout+0x4c>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
  2022b0:	e59d300c 	ldr	r3, [sp, #12]
  2022b4:	e59d1004 	ldr	r1, [sp, #4]
  2022b8:	e1a00003 	mov	r0, r3
  2022bc:	eb00066b 	bl	203c70 <osalThreadEnqueueTimeoutS.lto_priv.38>
  2022c0:	e58d0014 	str	r0, [sp, #20]
    if (msg < MSG_OK) {
  2022c4:	e59d3014 	ldr	r3, [sp, #20]
  2022c8:	e3530000 	cmp	r3, #0
  2022cc:	aa000002 	bge	2022dc <oqPutTimeout+0x4c>
      osalSysUnlock();
  2022d0:	eb000652 	bl	203c20 <osalSysUnlock.lto_priv.23>
      return msg;
  2022d4:	e59d3014 	ldr	r3, [sp, #20]
  2022d8:	ea000023 	b	20236c <oqPutTimeout+0xdc>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
  2022dc:	e59d300c 	ldr	r3, [sp, #12]
  2022e0:	e5933008 	ldr	r3, [r3, #8]
  2022e4:	e3530000 	cmp	r3, #0
  2022e8:	0afffff0 	beq	2022b0 <oqPutTimeout+0x20>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  2022ec:	e59d300c 	ldr	r3, [sp, #12]
  2022f0:	e5933008 	ldr	r3, [r3, #8]
  2022f4:	e2432001 	sub	r2, r3, #1
  2022f8:	e59d300c 	ldr	r3, [sp, #12]
  2022fc:	e5832008 	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
  202300:	e59d300c 	ldr	r3, [sp, #12]
  202304:	e5933014 	ldr	r3, [r3, #20]
  202308:	e2831001 	add	r1, r3, #1
  20230c:	e59d200c 	ldr	r2, [sp, #12]
  202310:	e5821014 	str	r1, [r2, #20]
  202314:	e5dd200b 	ldrb	r2, [sp, #11]
  202318:	e5c32000 	strb	r2, [r3]
  if (oqp->q_wrptr >= oqp->q_top) {
  20231c:	e59d300c 	ldr	r3, [sp, #12]
  202320:	e5932014 	ldr	r2, [r3, #20]
  202324:	e59d300c 	ldr	r3, [sp, #12]
  202328:	e5933010 	ldr	r3, [r3, #16]
  20232c:	e1520003 	cmp	r2, r3
  202330:	3a000003 	bcc	202344 <oqPutTimeout+0xb4>
    oqp->q_wrptr = oqp->q_buffer;
  202334:	e59d300c 	ldr	r3, [sp, #12]
  202338:	e593200c 	ldr	r2, [r3, #12]
  20233c:	e59d300c 	ldr	r3, [sp, #12]
  202340:	e5832014 	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
  202344:	e59d300c 	ldr	r3, [sp, #12]
  202348:	e593301c 	ldr	r3, [r3, #28]
  20234c:	e3530000 	cmp	r3, #0
  202350:	0a000003 	beq	202364 <oqPutTimeout+0xd4>
    oqp->q_notify(oqp);
  202354:	e59d300c 	ldr	r3, [sp, #12]
  202358:	e593301c 	ldr	r3, [r3, #28]
  20235c:	e59d000c 	ldr	r0, [sp, #12]
  202360:	e12fff33 	blx	r3
  }

  osalSysUnlock();
  202364:	eb00062d 	bl	203c20 <osalSysUnlock.lto_priv.23>

  return MSG_OK;
  202368:	e3a03000 	mov	r3, #0
}
  20236c:	e1a00003 	mov	r0, r3
  202370:	e28dd01c 	add	sp, sp, #28
  202374:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202380 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
  202380:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202384:	e24dd014 	sub	sp, sp, #20
  202388:	e58d0004 	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
  20238c:	e59d3004 	ldr	r3, [sp, #4]
  202390:	e5932014 	ldr	r2, [r3, #20]
  202394:	e59d3004 	ldr	r3, [sp, #4]
  202398:	e5933018 	ldr	r3, [r3, #24]
  20239c:	e1520003 	cmp	r2, r3
  2023a0:	1a000005 	bne	2023bc <oqGetI+0x3c>
  2023a4:	e59d3004 	ldr	r3, [sp, #4]
  2023a8:	e5933008 	ldr	r3, [r3, #8]
  2023ac:	e3530000 	cmp	r3, #0
  2023b0:	0a000001 	beq	2023bc <oqGetI+0x3c>
  2023b4:	e3a03001 	mov	r3, #1
  2023b8:	ea000000 	b	2023c0 <oqGetI+0x40>
  2023bc:	e3a03000 	mov	r3, #0
  2023c0:	e2033001 	and	r3, r3, #1
  2023c4:	e3530000 	cmp	r3, #0
  2023c8:	0a000001 	beq	2023d4 <oqGetI+0x54>
    return MSG_TIMEOUT;
  2023cc:	e3e03000 	mvn	r3, #0
  2023d0:	ea00001a 	b	202440 <oqGetI+0xc0>
  }

  oqp->q_counter++;
  2023d4:	e59d3004 	ldr	r3, [sp, #4]
  2023d8:	e5933008 	ldr	r3, [r3, #8]
  2023dc:	e2832001 	add	r2, r3, #1
  2023e0:	e59d3004 	ldr	r3, [sp, #4]
  2023e4:	e5832008 	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
  2023e8:	e59d3004 	ldr	r3, [sp, #4]
  2023ec:	e5933018 	ldr	r3, [r3, #24]
  2023f0:	e2831001 	add	r1, r3, #1
  2023f4:	e59d2004 	ldr	r2, [sp, #4]
  2023f8:	e5821018 	str	r1, [r2, #24]
  2023fc:	e5d33000 	ldrb	r3, [r3]
  202400:	e5cd300f 	strb	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
  202404:	e59d3004 	ldr	r3, [sp, #4]
  202408:	e5932018 	ldr	r2, [r3, #24]
  20240c:	e59d3004 	ldr	r3, [sp, #4]
  202410:	e5933010 	ldr	r3, [r3, #16]
  202414:	e1520003 	cmp	r2, r3
  202418:	3a000003 	bcc	20242c <oqGetI+0xac>
    oqp->q_rdptr = oqp->q_buffer;
  20241c:	e59d3004 	ldr	r3, [sp, #4]
  202420:	e593200c 	ldr	r2, [r3, #12]
  202424:	e59d3004 	ldr	r3, [sp, #4]
  202428:	e5832018 	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
  20242c:	e59d3004 	ldr	r3, [sp, #4]
  202430:	e3a01000 	mov	r1, #0
  202434:	e1a00003 	mov	r0, r3
  202438:	eb000618 	bl	203ca0 <osalThreadDequeueNextI.lto_priv.40>

  return (msg_t)b;
  20243c:	e5dd300f 	ldrb	r3, [sp, #15]
}
  202440:	e1a00003 	mov	r0, r3
  202444:	e28dd014 	add	sp, sp, #20
  202448:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20244c:	00000000 	andeq	r0, r0, r0

00202450 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  202450:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202454:	e24dd02c 	sub	sp, sp, #44	; 0x2c
  202458:	e58d000c 	str	r0, [sp, #12]
  20245c:	e58d1008 	str	r1, [sp, #8]
  202460:	e58d2004 	str	r2, [sp, #4]
  202464:	e58d3000 	str	r3, [sp]
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  202468:	e59d300c 	ldr	r3, [sp, #12]
  20246c:	e593301c 	ldr	r3, [r3, #28]
  202470:	e58d301c 	str	r3, [sp, #28]
  size_t w = 0;
  202474:	e3a03000 	mov	r3, #0
  202478:	e58d3024 	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
  20247c:	eb0005e3 	bl	203c10 <osalSysLock.lto_priv.26>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
  202480:	eb0005ea 	bl	203c30 <osalOsGetSystemTimeX.lto_priv.39>
  202484:	e1a02000 	mov	r2, r0
  202488:	e59d3000 	ldr	r3, [sp]
  20248c:	e0823003 	add	r3, r2, r3
  202490:	e58d3018 	str	r3, [sp, #24]
  202494:	ea000022 	b	202524 <oqWriteTimeout+0xd4>
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202498:	e59d3000 	ldr	r3, [sp]
  20249c:	e3730001 	cmn	r3, #1
  2024a0:	0a000002 	beq	2024b0 <oqWriteTimeout+0x60>
  2024a4:	e59d3000 	ldr	r3, [sp]
  2024a8:	e3530000 	cmp	r3, #0
  2024ac:	1a000005 	bne	2024c8 <oqWriteTimeout+0x78>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
  2024b0:	e59d300c 	ldr	r3, [sp, #12]
  2024b4:	e59d1000 	ldr	r1, [sp]
  2024b8:	e1a00003 	mov	r0, r3
  2024bc:	eb0005eb 	bl	203c70 <osalThreadEnqueueTimeoutS.lto_priv.38>
  2024c0:	e58d0020 	str	r0, [sp, #32]
  2024c4:	ea000010 	b	20250c <oqWriteTimeout+0xbc>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
  2024c8:	eb0005d8 	bl	203c30 <osalOsGetSystemTimeX.lto_priv.39>
  2024cc:	e1a02000 	mov	r2, r0
  2024d0:	e59d3018 	ldr	r3, [sp, #24]
  2024d4:	e0623003 	rsb	r3, r2, r3
  2024d8:	e58d3014 	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
  2024dc:	e59d2014 	ldr	r2, [sp, #20]
  2024e0:	e59d3000 	ldr	r3, [sp]
  2024e4:	e1520003 	cmp	r2, r3
  2024e8:	9a000002 	bls	2024f8 <oqWriteTimeout+0xa8>
          osalSysUnlock();
  2024ec:	eb0005cb 	bl	203c20 <osalSysUnlock.lto_priv.23>
          return w;
  2024f0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  2024f4:	ea00003b 	b	2025e8 <oqWriteTimeout+0x198>
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
  2024f8:	e59d300c 	ldr	r3, [sp, #12]
  2024fc:	e59d1014 	ldr	r1, [sp, #20]
  202500:	e1a00003 	mov	r0, r3
  202504:	eb0005d9 	bl	203c70 <osalThreadEnqueueTimeoutS.lto_priv.38>
  202508:	e58d0020 	str	r0, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  20250c:	e59d3020 	ldr	r3, [sp, #32]
  202510:	e3530000 	cmp	r3, #0
  202514:	0a000002 	beq	202524 <oqWriteTimeout+0xd4>
        osalSysUnlock();
  202518:	eb0005c0 	bl	203c20 <osalSysUnlock.lto_priv.23>
        return w;
  20251c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  202520:	ea000030 	b	2025e8 <oqWriteTimeout+0x198>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
  202524:	e59d300c 	ldr	r3, [sp, #12]
  202528:	e5933008 	ldr	r3, [r3, #8]
  20252c:	e3530000 	cmp	r3, #0
  202530:	0affffd8 	beq	202498 <oqWriteTimeout+0x48>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
  202534:	e59d300c 	ldr	r3, [sp, #12]
  202538:	e5933008 	ldr	r3, [r3, #8]
  20253c:	e2432001 	sub	r2, r3, #1
  202540:	e59d300c 	ldr	r3, [sp, #12]
  202544:	e5832008 	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
  202548:	e59d300c 	ldr	r3, [sp, #12]
  20254c:	e5933014 	ldr	r3, [r3, #20]
  202550:	e2831001 	add	r1, r3, #1
  202554:	e59d200c 	ldr	r2, [sp, #12]
  202558:	e5821014 	str	r1, [r2, #20]
  20255c:	e59d2008 	ldr	r2, [sp, #8]
  202560:	e2821001 	add	r1, r2, #1
  202564:	e58d1008 	str	r1, [sp, #8]
  202568:	e5d22000 	ldrb	r2, [r2]
  20256c:	e5c32000 	strb	r2, [r3]
    if (oqp->q_wrptr >= oqp->q_top) {
  202570:	e59d300c 	ldr	r3, [sp, #12]
  202574:	e5932014 	ldr	r2, [r3, #20]
  202578:	e59d300c 	ldr	r3, [sp, #12]
  20257c:	e5933010 	ldr	r3, [r3, #16]
  202580:	e1520003 	cmp	r2, r3
  202584:	3a000003 	bcc	202598 <oqWriteTimeout+0x148>
      oqp->q_wrptr = oqp->q_buffer;
  202588:	e59d300c 	ldr	r3, [sp, #12]
  20258c:	e593200c 	ldr	r2, [r3, #12]
  202590:	e59d300c 	ldr	r3, [sp, #12]
  202594:	e5832014 	str	r2, [r3, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
  202598:	e59d301c 	ldr	r3, [sp, #28]
  20259c:	e3530000 	cmp	r3, #0
  2025a0:	0a000002 	beq	2025b0 <oqWriteTimeout+0x160>
      nfy(oqp);
  2025a4:	e59d301c 	ldr	r3, [sp, #28]
  2025a8:	e59d000c 	ldr	r0, [sp, #12]
  2025ac:	e12fff33 	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
  2025b0:	eb00059a 	bl	203c20 <osalSysUnlock.lto_priv.23>

    w++;
  2025b4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  2025b8:	e2833001 	add	r3, r3, #1
  2025bc:	e58d3024 	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
  2025c0:	e59d3004 	ldr	r3, [sp, #4]
  2025c4:	e2433001 	sub	r3, r3, #1
  2025c8:	e58d3004 	str	r3, [sp, #4]
  2025cc:	e59d3004 	ldr	r3, [sp, #4]
  2025d0:	e3530000 	cmp	r3, #0
  2025d4:	1a000001 	bne	2025e0 <oqWriteTimeout+0x190>
      return w;
  2025d8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  2025dc:	ea000001 	b	2025e8 <oqWriteTimeout+0x198>
    }

    osalSysLock();
  2025e0:	eb00058a 	bl	203c10 <osalSysLock.lto_priv.26>
  2025e4:	eaffffce 	b	202524 <oqWriteTimeout+0xd4>
  }
}
  2025e8:	e1a00003 	mov	r0, r3
  2025ec:	e28dd02c 	add	sp, sp, #44	; 0x2c
  2025f0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202600 <port_lock.lto_priv.35>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  202600:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  202604:	e12fff1e 	bx	lr
	...

00202610 <port_unlock.lto_priv.33>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  202610:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  202614:	e12fff1e 	bx	lr
	...

00202620 <chSysLock.lto_priv.31>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  202620:	e92d4010 	push	{r4, lr}

  port_lock();
  202624:	ebfffff5 	bl	202600 <port_lock.lto_priv.35>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  202628:	e8bd8010 	pop	{r4, pc}
  20262c:	00000000 	andeq	r0, r0, r0

00202630 <chSysUnlock.lto_priv.29>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  202630:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  202634:	ebfffff5 	bl	202610 <port_unlock.lto_priv.33>
}
  202638:	e8bd8010 	pop	{r4, pc}
  20263c:	00000000 	andeq	r0, r0, r0

00202640 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
  202640:	e24dd008 	sub	sp, sp, #8
  202644:	e58d0004 	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
  202648:	e59d3004 	ldr	r3, [sp, #4]
  20264c:	e59d2004 	ldr	r2, [sp, #4]
  202650:	e5832000 	str	r2, [r3]
}
  202654:	e28dd008 	add	sp, sp, #8
  202658:	e12fff1e 	bx	lr
  20265c:	00000000 	andeq	r0, r0, r0

00202660 <osalSysLock.lto_priv.27>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
  202660:	e92d4010 	push	{r4, lr}

  chSysLock();
  202664:	ebffffed 	bl	202620 <chSysLock.lto_priv.31>
}
  202668:	e8bd8010 	pop	{r4, pc}
  20266c:	00000000 	andeq	r0, r0, r0

00202670 <osalSysUnlock.lto_priv.24>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
  202670:	e92d4010 	push	{r4, lr}

  chSysUnlock();
  202674:	ebffffed 	bl	202630 <chSysUnlock.lto_priv.29>
}
  202678:	e8bd8010 	pop	{r4, pc}
  20267c:	00000000 	andeq	r0, r0, r0

00202680 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
  202680:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202684:	e24dd00c 	sub	sp, sp, #12
  202688:	e58d0004 	str	r0, [sp, #4]

  chEvtObjectInit(esp);
  20268c:	e59d0004 	ldr	r0, [sp, #4]
  202690:	ebffffea 	bl	202640 <chEvtObjectInit>
}
  202694:	e28dd00c 	add	sp, sp, #12
  202698:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20269c:	00000000 	andeq	r0, r0, r0

002026a0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
  2026a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2026a4:	e24dd00c 	sub	sp, sp, #12
  2026a8:	e58d0004 	str	r0, [sp, #4]
  2026ac:	e58d1000 	str	r1, [sp]

  chEvtBroadcastFlagsI(esp, flags);
  2026b0:	e59d1000 	ldr	r1, [sp]
  2026b4:	e59d0004 	ldr	r0, [sp, #4]
  2026b8:	eb000aa4 	bl	205150 <chEvtBroadcastFlagsI>
}
  2026bc:	e28dd00c 	add	sp, sp, #12
  2026c0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002026d0 <_write.lto_priv.0>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
  2026d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2026d4:	e24dd014 	sub	sp, sp, #20
  2026d8:	e58d000c 	str	r0, [sp, #12]
  2026dc:	e58d1008 	str	r1, [sp, #8]
  2026e0:	e58d2004 	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
  2026e4:	e59d300c 	ldr	r3, [sp, #12]
  2026e8:	e2830030 	add	r0, r3, #48	; 0x30
  2026ec:	e3e03000 	mvn	r3, #0
  2026f0:	e59d2004 	ldr	r2, [sp, #4]
  2026f4:	e59d1008 	ldr	r1, [sp, #8]
  2026f8:	ebffff54 	bl	202450 <oqWriteTimeout>
  2026fc:	e1a03000 	mov	r3, r0
                        n, TIME_INFINITE);
}
  202700:	e1a00003 	mov	r0, r3
  202704:	e28dd014 	add	sp, sp, #20
  202708:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20270c:	00000000 	andeq	r0, r0, r0

00202710 <_read.lto_priv.1>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
  202710:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202714:	e24dd014 	sub	sp, sp, #20
  202718:	e58d000c 	str	r0, [sp, #12]
  20271c:	e58d1008 	str	r1, [sp, #8]
  202720:	e58d2004 	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
  202724:	e59d300c 	ldr	r3, [sp, #12]
  202728:	e283000c 	add	r0, r3, #12
  20272c:	e3e03000 	mvn	r3, #0
  202730:	e59d2004 	ldr	r2, [sp, #4]
  202734:	e59d1008 	ldr	r1, [sp, #8]
  202738:	ebfffe44 	bl	202050 <iqReadTimeout>
  20273c:	e1a03000 	mov	r3, r0
                       n, TIME_INFINITE);
}
  202740:	e1a00003 	mov	r0, r3
  202744:	e28dd014 	add	sp, sp, #20
  202748:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20274c:	00000000 	andeq	r0, r0, r0

00202750 <_put.lto_priv.2>:

static msg_t _put(void *ip, uint8_t b) {
  202750:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202754:	e24dd00c 	sub	sp, sp, #12
  202758:	e58d0004 	str	r0, [sp, #4]
  20275c:	e1a03001 	mov	r3, r1
  202760:	e5cd3003 	strb	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
  202764:	e59d3004 	ldr	r3, [sp, #4]
  202768:	e2833030 	add	r3, r3, #48	; 0x30
  20276c:	e5dd1003 	ldrb	r1, [sp, #3]
  202770:	e3e02000 	mvn	r2, #0
  202774:	e1a00003 	mov	r0, r3
  202778:	ebfffec4 	bl	202290 <oqPutTimeout>
  20277c:	e1a03000 	mov	r3, r0
}
  202780:	e1a00003 	mov	r0, r3
  202784:	e28dd00c 	add	sp, sp, #12
  202788:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20278c:	00000000 	andeq	r0, r0, r0

00202790 <_get.lto_priv.3>:

static msg_t _get(void *ip) {
  202790:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202794:	e24dd00c 	sub	sp, sp, #12
  202798:	e58d0004 	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
  20279c:	e59d3004 	ldr	r3, [sp, #4]
  2027a0:	e283300c 	add	r3, r3, #12
  2027a4:	e3e01000 	mvn	r1, #0
  2027a8:	e1a00003 	mov	r0, r3
  2027ac:	ebfffdef 	bl	201f70 <iqGetTimeout>
  2027b0:	e1a03000 	mov	r3, r0
}
  2027b4:	e1a00003 	mov	r0, r3
  2027b8:	e28dd00c 	add	sp, sp, #12
  2027bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

002027c0 <_putt.lto_priv.4>:

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
  2027c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2027c4:	e24dd014 	sub	sp, sp, #20
  2027c8:	e58d000c 	str	r0, [sp, #12]
  2027cc:	e1a03001 	mov	r3, r1
  2027d0:	e58d2004 	str	r2, [sp, #4]
  2027d4:	e5cd300b 	strb	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
  2027d8:	e59d300c 	ldr	r3, [sp, #12]
  2027dc:	e2833030 	add	r3, r3, #48	; 0x30
  2027e0:	e5dd100b 	ldrb	r1, [sp, #11]
  2027e4:	e59d2004 	ldr	r2, [sp, #4]
  2027e8:	e1a00003 	mov	r0, r3
  2027ec:	ebfffea7 	bl	202290 <oqPutTimeout>
  2027f0:	e1a03000 	mov	r3, r0
}
  2027f4:	e1a00003 	mov	r0, r3
  2027f8:	e28dd014 	add	sp, sp, #20
  2027fc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202800 <_gett.lto_priv.5>:

static msg_t _gett(void *ip, systime_t timeout) {
  202800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202804:	e24dd00c 	sub	sp, sp, #12
  202808:	e58d0004 	str	r0, [sp, #4]
  20280c:	e58d1000 	str	r1, [sp]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
  202810:	e59d3004 	ldr	r3, [sp, #4]
  202814:	e283300c 	add	r3, r3, #12
  202818:	e59d1000 	ldr	r1, [sp]
  20281c:	e1a00003 	mov	r0, r3
  202820:	ebfffdd2 	bl	201f70 <iqGetTimeout>
  202824:	e1a03000 	mov	r3, r0
}
  202828:	e1a00003 	mov	r0, r3
  20282c:	e28dd00c 	add	sp, sp, #12
  202830:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202840 <_writet.lto_priv.6>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
  202840:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202844:	e24dd014 	sub	sp, sp, #20
  202848:	e58d000c 	str	r0, [sp, #12]
  20284c:	e58d1008 	str	r1, [sp, #8]
  202850:	e58d2004 	str	r2, [sp, #4]
  202854:	e58d3000 	str	r3, [sp]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
  202858:	e59d300c 	ldr	r3, [sp, #12]
  20285c:	e2830030 	add	r0, r3, #48	; 0x30
  202860:	e59d3000 	ldr	r3, [sp]
  202864:	e59d2004 	ldr	r2, [sp, #4]
  202868:	e59d1008 	ldr	r1, [sp, #8]
  20286c:	ebfffef7 	bl	202450 <oqWriteTimeout>
  202870:	e1a03000 	mov	r3, r0
}
  202874:	e1a00003 	mov	r0, r3
  202878:	e28dd014 	add	sp, sp, #20
  20287c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202880 <_readt.lto_priv.7>:

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
  202880:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202884:	e24dd014 	sub	sp, sp, #20
  202888:	e58d000c 	str	r0, [sp, #12]
  20288c:	e58d1008 	str	r1, [sp, #8]
  202890:	e58d2004 	str	r2, [sp, #4]
  202894:	e58d3000 	str	r3, [sp]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
  202898:	e59d300c 	ldr	r3, [sp, #12]
  20289c:	e283000c 	add	r0, r3, #12
  2028a0:	e59d3000 	ldr	r3, [sp]
  2028a4:	e59d2004 	ldr	r2, [sp, #4]
  2028a8:	e59d1008 	ldr	r1, [sp, #8]
  2028ac:	ebfffde7 	bl	202050 <iqReadTimeout>
  2028b0:	e1a03000 	mov	r3, r0
}
  2028b4:	e1a00003 	mov	r0, r3
  2028b8:	e28dd014 	add	sp, sp, #20
  2028bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

002028c0 <_ctl.lto_priv.8>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
  2028c0:	e24dd018 	sub	sp, sp, #24
  2028c4:	e58d000c 	str	r0, [sp, #12]
  2028c8:	e58d1008 	str	r1, [sp, #8]
  2028cc:	e58d2004 	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
  2028d0:	e59d300c 	ldr	r3, [sp, #12]
  2028d4:	e58d3014 	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);

  switch (operation) {
  2028d8:	e59d3008 	ldr	r3, [sp, #8]
  2028dc:	e3530001 	cmp	r3, #1
#endif
  case CHN_CTL_INVALID:
    osalDbgAssert(false, "invalid CTL operation");
    break;
  }
  return MSG_OK;
  2028e0:	e3a03000 	mov	r3, #0
}
  2028e4:	e1a00003 	mov	r0, r3
  2028e8:	e28dd018 	add	sp, sp, #24
  2028ec:	e12fff1e 	bx	lr

002028f0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
  2028f0:	e92d4010 	push	{r4, lr}

  sd_lld_init();
  2028f4:	ebfff7c1 	bl	200800 <sd_lld_init>
}
  2028f8:	e8bd8010 	pop	{r4, pc}
  2028fc:	00000000 	andeq	r0, r0, r0

00202900 <sdObjectInit>:
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {
  202900:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202904:	e24dd00c 	sub	sp, sp, #12
  202908:	e58d0004 	str	r0, [sp, #4]

  sdp->vmt = &vmt;
  20290c:	e59d2004 	ldr	r2, [sp, #4]
  202910:	e3053250 	movw	r3, #21072	; 0x5250
  202914:	e3403020 	movt	r3, #32
  202918:	e5823000 	str	r3, [r2]
  osalEventObjectInit(&sdp->event);
  20291c:	e59d3004 	ldr	r3, [sp, #4]
  202920:	e2833004 	add	r3, r3, #4
  202924:	e1a00003 	mov	r0, r3
  202928:	ebffff54 	bl	202680 <osalEventObjectInit>
  sdp->state = SD_STOP;
  20292c:	e59d3004 	ldr	r3, [sp, #4]
  202930:	e3a02001 	mov	r2, #1
  202934:	e5c32008 	strb	r2, [r3, #8]
}
  202938:	e28dd00c 	add	sp, sp, #12
  20293c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202940 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
  202940:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202944:	e24dd00c 	sub	sp, sp, #12
  202948:	e58d0004 	str	r0, [sp, #4]
  20294c:	e58d1000 	str	r1, [sp]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
  202950:	ebffff42 	bl	202660 <osalSysLock.lto_priv.27>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  202954:	e59d1000 	ldr	r1, [sp]
  202958:	e59d0004 	ldr	r0, [sp, #4]
  20295c:	ebfff7d7 	bl	2008c0 <sd_lld_start>
  sdp->state = SD_READY;
  202960:	e59d3004 	ldr	r3, [sp, #4]
  202964:	e3a02002 	mov	r2, #2
  202968:	e5c32008 	strb	r2, [r3, #8]
  osalSysUnlock();
  20296c:	ebffff3f 	bl	202670 <osalSysUnlock.lto_priv.24>
}
  202970:	e28dd00c 	add	sp, sp, #12
  202974:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202980 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
  202980:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202984:	e24dd00c 	sub	sp, sp, #12
  202988:	e58d0004 	str	r0, [sp, #4]
  20298c:	e1a03001 	mov	r3, r1
  202990:	e5cd3003 	strb	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
  202994:	e59d3004 	ldr	r3, [sp, #4]
  202998:	e5933014 	ldr	r3, [r3, #20]
  20299c:	e3530000 	cmp	r3, #0
  2029a0:	1a000004 	bne	2029b8 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  2029a4:	e59d3004 	ldr	r3, [sp, #4]
  2029a8:	e2833004 	add	r3, r3, #4
  2029ac:	e3a01004 	mov	r1, #4
  2029b0:	e1a00003 	mov	r0, r3
  2029b4:	ebffff39 	bl	2026a0 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
  2029b8:	e59d3004 	ldr	r3, [sp, #4]
  2029bc:	e283300c 	add	r3, r3, #12
  2029c0:	e5dd2003 	ldrb	r2, [sp, #3]
  2029c4:	e1a01002 	mov	r1, r2
  2029c8:	e1a00003 	mov	r0, r3
  2029cc:	eb0004e3 	bl	203d60 <iqPutI>
  2029d0:	e1a03000 	mov	r3, r0
  2029d4:	e3530000 	cmp	r3, #0
  2029d8:	aa000004 	bge	2029f0 <sdIncomingDataI+0x70>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
  2029dc:	e59d3004 	ldr	r3, [sp, #4]
  2029e0:	e2833004 	add	r3, r3, #4
  2029e4:	e3a01b01 	mov	r1, #1024	; 0x400
  2029e8:	e1a00003 	mov	r0, r3
  2029ec:	ebffff2b 	bl	2026a0 <osalEventBroadcastFlagsI>
}
  2029f0:	e28dd00c 	add	sp, sp, #12
  2029f4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202a00 <port_lock.lto_priv.36>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  202a00:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  202a04:	e12fff1e 	bx	lr
	...

00202a10 <port_unlock.lto_priv.34>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  202a10:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  202a14:	e12fff1e 	bx	lr
	...

00202a20 <chSysLock.lto_priv.32>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  202a20:	e92d4010 	push	{r4, lr}

  port_lock();
  202a24:	ebfffff5 	bl	202a00 <port_lock.lto_priv.36>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  202a28:	e8bd8010 	pop	{r4, pc}
  202a2c:	00000000 	andeq	r0, r0, r0

00202a30 <chSysUnlock.lto_priv.30>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  202a30:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  202a34:	ebfffff5 	bl	202a10 <port_unlock.lto_priv.34>
}
  202a38:	e8bd8010 	pop	{r4, pc}
  202a3c:	00000000 	andeq	r0, r0, r0

00202a40 <osalSysLock.lto_priv.28>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
  202a40:	e92d4010 	push	{r4, lr}

  chSysLock();
  202a44:	ebfffff5 	bl	202a20 <chSysLock.lto_priv.32>
}
  202a48:	e8bd8010 	pop	{r4, pc}
  202a4c:	00000000 	andeq	r0, r0, r0

00202a50 <osalSysUnlock.lto_priv.25>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
  202a50:	e92d4010 	push	{r4, lr}

  chSysUnlock();
  202a54:	ebfffff5 	bl	202a30 <chSysUnlock.lto_priv.30>
}
  202a58:	e8bd8010 	pop	{r4, pc}
  202a5c:	00000000 	andeq	r0, r0, r0

00202a60 <uartInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void uartInit(void) {
  202a60:	e92d4010 	push	{r4, lr}

  uart_lld_init();
  202a64:	ebfff9b9 	bl	201150 <uart_lld_init>
}
  202a68:	e8bd8010 	pop	{r4, pc}
  202a6c:	00000000 	andeq	r0, r0, r0

00202a70 <uartObjectInit>:
 *
 * @param[out] uartp    pointer to the @p UARTDriver object
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {
  202a70:	e24dd008 	sub	sp, sp, #8
  202a74:	e58d0004 	str	r0, [sp, #4]

  uartp->state      = UART_STOP;
  202a78:	e59d3004 	ldr	r3, [sp, #4]
  202a7c:	e3a02001 	mov	r2, #1
  202a80:	e5c32000 	strb	r2, [r3]
  uartp->txstate    = UART_TX_IDLE;
  202a84:	e59d3004 	ldr	r3, [sp, #4]
  202a88:	e3a02000 	mov	r2, #0
  202a8c:	e5c32001 	strb	r2, [r3, #1]
  uartp->rxstate    = UART_RX_IDLE;
  202a90:	e59d3004 	ldr	r3, [sp, #4]
  202a94:	e3a02000 	mov	r2, #0
  202a98:	e5c32002 	strb	r2, [r3, #2]
  uartp->config     = NULL;
  202a9c:	e59d3004 	ldr	r3, [sp, #4]
  202aa0:	e3a02000 	mov	r2, #0
  202aa4:	e5832004 	str	r2, [r3, #4]

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
  202aa8:	e28dd008 	add	sp, sp, #8
  202aac:	e12fff1e 	bx	lr

00202ab0 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
  202ab0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202ab4:	e24dd00c 	sub	sp, sp, #12
  202ab8:	e58d0004 	str	r0, [sp, #4]
  202abc:	e58d1000 	str	r1, [sp]

  osalDbgCheck((uartp != NULL) && (config != NULL));

  osalSysLock();
  202ac0:	ebffffde 	bl	202a40 <osalSysLock.lto_priv.28>
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uartp->config = config;
  202ac4:	e59d3004 	ldr	r3, [sp, #4]
  202ac8:	e59d2000 	ldr	r2, [sp]
  202acc:	e5832004 	str	r2, [r3, #4]
  uart_lld_start(uartp);
  202ad0:	e59d0004 	ldr	r0, [sp, #4]
  202ad4:	ebfff9c5 	bl	2011f0 <uart_lld_start>
  uartp->state = UART_READY;
  202ad8:	e59d3004 	ldr	r3, [sp, #4]
  202adc:	e3a02002 	mov	r2, #2
  202ae0:	e5c32000 	strb	r2, [r3]
  osalSysUnlock();
  202ae4:	ebffffd9 	bl	202a50 <osalSysUnlock.lto_priv.25>
}
  202ae8:	e28dd00c 	add	sp, sp, #12
  202aec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202af0 <uartStartSend>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void uartStartSend(UARTDriver *uartp, size_t n, const void *txbuf) {
  202af0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202af4:	e24dd014 	sub	sp, sp, #20
  202af8:	e58d000c 	str	r0, [sp, #12]
  202afc:	e58d1008 	str	r1, [sp, #8]
  202b00:	e58d2004 	str	r2, [sp, #4]

  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
             
  osalSysLock();
  202b04:	ebffffcd 	bl	202a40 <osalSysLock.lto_priv.28>
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");

  uart_lld_start_send(uartp, n, txbuf);
  202b08:	e59d2004 	ldr	r2, [sp, #4]
  202b0c:	e59d1008 	ldr	r1, [sp, #8]
  202b10:	e59d000c 	ldr	r0, [sp, #12]
  202b14:	ebfffa31 	bl	2013e0 <uart_lld_start_send>
  uartp->txstate = UART_TX_ACTIVE;
  202b18:	e59d300c 	ldr	r3, [sp, #12]
  202b1c:	e3a02001 	mov	r2, #1
  202b20:	e5c32001 	strb	r2, [r3, #1]
  osalSysUnlock();
  202b24:	ebffffc9 	bl	202a50 <osalSysUnlock.lto_priv.25>
}
  202b28:	e28dd014 	add	sp, sp, #20
  202b2c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202b30 <uartStopSend>:
 *                      stopped transmit operation.
 * @retval 0            There was no transmit operation in progress.
 *
 * @api
 */
size_t uartStopSend(UARTDriver *uartp) {
  202b30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202b34:	e24dd014 	sub	sp, sp, #20
  202b38:	e58d0004 	str	r0, [sp, #4]
  size_t n;

  osalDbgCheck(uartp != NULL);

  osalSysLock();
  202b3c:	ebffffbf 	bl	202a40 <osalSysLock.lto_priv.28>
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->txstate == UART_TX_ACTIVE) {
  202b40:	e59d3004 	ldr	r3, [sp, #4]
  202b44:	e5d33001 	ldrb	r3, [r3, #1]
  202b48:	e3530001 	cmp	r3, #1
  202b4c:	1a000006 	bne	202b6c <uartStopSend+0x3c>
    n = uart_lld_stop_send(uartp);
  202b50:	e59d0004 	ldr	r0, [sp, #4]
  202b54:	ebfffa55 	bl	2014b0 <uart_lld_stop_send>
  202b58:	e58d000c 	str	r0, [sp, #12]
    uartp->txstate = UART_TX_IDLE;
  202b5c:	e59d3004 	ldr	r3, [sp, #4]
  202b60:	e3a02000 	mov	r2, #0
  202b64:	e5c32001 	strb	r2, [r3, #1]
  202b68:	ea000001 	b	202b74 <uartStopSend+0x44>
  }
  else {
    n = 0;
  202b6c:	e3a03000 	mov	r3, #0
  202b70:	e58d300c 	str	r3, [sp, #12]
  }
  osalSysUnlock();
  202b74:	ebffffb5 	bl	202a50 <osalSysUnlock.lto_priv.25>

  return n;
  202b78:	e59d300c 	ldr	r3, [sp, #12]
}
  202b7c:	e1a00003 	mov	r0, r3
  202b80:	e28dd014 	add	sp, sp, #20
  202b84:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202b90 <uartStartReceive>:
 * @param[in] n         number of data frames to receive
 * @param[in] rxbuf     the pointer to the receive buffer
 *
 * @api
 */
void uartStartReceive(UARTDriver *uartp, size_t n, void *rxbuf) {
  202b90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202b94:	e24dd014 	sub	sp, sp, #20
  202b98:	e58d000c 	str	r0, [sp, #12]
  202b9c:	e58d1008 	str	r1, [sp, #8]
  202ba0:	e58d2004 	str	r2, [sp, #4]

  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
  202ba4:	ebffffa5 	bl	202a40 <osalSysLock.lto_priv.28>
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");

  uart_lld_start_receive(uartp, n, rxbuf);
  202ba8:	e59d2004 	ldr	r2, [sp, #4]
  202bac:	e59d1008 	ldr	r1, [sp, #8]
  202bb0:	e59d000c 	ldr	r0, [sp, #12]
  202bb4:	ebfffa69 	bl	201560 <uart_lld_start_receive>
  uartp->rxstate = UART_RX_ACTIVE;
  202bb8:	e59d300c 	ldr	r3, [sp, #12]
  202bbc:	e3a02001 	mov	r2, #1
  202bc0:	e5c32002 	strb	r2, [r3, #2]
  osalSysUnlock();
  202bc4:	ebffffa1 	bl	202a50 <osalSysUnlock.lto_priv.25>
}
  202bc8:	e28dd014 	add	sp, sp, #20
  202bcc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00202bd0 <uartStopReceive>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @api
 */
size_t uartStopReceive(UARTDriver *uartp) {
  202bd0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  202bd4:	e24dd014 	sub	sp, sp, #20
  202bd8:	e58d0004 	str	r0, [sp, #4]
  size_t n;

  osalDbgCheck(uartp != NULL);

  osalSysLock();
  202bdc:	ebffff97 	bl	202a40 <osalSysLock.lto_priv.28>
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->rxstate == UART_RX_ACTIVE) {
  202be0:	e59d3004 	ldr	r3, [sp, #4]
  202be4:	e5d33002 	ldrb	r3, [r3, #2]
  202be8:	e3530001 	cmp	r3, #1
  202bec:	1a000006 	bne	202c0c <uartStopReceive+0x3c>
    n = uart_lld_stop_receive(uartp);
  202bf0:	e59d0004 	ldr	r0, [sp, #4]
  202bf4:	ebfffaed 	bl	2017b0 <uart_lld_stop_receive>
  202bf8:	e58d000c 	str	r0, [sp, #12]
    uartp->rxstate = UART_RX_IDLE;
  202bfc:	e59d3004 	ldr	r3, [sp, #4]
  202c00:	e3a02000 	mov	r2, #0
  202c04:	e5c32002 	strb	r2, [r3, #2]
  202c08:	ea000001 	b	202c14 <uartStopReceive+0x44>
  }
  else {
    n = 0;
  202c0c:	e3a03000 	mov	r3, #0
  202c10:	e58d300c 	str	r3, [sp, #12]
  }
  osalSysUnlock();
  202c14:	ebffff8d 	bl	202a50 <osalSysUnlock.lto_priv.25>

  return n;
  202c18:	e59d300c 	ldr	r3, [sp, #12]
}
  202c1c:	e1a00003 	mov	r0, r3
  202c20:	e28dd014 	add	sp, sp, #20
  202c24:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00202c30 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
  202c30:	e92d4010 	push	{r4, lr}

  /* Disabling PMC write protection. */
  pmcDisableWP();
  202c34:	e3a03901 	mov	r3, #16384	; 0x4000
  202c38:	e34f3001 	movt	r3, #61441	; 0xf001
  202c3c:	e3a02c43 	mov	r2, #17152	; 0x4300
  202c40:	e345204d 	movt	r2, #20557	; 0x504d
  202c44:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling matrix clock */
  pmcEnableH32MX();
  202c48:	e3a03901 	mov	r3, #16384	; 0x4000
  202c4c:	e34f3001 	movt	r3, #61441	; 0xf001
  202c50:	e3a02c43 	mov	r2, #17152	; 0x4300
  202c54:	e345204d 	movt	r2, #20557	; 0x504d
  202c58:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  202c5c:	e3a03901 	mov	r3, #16384	; 0x4000
  202c60:	e34f3001 	movt	r3, #61441	; 0xf001
  202c64:	e3a02901 	mov	r2, #16384	; 0x4000
  202c68:	e34f2001 	movt	r2, #61441	; 0xf001
  202c6c:	e5922010 	ldr	r2, [r2, #16]
  202c70:	e3822901 	orr	r2, r2, #16384	; 0x4000
  202c74:	e5832010 	str	r2, [r3, #16]
  202c78:	e3a03901 	mov	r3, #16384	; 0x4000
  202c7c:	e34f3001 	movt	r3, #61441	; 0xf001
  202c80:	e3042301 	movw	r2, #17153	; 0x4301
  202c84:	e345204d 	movt	r2, #20557	; 0x504d
  202c88:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  pmcEnableH64MX();
  202c8c:	e3a03901 	mov	r3, #16384	; 0x4000
  202c90:	e34f3001 	movt	r3, #61441	; 0xf001
  202c94:	e3a02c43 	mov	r2, #17152	; 0x4300
  202c98:	e345204d 	movt	r2, #20557	; 0x504d
  202c9c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  202ca0:	e3a03901 	mov	r3, #16384	; 0x4000
  202ca4:	e34f3001 	movt	r3, #61441	; 0xf001
  202ca8:	e3a02901 	mov	r2, #16384	; 0x4000
  202cac:	e34f2001 	movt	r2, #61441	; 0xf001
  202cb0:	e5922010 	ldr	r2, [r2, #16]
  202cb4:	e3822902 	orr	r2, r2, #32768	; 0x8000
  202cb8:	e5832010 	str	r2, [r3, #16]
  202cbc:	e3a03901 	mov	r3, #16384	; 0x4000
  202cc0:	e34f3001 	movt	r3, #61441	; 0xf001
  202cc4:	e3042301 	movw	r2, #17153	; 0x4301
  202cc8:	e345204d 	movt	r2, #20557	; 0x504d
  202ccc:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* Enabling write protection.  */
  pmcEnableWP();
  202cd0:	e3a03901 	mov	r3, #16384	; 0x4000
  202cd4:	e34f3001 	movt	r3, #61441	; 0xf001
  202cd8:	e3042301 	movw	r2, #17153	; 0x4301
  202cdc:	e345204d 	movt	r2, #20557	; 0x504d
  202ce0:	e58320e4 	str	r2, [r3, #228]	; 0xe4

#if defined(SAMA_DMA_REQUIRED)
  dmaInit();
  202ce4:	eb000209 	bl	203510 <dmaInit>
#endif
  /* Advanced interrupt controller init */
  aicInit();
  202ce8:	eb000128 	bl	203190 <aicInit>
}
  202cec:	e8bd8010 	pop	{r4, pc}

00202cf0 <sama_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void sama_clock_init(void) {
  202cf0:	e24dd010 	sub	sp, sp, #16
#if !SAMA_NO_INIT
  uint32_t mor, pllar, mckr, mainf;
  /* Disabling PMC write protection. */
  pmcDisableWP();
  202cf4:	e3a03901 	mov	r3, #16384	; 0x4000
  202cf8:	e34f3001 	movt	r3, #61441	; 0xf001
  202cfc:	e3a02c43 	mov	r2, #17152	; 0x4300
  202d00:	e345204d 	movt	r2, #20557	; 0x504d
  202d04:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  /* 
   * Enforcing the reset default configuration of clock tree. 
   */  
  /* Setting Slow Clock source to OSCRC. */
  SCKC->SCKC_CR = 0U;
  202d08:	e3083050 	movw	r3, #32848	; 0x8050
  202d0c:	e34f3804 	movt	r3, #63492	; 0xf804
  202d10:	e3a02000 	mov	r2, #0
  202d14:	e5832000 	str	r2, [r3]

  /* Enabling MOSCRC. */
  PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  202d18:	e3a02901 	mov	r2, #16384	; 0x4000
  202d1c:	e34f2001 	movt	r2, #61441	; 0xf001
  202d20:	e3a03901 	mov	r3, #16384	; 0x4000
  202d24:	e34f3001 	movt	r3, #61441	; 0xf001
  202d28:	e5933020 	ldr	r3, [r3, #32]
  202d2c:	e3833837 	orr	r3, r3, #3604480	; 0x370000
  202d30:	e3833008 	orr	r3, r3, #8
  202d34:	e5823020 	str	r3, [r2, #32]
  while (!(PMC->PMC_SR & PMC_SR_MOSCRCS))
  202d38:	e3a03901 	mov	r3, #16384	; 0x4000
  202d3c:	e34f3001 	movt	r3, #61441	; 0xf001
  202d40:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202d44:	e2033802 	and	r3, r3, #131072	; 0x20000
  202d48:	e3530000 	cmp	r3, #0
  202d4c:	0afffff9 	beq	202d38 <sama_clock_init+0x48>
    ;                                       /* Waits until MOSCRC is stable.*/

  /* Switching Main Oscillator Source to MOSRC. */
  mor = PMC->CKGR_MOR | CKGR_MOR_KEY_PASSWD;
  202d50:	e3a03901 	mov	r3, #16384	; 0x4000
  202d54:	e34f3001 	movt	r3, #61441	; 0xf001
  202d58:	e5933020 	ldr	r3, [r3, #32]
  202d5c:	e3833837 	orr	r3, r3, #3604480	; 0x370000
  202d60:	e58d300c 	str	r3, [sp, #12]
  mor &= ~CKGR_MOR_MOSCSEL;
  202d64:	e59d300c 	ldr	r3, [sp, #12]
  202d68:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
  202d6c:	e58d300c 	str	r3, [sp, #12]
  mor |= SAMA_MOSC_MOSCRC;
  PMC->CKGR_MOR = mor;
  202d70:	e3a03901 	mov	r3, #16384	; 0x4000
  202d74:	e34f3001 	movt	r3, #61441	; 0xf001
  202d78:	e59d200c 	ldr	r2, [sp, #12]
  202d7c:	e5832020 	str	r2, [r3, #32]

  while (!(PMC->PMC_SR & PMC_SR_MOSCSELS))
  202d80:	e3a03901 	mov	r3, #16384	; 0x4000
  202d84:	e34f3001 	movt	r3, #61441	; 0xf001
  202d88:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202d8c:	e2033801 	and	r3, r3, #65536	; 0x10000
  202d90:	e3530000 	cmp	r3, #0
  202d94:	0afffff9 	beq	202d80 <sama_clock_init+0x90>
    ;                                       /* Waits until MOSCSEL has changed.*/

  /* Switching Master Clock source to Main Clock. */
  mckr = PMC->PMC_MCKR;
  202d98:	e3a03901 	mov	r3, #16384	; 0x4000
  202d9c:	e34f3001 	movt	r3, #61441	; 0xf001
  202da0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  202da4:	e58d3008 	str	r3, [sp, #8]
  mckr &= ~PMC_MCKR_CSS_Msk;
  202da8:	e59d3008 	ldr	r3, [sp, #8]
  202dac:	e3c33003 	bic	r3, r3, #3
  202db0:	e58d3008 	str	r3, [sp, #8]
  mckr |= PMC_MCKR_CSS_MAIN_CLK;
  202db4:	e59d3008 	ldr	r3, [sp, #8]
  202db8:	e3833001 	orr	r3, r3, #1
  202dbc:	e58d3008 	str	r3, [sp, #8]
  PMC->PMC_MCKR = mckr;
  202dc0:	e3a03901 	mov	r3, #16384	; 0x4000
  202dc4:	e34f3001 	movt	r3, #61441	; 0xf001
  202dc8:	e59d2008 	ldr	r2, [sp, #8]
  202dcc:	e5832030 	str	r2, [r3, #48]	; 0x30

  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
  202dd0:	e3a03901 	mov	r3, #16384	; 0x4000
  202dd4:	e34f3001 	movt	r3, #61441	; 0xf001
  202dd8:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202ddc:	e2033008 	and	r3, r3, #8
  202de0:	e3530000 	cmp	r3, #0
  202de4:	0afffff9 	beq	202dd0 <sama_clock_init+0xe0>
    ;                                       /* Waits until Master Clock is stable.*/

  /* Counter Clock Source to MOSCRC. */
  PMC->CKGR_MCFR &= ~CKGR_MCFR_CCSS;
  202de8:	e3a03901 	mov	r3, #16384	; 0x4000
  202dec:	e34f3001 	movt	r3, #61441	; 0xf001
  202df0:	e3a02901 	mov	r2, #16384	; 0x4000
  202df4:	e34f2001 	movt	r2, #61441	; 0xf001
  202df8:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  202dfc:	e3c22401 	bic	r2, r2, #16777216	; 0x1000000
  202e00:	e5832024 	str	r2, [r3, #36]	; 0x24

  /*
   * Main oscillator configuration block.
   */
  /* Setting Slow clock source. */
  SCKC->SCKC_CR = SAMA_OSC_SEL;
  202e04:	e3083050 	movw	r3, #32848	; 0x8050
  202e08:	e34f3804 	movt	r3, #63492	; 0xf804
  202e0c:	e3a02008 	mov	r2, #8
  202e10:	e5832000 	str	r2, [r3]
  while ((SAMA_OSC_SEL && !(PMC->PMC_SR & PMC_SR_OSCSELS)) ||
  202e14:	e3a03901 	mov	r3, #16384	; 0x4000
  202e18:	e34f3001 	movt	r3, #61441	; 0xf001
  202e1c:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202e20:	e2033080 	and	r3, r3, #128	; 0x80
  202e24:	e3530000 	cmp	r3, #0
  202e28:	0afffff9 	beq	202e14 <sama_clock_init+0x124>
        (!SAMA_OSC_SEL &&  (PMC->PMC_SR & PMC_SR_OSCSELS)))
    ;                                       /* Waits until MOSCxxS switch is done.*/
  mor = PMC->CKGR_MOR | CKGR_MOR_KEY_PASSWD;
  202e2c:	e3a03901 	mov	r3, #16384	; 0x4000
  202e30:	e34f3001 	movt	r3, #61441	; 0xf001
  202e34:	e5933020 	ldr	r3, [r3, #32]
  202e38:	e3833837 	orr	r3, r3, #3604480	; 0x370000
  202e3c:	e58d300c 	str	r3, [sp, #12]
#if SAMA_MOSCXT_ENABLED
  mor |= CKGR_MOR_MOSCXTEN;
  202e40:	e59d300c 	ldr	r3, [sp, #12]
  202e44:	e3833001 	orr	r3, r3, #1
  202e48:	e58d300c 	str	r3, [sp, #12]
  PMC->CKGR_MOR = mor;
  202e4c:	e3a03901 	mov	r3, #16384	; 0x4000
  202e50:	e34f3001 	movt	r3, #61441	; 0xf001
  202e54:	e59d200c 	ldr	r2, [sp, #12]
  202e58:	e5832020 	str	r2, [r3, #32]
  while (!(PMC->PMC_SR & PMC_SR_MOSCXTS))
  202e5c:	e3a03901 	mov	r3, #16384	; 0x4000
  202e60:	e34f3001 	movt	r3, #61441	; 0xf001
  202e64:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202e68:	e2033001 	and	r3, r3, #1
  202e6c:	e3530000 	cmp	r3, #0
  202e70:	0afffff9 	beq	202e5c <sama_clock_init+0x16c>
    ;                                       /* Waits until MOSCXT is stable.*/
  /* Counter Clock Source to MOSCXT. */
  PMC->CKGR_MCFR |= CKGR_MCFR_CCSS;
  202e74:	e3a03901 	mov	r3, #16384	; 0x4000
  202e78:	e34f3001 	movt	r3, #61441	; 0xf001
  202e7c:	e3a02901 	mov	r2, #16384	; 0x4000
  202e80:	e34f2001 	movt	r2, #61441	; 0xf001
  202e84:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  202e88:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
  202e8c:	e5832024 	str	r2, [r3, #36]	; 0x24
#else
  mor &= ~CKGR_MOR_MOSCXTEN;
  PMC->CKGR_MOR = mor;
#endif

  PMC->CKGR_MCFR |= CKGR_MCFR_RCMEAS;
  202e90:	e3a03901 	mov	r3, #16384	; 0x4000
  202e94:	e34f3001 	movt	r3, #61441	; 0xf001
  202e98:	e3a02901 	mov	r2, #16384	; 0x4000
  202e9c:	e34f2001 	movt	r2, #61441	; 0xf001
  202ea0:	e5922024 	ldr	r2, [r2, #36]	; 0x24
  202ea4:	e3822601 	orr	r2, r2, #1048576	; 0x100000
  202ea8:	e5832024 	str	r2, [r3, #36]	; 0x24
  while (!(PMC->CKGR_MCFR & CKGR_MCFR_MAINFRDY))
  202eac:	e3a03901 	mov	r3, #16384	; 0x4000
  202eb0:	e34f3001 	movt	r3, #61441	; 0xf001
  202eb4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  202eb8:	e2033801 	and	r3, r3, #65536	; 0x10000
  202ebc:	e3530000 	cmp	r3, #0
  202ec0:	0afffff9 	beq	202eac <sama_clock_init+0x1bc>
    ;
  mainf = CKGR_MCFR_MAINF(PMC->CKGR_MCFR);
  202ec4:	e3a03901 	mov	r3, #16384	; 0x4000
  202ec8:	e34f3001 	movt	r3, #61441	; 0xf001
  202ecc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  202ed0:	e6ff3073 	uxth	r3, r3
  202ed4:	e58d3004 	str	r3, [sp, #4]
   * should be activable through a switch.
   */
  (void)mainf;

  /* Switching Main Clock source. */
  mor &= ~CKGR_MOR_MOSCSEL;
  202ed8:	e59d300c 	ldr	r3, [sp, #12]
  202edc:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
  202ee0:	e58d300c 	str	r3, [sp, #12]
  mor |= SAMA_MOSC_SEL;
  202ee4:	e59d300c 	ldr	r3, [sp, #12]
  202ee8:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
  202eec:	e58d300c 	str	r3, [sp, #12]
  PMC->CKGR_MOR = mor;
  202ef0:	e3a03901 	mov	r3, #16384	; 0x4000
  202ef4:	e34f3001 	movt	r3, #61441	; 0xf001
  202ef8:	e59d200c 	ldr	r2, [sp, #12]
  202efc:	e5832020 	str	r2, [r3, #32]

  /* Eventually disabling MOSCRC. */
#if !SAMA_MOSCRC_ENABLED
  PMC->CKGR_MOR &= ~ CKGR_MOR_MOSCRCEN;
  202f00:	e3a03901 	mov	r3, #16384	; 0x4000
  202f04:	e34f3001 	movt	r3, #61441	; 0xf001
  202f08:	e3a02901 	mov	r2, #16384	; 0x4000
  202f0c:	e34f2001 	movt	r2, #61441	; 0xf001
  202f10:	e5922020 	ldr	r2, [r2, #32]
  202f14:	e3c22008 	bic	r2, r2, #8
  202f18:	e5832020 	str	r2, [r3, #32]
#endif

/*
 * PLLA configuration block.
 */
  pllar = SAMA_PLLA_ONE | CKGR_PLLAR_PLLACOUNT(0x3F);
  202f1c:	e3a03c3f 	mov	r3, #16128	; 0x3f00
  202f20:	e3423000 	movt	r3, #8192	; 0x2000
  202f24:	e58d3000 	str	r3, [sp]
#if SAMA_ACTIVATE_PLLA
  pllar |= CKGR_PLLAR_DIVA_BYPASS | SAMA_PLLA_MUL;
  202f28:	e59d3000 	ldr	r3, [sp]
  202f2c:	e3833752 	orr	r3, r3, #21495808	; 0x1480000
  202f30:	e3833001 	orr	r3, r3, #1
  202f34:	e58d3000 	str	r3, [sp]
#endif
  PMC->CKGR_PLLAR = pllar;                  /* Writing PLLA register.       */
  202f38:	e3a03901 	mov	r3, #16384	; 0x4000
  202f3c:	e34f3001 	movt	r3, #61441	; 0xf001
  202f40:	e59d2000 	ldr	r2, [sp]
  202f44:	e5832028 	str	r2, [r3, #40]	; 0x28

#if SAMA_ACTIVATE_PLLA
  while (!(PMC->PMC_SR & PMC_SR_LOCKA))
  202f48:	e3a03901 	mov	r3, #16384	; 0x4000
  202f4c:	e34f3001 	movt	r3, #61441	; 0xf001
  202f50:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202f54:	e2033002 	and	r3, r3, #2
  202f58:	e3530000 	cmp	r3, #0
  202f5c:	0afffff9 	beq	202f48 <sama_clock_init+0x258>
#endif

/*
 * Master clock configuration block.
 */
  mckr = PMC->PMC_MCKR;
  202f60:	e3a03901 	mov	r3, #16384	; 0x4000
  202f64:	e34f3001 	movt	r3, #61441	; 0xf001
  202f68:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  202f6c:	e58d3008 	str	r3, [sp, #8]
  mckr &= ~PMC_MCKR_CSS_Msk;
  202f70:	e59d3008 	ldr	r3, [sp, #8]
  202f74:	e3c33003 	bic	r3, r3, #3
  202f78:	e58d3008 	str	r3, [sp, #8]
  mckr |= SAMA_MCK_SEL;
  202f7c:	e59d3008 	ldr	r3, [sp, #8]
  202f80:	e3833002 	orr	r3, r3, #2
  202f84:	e58d3008 	str	r3, [sp, #8]
  PMC->PMC_MCKR = mckr;
  202f88:	e3a03901 	mov	r3, #16384	; 0x4000
  202f8c:	e34f3001 	movt	r3, #61441	; 0xf001
  202f90:	e59d2008 	ldr	r2, [sp, #8]
  202f94:	e5832030 	str	r2, [r3, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
  202f98:	e3a03901 	mov	r3, #16384	; 0x4000
  202f9c:	e34f3001 	movt	r3, #61441	; 0xf001
  202fa0:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  202fa4:	e2033008 	and	r3, r3, #8
  202fa8:	e3530000 	cmp	r3, #0
  202fac:	0afffff9 	beq	202f98 <sama_clock_init+0x2a8>
    ;                                       /* Waits until MCK is stable.   */

  mckr &= ~(PMC_MCKR_PRES_Msk | PMC_MCKR_MDIV_Msk | PMC_MCKR_H32MXDIV);
  202fb0:	e59d3008 	ldr	r3, [sp, #8]
  202fb4:	e3c33401 	bic	r3, r3, #16777216	; 0x1000000
  202fb8:	e3c33e37 	bic	r3, r3, #880	; 0x370
  202fbc:	e58d3008 	str	r3, [sp, #8]
  
  /* Note that prescaler and divider must be changed with separate accesses.*/
  mckr |= SAMA_MCK_PRES;
  mckr |= SAMA_MCK_MDIV;
  202fc0:	e59d3008 	ldr	r3, [sp, #8]
  202fc4:	e3833c03 	orr	r3, r3, #768	; 0x300
  202fc8:	e58d3008 	str	r3, [sp, #8]
  mckr |= SAMA_H64MX_H32MX_DIV;
  202fcc:	e59d3008 	ldr	r3, [sp, #8]
  202fd0:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
  202fd4:	e58d3008 	str	r3, [sp, #8]
#if SAMA_PLLADIV2_EN
  mckr |= PMC_MCKR_PLLADIV2;
  202fd8:	e59d3008 	ldr	r3, [sp, #8]
  202fdc:	e3833a01 	orr	r3, r3, #4096	; 0x1000
  202fe0:	e58d3008 	str	r3, [sp, #8]
#else
  mckr &= ~PMC_MCKR_PLLADIV2;
#endif
  PMC->PMC_MCKR = mckr;
  202fe4:	e3a03901 	mov	r3, #16384	; 0x4000
  202fe8:	e34f3001 	movt	r3, #61441	; 0xf001
  202fec:	e59d2008 	ldr	r2, [sp, #8]
  202ff0:	e5832030 	str	r2, [r3, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
  202ff4:	e3a03901 	mov	r3, #16384	; 0x4000
  202ff8:	e34f3001 	movt	r3, #61441	; 0xf001
  202ffc:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  203000:	e2033008 	and	r3, r3, #8
  203004:	e3530000 	cmp	r3, #0
  203008:	0afffff9 	beq	202ff4 <sama_clock_init+0x304>
    ;                                       /* Waits until MCK is stable.   */

  /* Enabling write protection.  */
  pmcEnableWP();
  20300c:	e3a03901 	mov	r3, #16384	; 0x4000
  203010:	e34f3001 	movt	r3, #61441	; 0xf001
  203014:	e3042301 	movw	r2, #17153	; 0x4301
  203018:	e345204d 	movt	r2, #20557	; 0x504d
  20301c:	e58320e4 	str	r2, [r3, #228]	; 0xe4

#endif /* !SAMA_NO_INIT */
}
  203020:	e28dd010 	add	sp, sp, #16
  203024:	e12fff1e 	bx	lr
	...

00203030 <port_lock_from_isr.lto_priv.21>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  203030:	e12fff1e 	bx	lr
	...

00203040 <port_unlock_from_isr.lto_priv.19>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  203040:	e12fff1e 	bx	lr
	...

00203050 <chSysLockFromISR.lto_priv.17>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  203050:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  203054:	ebfffff5 	bl	203030 <port_lock_from_isr.lto_priv.21>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  203058:	e8bd8010 	pop	{r4, pc}
  20305c:	00000000 	andeq	r0, r0, r0

00203060 <chSysUnlockFromISR.lto_priv.15>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  203060:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  203064:	ebfffff5 	bl	203040 <port_unlock_from_isr.lto_priv.19>
}
  203068:	e8bd8010 	pop	{r4, pc}
  20306c:	00000000 	andeq	r0, r0, r0

00203070 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
  203070:	e92d4010 	push	{r4, lr}

  chSysLockFromISR();
  203074:	ebfffff5 	bl	203050 <chSysLockFromISR.lto_priv.17>
}
  203078:	e8bd8010 	pop	{r4, pc}
  20307c:	00000000 	andeq	r0, r0, r0

00203080 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
  203080:	e92d4010 	push	{r4, lr}

  chSysUnlockFromISR();
  203084:	ebfffff5 	bl	203060 <chSysUnlockFromISR.lto_priv.15>
}
  203088:	e8bd8010 	pop	{r4, pc}
  20308c:	00000000 	andeq	r0, r0, r0

00203090 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
  203090:	e92d4010 	push	{r4, lr}

  chSysTimerHandlerI();
  203094:	eb0004a5 	bl	204330 <chSysTimerHandlerI>
}
  203098:	e8bd8010 	pop	{r4, pc}
  20309c:	00000000 	andeq	r0, r0, r0

002030a0 <PIT_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(PIT_Handler) {
  2030a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2030a4:	e24dd00c 	sub	sp, sp, #12
  uint32_t ivr;
  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
  2030a8:	ebfffff0 	bl	203070 <osalSysLockFromISR>
  ivr = PIT->PIT_PIVR;    /* acknowledge PIT interrupt */
  2030ac:	e3083030 	movw	r3, #32816	; 0x8030
  2030b0:	e34f3804 	movt	r3, #63492	; 0xf804
  2030b4:	e5933008 	ldr	r3, [r3, #8]
  2030b8:	e58d3004 	str	r3, [sp, #4]
  osalDbgAssert((ivr & PIT_PIVR_PICNT_Msk) == (1 << PIT_PIVR_PICNT_Pos),
      "check for lost tick");
  osalOsTimerHandlerI();
  2030bc:	ebfffff3 	bl	203090 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
  2030c0:	ebffffee 	bl	203080 <osalSysUnlockFromISR>
  aicAckInt();
  2030c4:	e3a03903 	mov	r3, #49152	; 0xc000
  2030c8:	e34f3803 	movt	r3, #63491	; 0xf803
  2030cc:	e3a02001 	mov	r2, #1
  2030d0:	e5832038 	str	r2, [r3, #56]	; 0x38
  OSAL_IRQ_EPILOGUE();
  2030d4:	eb00065d 	bl	204a50 <chSchIsPreemptionRequired>
  2030d8:	e1a03000 	mov	r3, r0
}
  2030dc:	e1a00003 	mov	r0, r3
  2030e0:	e28dd00c 	add	sp, sp, #12
  2030e4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002030f0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
  2030f0:	e92d4010 	push	{r4, lr}

#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC)
  /* Enabling PIT.*/
  pmcEnablePIT();
  2030f4:	e3a03901 	mov	r3, #16384	; 0x4000
  2030f8:	e34f3001 	movt	r3, #61441	; 0xf001
  2030fc:	e3a02c43 	mov	r2, #17152	; 0x4300
  203100:	e345204d 	movt	r2, #20557	; 0x504d
  203104:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  203108:	e3a03901 	mov	r3, #16384	; 0x4000
  20310c:	e34f3001 	movt	r3, #61441	; 0xf001
  203110:	e3a02901 	mov	r2, #16384	; 0x4000
  203114:	e34f2001 	movt	r2, #61441	; 0xf001
  203118:	e5922010 	ldr	r2, [r2, #16]
  20311c:	e3822008 	orr	r2, r2, #8
  203120:	e5832010 	str	r2, [r3, #16]
  203124:	e3a03901 	mov	r3, #16384	; 0x4000
  203128:	e34f3001 	movt	r3, #61441	; 0xf001
  20312c:	e3042301 	movw	r2, #17153	; 0x4301
  203130:	e345204d 	movt	r2, #20557	; 0x504d
  203134:	e58320e4 	str	r2, [r3, #228]	; 0xe4

  PIT->PIT_MR = PIT_MR_PIV((SAMA_PIT / OSAL_ST_FREQUENCY) - 1);
  203138:	e3083030 	movw	r3, #32816	; 0x8030
  20313c:	e34f3804 	movt	r3, #63492	; 0xf804
  203140:	e3012442 	movw	r2, #5186	; 0x1442
  203144:	e5832000 	str	r2, [r3]
  PIT->PIT_MR |= PIT_MR_PITEN | PIT_MR_PITIEN;
  203148:	e3083030 	movw	r3, #32816	; 0x8030
  20314c:	e34f3804 	movt	r3, #63492	; 0xf804
  203150:	e3082030 	movw	r2, #32816	; 0x8030
  203154:	e34f2804 	movt	r2, #63492	; 0xf804
  203158:	e5922000 	ldr	r2, [r2]
  20315c:	e3822403 	orr	r2, r2, #50331648	; 0x3000000
  203160:	e5832000 	str	r2, [r3]

  /* IRQ enabled.*/
  aicSetSourcePriority(ID_PIT, SAMA_ST_IRQ_PRIORITY);
  203164:	e3a01000 	mov	r1, #0
  203168:	e3a00003 	mov	r0, #3
  20316c:	eb00001f 	bl	2031f0 <aicSetSourcePriority>
  aicSetSourceHandler(ID_PIT, PIT_Handler);
  203170:	e30310a0 	movw	r1, #12448	; 0x30a0
  203174:	e3401020 	movt	r1, #32
  203178:	e3a00003 	mov	r0, #3
  20317c:	eb00003b 	bl	203270 <aicSetSourceHandler>
  aicEnableInt(ID_PIT);
  203180:	e3a00003 	mov	r0, #3
  203184:	eb000051 	bl	2032d0 <aicEnableInt>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
  203188:	e8bd8010 	pop	{r4, pc}
  20318c:	00000000 	andeq	r0, r0, r0

00203190 <aicInit>:
 * @brief   AIC Initialization.
 * @note    Better reset everything in the AIC.
 *
 * @notapi
 */
void aicInit(void) {
  203190:	e24dd008 	sub	sp, sp, #8

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  203194:	e3a03903 	mov	r3, #49152	; 0xc000
  203198:	e34f3803 	movt	r3, #63491	; 0xf803
  20319c:	e58d3000 	str	r3, [sp]
  Aic *aic = AIC;
#endif

  unsigned i;
  /* Disable all interrupts */
  for (i = 1; i < ID_PERIPH_COUNT; i++) {
  2031a0:	e3a03001 	mov	r3, #1
  2031a4:	e58d3004 	str	r3, [sp, #4]
  2031a8:	ea000008 	b	2031d0 <aicInit+0x40>
    aic->AIC_SSR = i;
  2031ac:	e59d3000 	ldr	r3, [sp]
  2031b0:	e59d2004 	ldr	r2, [sp, #4]
  2031b4:	e5832000 	str	r2, [r3]
    aic->AIC_IDCR = AIC_IDCR_INTD;
  2031b8:	e59d3000 	ldr	r3, [sp]
  2031bc:	e3a02001 	mov	r2, #1
  2031c0:	e5832044 	str	r2, [r3, #68]	; 0x44
  Aic *aic = AIC;
#endif

  unsigned i;
  /* Disable all interrupts */
  for (i = 1; i < ID_PERIPH_COUNT; i++) {
  2031c4:	e59d3004 	ldr	r3, [sp, #4]
  2031c8:	e2833001 	add	r3, r3, #1
  2031cc:	e58d3004 	str	r3, [sp, #4]
  2031d0:	e59d3004 	ldr	r3, [sp, #4]
  2031d4:	e353004e 	cmp	r3, #78	; 0x4e
  2031d8:	9afffff3 	bls	2031ac <aicInit+0x1c>
    aic->AIC_SSR = i;
    aic->AIC_IDCR = AIC_IDCR_INTD;
  }
}
  2031dc:	e28dd008 	add	sp, sp, #8
  2031e0:	e12fff1e 	bx	lr
	...

002031f0 <aicSetSourcePriority>:
 * @note    Source cannot be ID_SAIC_FIQ (0).
 *
 * @param[in] source    interrupt source to configure
 * @param[in] priority  priority level of the selected source.
 */
void aicSetSourcePriority(uint32_t source, uint8_t priority) {
  2031f0:	e24dd010 	sub	sp, sp, #16
  2031f4:	e58d0004 	str	r0, [sp, #4]
  2031f8:	e1a03001 	mov	r3, r1
  2031fc:	e5cd3003 	strb	r3, [sp, #3]

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  203200:	e3a03903 	mov	r3, #49152	; 0xc000
  203204:	e34f3803 	movt	r3, #63491	; 0xf803
  203208:	e58d300c 	str	r3, [sp, #12]
#endif

  osalDbgCheck(source != ID_SAIC_FIQ);
  osalDbgAssert(SAMA_IRQ_IS_VALID_PRIORITY(priority), "invalid irq priority");
  /* Disable write protection */
  aicDisableWP(aic);
  20320c:	e59d200c 	ldr	r2, [sp, #12]
  203210:	e3a03c43 	mov	r3, #17152	; 0x4300
  203214:	e3443149 	movt	r3, #16713	; 0x4149
  203218:	e58230e4 	str	r3, [r2, #228]	; 0xe4
  /* Set source id */
  aic->AIC_SSR = source;
  20321c:	e59d300c 	ldr	r3, [sp, #12]
  203220:	e59d2004 	ldr	r2, [sp, #4]
  203224:	e5832000 	str	r2, [r3]
  /* Disable the interrupt first */
  aic->AIC_IDCR = AIC_IDCR_INTD;
  203228:	e59d300c 	ldr	r3, [sp, #12]
  20322c:	e3a02001 	mov	r2, #1
  203230:	e5832044 	str	r2, [r3, #68]	; 0x44
  /* Configure priority */
  aic->AIC_SMR = AIC_SMR_PRIOR(priority);
  203234:	e5dd3003 	ldrb	r3, [sp, #3]
  203238:	e2032007 	and	r2, r3, #7
  20323c:	e59d300c 	ldr	r3, [sp, #12]
  203240:	e5832004 	str	r2, [r3, #4]
  /* Clear interrupt */
  aic->AIC_ICCR = AIC_ICCR_INTCLR;
  203244:	e59d300c 	ldr	r3, [sp, #12]
  203248:	e3a02001 	mov	r2, #1
  20324c:	e5832048 	str	r2, [r3, #72]	; 0x48
  /* Enable write protection */
  aicEnableWP(aic);
  203250:	e59d200c 	ldr	r2, [sp, #12]
  203254:	e3043301 	movw	r3, #17153	; 0x4301
  203258:	e3443149 	movt	r3, #16713	; 0x4149
  20325c:	e58230e4 	str	r3, [r2, #228]	; 0xe4
}
  203260:	e28dd010 	add	sp, sp, #16
  203264:	e12fff1e 	bx	lr
	...

00203270 <aicSetSourceHandler>:
 * @brief   Sets the source handler of an interrupt.
 *
 * @param[in] source    interrupt source to configure
 * @param[in] handler   handler for the interrupt source selected
 */
void aicSetSourceHandler(uint32_t source, bool (*handler)(void)) {
  203270:	e24dd010 	sub	sp, sp, #16
  203274:	e58d0004 	str	r0, [sp, #4]
  203278:	e58d1000 	str	r1, [sp]

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  20327c:	e3a03903 	mov	r3, #49152	; 0xc000
  203280:	e34f3803 	movt	r3, #63491	; 0xf803
  203284:	e58d300c 	str	r3, [sp, #12]
#else
  Aic *aic = AIC;
#endif

  /* Disable write protection */
  aicDisableWP(aic);
  203288:	e59d200c 	ldr	r2, [sp, #12]
  20328c:	e3a03c43 	mov	r3, #17152	; 0x4300
  203290:	e3443149 	movt	r3, #16713	; 0x4149
  203294:	e58230e4 	str	r3, [r2, #228]	; 0xe4
  /* Select source and assign handler */
  aic->AIC_SSR = AIC_SSR_INTSEL(source);
  203298:	e59d3004 	ldr	r3, [sp, #4]
  20329c:	e203207f 	and	r2, r3, #127	; 0x7f
  2032a0:	e59d300c 	ldr	r3, [sp, #12]
  2032a4:	e5832000 	str	r2, [r3]
  aic->AIC_SVR = (uint32_t)handler;
  2032a8:	e59d2000 	ldr	r2, [sp]
  2032ac:	e59d300c 	ldr	r3, [sp, #12]
  2032b0:	e5832008 	str	r2, [r3, #8]
  /* Enable write protection */
  aicEnableWP(aic);
  2032b4:	e59d200c 	ldr	r2, [sp, #12]
  2032b8:	e3043301 	movw	r3, #17153	; 0x4301
  2032bc:	e3443149 	movt	r3, #16713	; 0x4149
  2032c0:	e58230e4 	str	r3, [r2, #228]	; 0xe4
}
  2032c4:	e28dd010 	add	sp, sp, #16
  2032c8:	e12fff1e 	bx	lr
  2032cc:	00000000 	andeq	r0, r0, r0

002032d0 <aicEnableInt>:
/**
 * @brief   Enables interrupts coming from the source.
 *
 * @param[in] source    interrupt source to enable
 */
void aicEnableInt(uint32_t source) {
  2032d0:	e24dd010 	sub	sp, sp, #16
  2032d4:	e58d0004 	str	r0, [sp, #4]

#if SAMA_HAL_IS_SECURE
  Aic *aic = SAIC;
  2032d8:	e3a03903 	mov	r3, #49152	; 0xc000
  2032dc:	e34f3803 	movt	r3, #63491	; 0xf803
  2032e0:	e58d300c 	str	r3, [sp, #12]
#else
  Aic *aic = AIC;
#endif

  aic->AIC_SSR = AIC_SSR_INTSEL(source);
  2032e4:	e59d3004 	ldr	r3, [sp, #4]
  2032e8:	e203207f 	and	r2, r3, #127	; 0x7f
  2032ec:	e59d300c 	ldr	r3, [sp, #12]
  2032f0:	e5832000 	str	r2, [r3]
  aic->AIC_IECR = AIC_IECR_INTEN;
  2032f4:	e59d300c 	ldr	r3, [sp, #12]
  2032f8:	e3a02001 	mov	r2, #1
  2032fc:	e5832040 	str	r2, [r3, #64]	; 0x40
}
  203300:	e28dd010 	add	sp, sp, #16
  203304:	e12fff1e 	bx	lr
	...

00203310 <dmaHandler>:
/*===========================================================================*/

/**
 * @brief XDMAC interrupt handler
 */
OSAL_IRQ_HANDLER(dmaHandler) {
  203310:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203314:	e24dd024 	sub	sp, sp, #36	; 0x24
  uint32_t cont;

  OSAL_IRQ_PROLOGUE();
  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  203318:	e3a03000 	mov	r3, #0
  20331c:	e58d301c 	str	r3, [sp, #28]
  203320:	ea00006c 	b	2034d8 <dmaHandler+0x1c8>
    uint32_t chan, gis, flags;

    Xdmac *xdmac = dmaControllerSelect(cont);
  203324:	e59d301c 	ldr	r3, [sp, #28]
  203328:	e3530000 	cmp	r3, #0
  20332c:	1a000002 	bne	20333c <dmaHandler+0x2c>
  203330:	e3a03000 	mov	r3, #0
  203334:	e34f3001 	movt	r3, #61441	; 0xf001
  203338:	ea000001 	b	203344 <dmaHandler+0x34>
  20333c:	e3a03901 	mov	r3, #16384	; 0x4000
  203340:	e34f3000 	movt	r3, #61440	; 0xf000
  203344:	e58d3010 	str	r3, [sp, #16]

    /* Read Global Interrupt Status Register */
    gis = dmaGetGlobalInt(xdmac);
  203348:	e59d3010 	ldr	r3, [sp, #16]
  20334c:	e5933018 	ldr	r3, [r3, #24]
  203350:	e58d300c 	str	r3, [sp, #12]

    if ((gis & 0xFFFF) == 0)
  203354:	e59d300c 	ldr	r3, [sp, #12]
  203358:	e6ff3073 	uxth	r3, r3
  20335c:	e3530000 	cmp	r3, #0
  203360:	0a000058 	beq	2034c8 <dmaHandler+0x1b8>
    /* There is no interrupt pending for this xdmac controller */
      continue;

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  203364:	e3a03000 	mov	r3, #0
  203368:	e58d3018 	str	r3, [sp, #24]
  20336c:	ea000051 	b	2034b8 <dmaHandler+0x1a8>
      sama_dma_channel_t *channel = &_sama_dma_channel_t[(cont * XDMAC_CHANNELS) + chan];
  203370:	e59d301c 	ldr	r3, [sp, #28]
  203374:	e1a02203 	lsl	r2, r3, #4
  203378:	e59d3018 	ldr	r3, [sp, #24]
  20337c:	e0823003 	add	r3, r2, r3
  203380:	e1a02203 	lsl	r2, r3, #4
  203384:	e30039f0 	movw	r3, #2544	; 0x9f0
  203388:	e3403021 	movt	r3, #33	; 0x21
  20338c:	e0823003 	add	r3, r2, r3
  203390:	e58d3008 	str	r3, [sp, #8]
      bool pendingInt = FALSE;
  203394:	e3a03000 	mov	r3, #0
  203398:	e5cd3017 	strb	r3, [sp, #23]

      if (!(gis & (0x1 << chan)))
  20339c:	e3a02001 	mov	r2, #1
  2033a0:	e59d3018 	ldr	r3, [sp, #24]
  2033a4:	e1a03312 	lsl	r3, r2, r3
  2033a8:	e1a02003 	mov	r2, r3
  2033ac:	e59d300c 	ldr	r3, [sp, #12]
  2033b0:	e0033002 	and	r3, r3, r2
  2033b4:	e3530000 	cmp	r3, #0
  2033b8:	0a000038 	beq	2034a0 <dmaHandler+0x190>
      /* There is no pending interrupt for this channel */
        continue;

      if (channel->state == SAMA_DMA_FREE)
  2033bc:	e59d3008 	ldr	r3, [sp, #8]
  2033c0:	e5d33005 	ldrb	r3, [r3, #5]
  2033c4:	e3530000 	cmp	r3, #0
  2033c8:	0a000036 	beq	2034a8 <dmaHandler+0x198>
      /* Channel is free */
        continue;

      uint32_t cis = dmaGetChannelInt(channel);
  2033cc:	e59d3008 	ldr	r3, [sp, #8]
  2033d0:	e5932000 	ldr	r2, [r3]
  2033d4:	e59d3008 	ldr	r3, [sp, #8]
  2033d8:	e5d33004 	ldrb	r3, [r3, #4]
  2033dc:	e1a03303 	lsl	r3, r3, #6
  2033e0:	e0823003 	add	r3, r2, r3
  2033e4:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
  2033e8:	e58d3004 	str	r3, [sp, #4]

      if (cis & XDMAC_CIS_BIS) {
  2033ec:	e59d3004 	ldr	r3, [sp, #4]
  2033f0:	e2033001 	and	r3, r3, #1
  2033f4:	e3530000 	cmp	r3, #0
  2033f8:	0a00000b 	beq	20342c <dmaHandler+0x11c>
        if (!(dmaGetChannelIntMask(channel) & XDMAC_CIM_LIM)) {
  2033fc:	e59d3008 	ldr	r3, [sp, #8]
  203400:	e5932000 	ldr	r2, [r3]
  203404:	e59d3008 	ldr	r3, [sp, #8]
  203408:	e5d33004 	ldrb	r3, [r3, #4]
  20340c:	e1a03303 	lsl	r3, r3, #6
  203410:	e0823003 	add	r3, r2, r3
  203414:	e5933058 	ldr	r3, [r3, #88]	; 0x58
  203418:	e2033002 	and	r3, r3, #2
  20341c:	e3530000 	cmp	r3, #0
  203420:	1a000001 	bne	20342c <dmaHandler+0x11c>
          pendingInt = TRUE;
  203424:	e3a03001 	mov	r3, #1
  203428:	e5cd3017 	strb	r3, [sp, #23]
        }
      }

      if (cis & XDMAC_CIS_LIS) {
  20342c:	e59d3004 	ldr	r3, [sp, #4]
  203430:	e2033002 	and	r3, r3, #2
  203434:	e3530000 	cmp	r3, #0
  203438:	0a000001 	beq	203444 <dmaHandler+0x134>
        pendingInt = TRUE;
  20343c:	e3a03001 	mov	r3, #1
  203440:	e5cd3017 	strb	r3, [sp, #23]
      }

      if (cis & XDMAC_CIS_DIS) {
  203444:	e59d3004 	ldr	r3, [sp, #4]
  203448:	e2033004 	and	r3, r3, #4
  20344c:	e3530000 	cmp	r3, #0
  203450:	0a000001 	beq	20345c <dmaHandler+0x14c>
        pendingInt = TRUE;
  203454:	e3a03001 	mov	r3, #1
  203458:	e5cd3017 	strb	r3, [sp, #23]
      }
      flags = cis;
  20345c:	e59d3004 	ldr	r3, [sp, #4]
  203460:	e58d3000 	str	r3, [sp]

      /* Execute callback */
      if (pendingInt && channel->dma_func) {
  203464:	e5dd3017 	ldrb	r3, [sp, #23]
  203468:	e3530000 	cmp	r3, #0
  20346c:	0a00000e 	beq	2034ac <dmaHandler+0x19c>
  203470:	e59d3008 	ldr	r3, [sp, #8]
  203474:	e5933008 	ldr	r3, [r3, #8]
  203478:	e3530000 	cmp	r3, #0
  20347c:	0a00000a 	beq	2034ac <dmaHandler+0x19c>
        channel->dma_func(channel->dma_param,flags);
  203480:	e59d3008 	ldr	r3, [sp, #8]
  203484:	e5933008 	ldr	r3, [r3, #8]
  203488:	e59d2008 	ldr	r2, [sp, #8]
  20348c:	e592200c 	ldr	r2, [r2, #12]
  203490:	e59d1000 	ldr	r1, [sp]
  203494:	e1a00002 	mov	r0, r2
  203498:	e12fff33 	blx	r3
  20349c:	ea000002 	b	2034ac <dmaHandler+0x19c>
      sama_dma_channel_t *channel = &_sama_dma_channel_t[(cont * XDMAC_CHANNELS) + chan];
      bool pendingInt = FALSE;

      if (!(gis & (0x1 << chan)))
      /* There is no pending interrupt for this channel */
        continue;
  2034a0:	e1a00000 	nop			; (mov r0, r0)
  2034a4:	ea000000 	b	2034ac <dmaHandler+0x19c>

      if (channel->state == SAMA_DMA_FREE)
      /* Channel is free */
        continue;
  2034a8:	e1a00000 	nop			; (mov r0, r0)

    if ((gis & 0xFFFF) == 0)
    /* There is no interrupt pending for this xdmac controller */
      continue;

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  2034ac:	e59d3018 	ldr	r3, [sp, #24]
  2034b0:	e2833001 	add	r3, r3, #1
  2034b4:	e58d3018 	str	r3, [sp, #24]
  2034b8:	e59d3018 	ldr	r3, [sp, #24]
  2034bc:	e353000f 	cmp	r3, #15
  2034c0:	9affffaa 	bls	203370 <dmaHandler+0x60>
  2034c4:	ea000000 	b	2034cc <dmaHandler+0x1bc>
    /* Read Global Interrupt Status Register */
    gis = dmaGetGlobalInt(xdmac);

    if ((gis & 0xFFFF) == 0)
    /* There is no interrupt pending for this xdmac controller */
      continue;
  2034c8:	e1a00000 	nop			; (mov r0, r0)
 */
OSAL_IRQ_HANDLER(dmaHandler) {
  uint32_t cont;

  OSAL_IRQ_PROLOGUE();
  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  2034cc:	e59d301c 	ldr	r3, [sp, #28]
  2034d0:	e2833001 	add	r3, r3, #1
  2034d4:	e58d301c 	str	r3, [sp, #28]
  2034d8:	e59d301c 	ldr	r3, [sp, #28]
  2034dc:	e3530001 	cmp	r3, #1
  2034e0:	9affff8f 	bls	203324 <dmaHandler+0x14>
      if (pendingInt && channel->dma_func) {
        channel->dma_func(channel->dma_param,flags);
      }
    }
  }
  aicAckInt();
  2034e4:	e3a03903 	mov	r3, #49152	; 0xc000
  2034e8:	e34f3803 	movt	r3, #63491	; 0xf803
  2034ec:	e3a02001 	mov	r2, #1
  2034f0:	e5832038 	str	r2, [r3, #56]	; 0x38
  OSAL_IRQ_EPILOGUE();
  2034f4:	eb000555 	bl	204a50 <chSchIsPreemptionRequired>
  2034f8:	e1a03000 	mov	r3, r0
}
  2034fc:	e1a00003 	mov	r0, r3
  203500:	e28dd024 	add	sp, sp, #36	; 0x24
  203504:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203510 <dmaInit>:
/**
 * @brief   SAMA DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
  203510:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203514:	e24dd014 	sub	sp, sp, #20

  uint8_t cont, chan;

  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  203518:	e3a03000 	mov	r3, #0
  20351c:	e5cd300f 	strb	r3, [sp, #15]
  203520:	ea00003d 	b	20361c <dmaInit+0x10c>

    Xdmac *xdmac = dmaControllerSelect(cont);
  203524:	e5dd300f 	ldrb	r3, [sp, #15]
  203528:	e3530000 	cmp	r3, #0
  20352c:	1a000002 	bne	20353c <dmaInit+0x2c>
  203530:	e3a03000 	mov	r3, #0
  203534:	e34f3001 	movt	r3, #61441	; 0xf001
  203538:	ea000001 	b	203544 <dmaInit+0x34>
  20353c:	e3a03901 	mov	r3, #16384	; 0x4000
  203540:	e34f3000 	movt	r3, #61440	; 0xf000
  203544:	e58d3008 	str	r3, [sp, #8]

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  203548:	e3a03000 	mov	r3, #0
  20354c:	e5cd300e 	strb	r3, [sp, #14]
  203550:	ea00001e 	b	2035d0 <dmaInit+0xc0>
      sama_dma_channel_t *channel = &_sama_dma_channel_t[(cont * XDMAC_CHANNELS) + chan];
  203554:	e5dd300f 	ldrb	r3, [sp, #15]
  203558:	e1a02203 	lsl	r2, r3, #4
  20355c:	e5dd300e 	ldrb	r3, [sp, #14]
  203560:	e0823003 	add	r3, r2, r3
  203564:	e1a02203 	lsl	r2, r3, #4
  203568:	e30039f0 	movw	r3, #2544	; 0x9f0
  20356c:	e3403021 	movt	r3, #33	; 0x21
  203570:	e0823003 	add	r3, r2, r3
  203574:	e58d3004 	str	r3, [sp, #4]

      /* Initialization of the specific channel */
      channel->xdmac    = xdmac;
  203578:	e59d3004 	ldr	r3, [sp, #4]
  20357c:	e59d2008 	ldr	r2, [sp, #8]
  203580:	e5832000 	str	r2, [r3]
      channel->chid     = chan;
  203584:	e59d3004 	ldr	r3, [sp, #4]
  203588:	e5dd200e 	ldrb	r2, [sp, #14]
  20358c:	e5c32004 	strb	r2, [r3, #4]
      channel->state    = SAMA_DMA_FREE;
  203590:	e59d3004 	ldr	r3, [sp, #4]
  203594:	e3a02000 	mov	r2, #0
  203598:	e5c32005 	strb	r2, [r3, #5]
      channel->dma_func = NULL;
  20359c:	e59d3004 	ldr	r3, [sp, #4]
  2035a0:	e3a02000 	mov	r2, #0
  2035a4:	e5832008 	str	r2, [r3, #8]

      /* Clear interrupts */
      dmaGetChannelInt(channel);
  2035a8:	e59d3004 	ldr	r3, [sp, #4]
  2035ac:	e5932000 	ldr	r2, [r3]
  2035b0:	e59d3004 	ldr	r3, [sp, #4]
  2035b4:	e5d33004 	ldrb	r3, [r3, #4]
  2035b8:	e1a03303 	lsl	r3, r3, #6
  2035bc:	e0823003 	add	r3, r2, r3
  2035c0:	e593305c 	ldr	r3, [r3, #92]	; 0x5c

  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {

    Xdmac *xdmac = dmaControllerSelect(cont);

    for (chan = 0; chan < XDMAC_CHANNELS; chan++) {
  2035c4:	e5dd300e 	ldrb	r3, [sp, #14]
  2035c8:	e2833001 	add	r3, r3, #1
  2035cc:	e5cd300e 	strb	r3, [sp, #14]
  2035d0:	e5dd300e 	ldrb	r3, [sp, #14]
  2035d4:	e353000f 	cmp	r3, #15
  2035d8:	9affffdd 	bls	203554 <dmaInit+0x44>

      /* Clear interrupts */
      dmaGetChannelInt(channel);
    }

    uint32_t id = dmaGetControllerId(xdmac);
  2035dc:	e59d2008 	ldr	r2, [sp, #8]
  2035e0:	e3a03000 	mov	r3, #0
  2035e4:	e34f3001 	movt	r3, #61441	; 0xf001
  2035e8:	e1520003 	cmp	r2, r3
  2035ec:	1a000001 	bne	2035f8 <dmaInit+0xe8>
  2035f0:	e3a03006 	mov	r3, #6
  2035f4:	ea000000 	b	2035fc <dmaInit+0xec>
  2035f8:	e3a03007 	mov	r3, #7
  2035fc:	e58d3000 	str	r3, [sp]
    /* set aic source handler */
    aicSetSourceHandler(id, dmaHandler);
  203600:	e3031310 	movw	r1, #13072	; 0x3310
  203604:	e3401020 	movt	r1, #32
  203608:	e59d0000 	ldr	r0, [sp]
  20360c:	ebffff17 	bl	203270 <aicSetSourceHandler>
 */
void dmaInit(void) {

  uint8_t cont, chan;

  for (cont = 0; cont < XDMAC_CONTROLLERS; cont++) {
  203610:	e5dd300f 	ldrb	r3, [sp, #15]
  203614:	e2833001 	add	r3, r3, #1
  203618:	e5cd300f 	strb	r3, [sp, #15]
  20361c:	e5dd300f 	ldrb	r3, [sp, #15]
  203620:	e3530001 	cmp	r3, #1
  203624:	9affffbe 	bls	203524 <dmaInit+0x14>

    uint32_t id = dmaGetControllerId(xdmac);
    /* set aic source handler */
    aicSetSourceHandler(id, dmaHandler);
  }
}
  203628:	e28dd014 	add	sp, sp, #20
  20362c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00203630 <dmaChannelSetTransactionSize>:
 * @param[in] dmastp    pointer to a sama_dma_channel_t structure
 * @param[in] size      value to be written in the XDMAC_CUBC register
 *
 * @special
 */
void dmaChannelSetTransactionSize(sama_dma_channel_t *dmachp, size_t n) {
  203630:	e92d4030 	push	{r4, r5, lr}
  203634:	e24dd014 	sub	sp, sp, #20
  203638:	e58d0004 	str	r0, [sp, #4]
  20363c:	e58d1000 	str	r1, [sp]

uint32_t i;
uint32_t divisor;
  /* Single block single microblock */
  if (n <= XDMAC_MAX_BT_SIZE) {
  203640:	e59d3000 	ldr	r3, [sp]
  203644:	e3530401 	cmp	r3, #16777216	; 0x1000000
  203648:	2a00000a 	bcs	203678 <dmaChannelSetTransactionSize+0x48>
    (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(n);
  20364c:	e59d3004 	ldr	r3, [sp, #4]
  203650:	e5931000 	ldr	r1, [r3]
  203654:	e59d3004 	ldr	r3, [sp, #4]
  203658:	e5d33004 	ldrb	r3, [r3, #4]
  20365c:	e1a00003 	mov	r0, r3
  203660:	e59d3000 	ldr	r3, [sp]
  203664:	e3c324ff 	bic	r2, r3, #-16777216	; 0xff000000
  203668:	e1a03300 	lsl	r3, r0, #6
  20366c:	e0813003 	add	r3, r1, r3
  203670:	e5832070 	str	r2, [r3, #112]	; 0x70
  203674:	ea000036 	b	203754 <dmaChannelSetTransactionSize+0x124>
  }
  /* Single block multiple microblocks */
  else {
   /* If n exceeds XDMAC_MAX_BT_SIZE, split the transfer in microblocks */
    for (i = 2; i < XDMAC_MAX_BT_SIZE; i++) {
  203678:	e3a03002 	mov	r3, #2
  20367c:	e58d300c 	str	r3, [sp, #12]
  203680:	ea00002e 	b	203740 <dmaChannelSetTransactionSize+0x110>
      divisor = XDMAC_MAX_BT_SIZE / i;
  203684:	e59d100c 	ldr	r1, [sp, #12]
  203688:	e3e004ff 	mvn	r0, #-16777216	; 0xff000000
  20368c:	ebfff327 	bl	200330 <__aeabi_uidiv>
  203690:	e1a03000 	mov	r3, r0
  203694:	e58d3008 	str	r3, [sp, #8]
      if (n % divisor)
  203698:	e59d3000 	ldr	r3, [sp]
  20369c:	e59d1008 	ldr	r1, [sp, #8]
  2036a0:	e1a00003 	mov	r0, r3
  2036a4:	ebfff39c 	bl	20051c <__aeabi_uidivmod>
  2036a8:	e1a03001 	mov	r3, r1
  2036ac:	e3530000 	cmp	r3, #0
  2036b0:	1a00001e 	bne	203730 <dmaChannelSetTransactionSize+0x100>
        continue;
      if ((n / divisor) <= XDMAC_MAX_BLOCK_LEN) {
  2036b4:	e59d1008 	ldr	r1, [sp, #8]
  2036b8:	e59d0000 	ldr	r0, [sp]
  2036bc:	ebfff31b 	bl	200330 <__aeabi_uidiv>
  2036c0:	e1a03000 	mov	r3, r0
  2036c4:	e3530a01 	cmp	r3, #4096	; 0x1000
  2036c8:	2a000019 	bcs	203734 <dmaChannelSetTransactionSize+0x104>
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(i);
  2036cc:	e59d3004 	ldr	r3, [sp, #4]
  2036d0:	e5931000 	ldr	r1, [r3]
  2036d4:	e59d3004 	ldr	r3, [sp, #4]
  2036d8:	e5d33004 	ldrb	r3, [r3, #4]
  2036dc:	e1a00003 	mov	r0, r3
  2036e0:	e59d300c 	ldr	r3, [sp, #12]
  2036e4:	e3c324ff 	bic	r2, r3, #-16777216	; 0xff000000
  2036e8:	e1a03300 	lsl	r3, r0, #6
  2036ec:	e0813003 	add	r3, r1, r3
  2036f0:	e5832070 	str	r2, [r3, #112]	; 0x70
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CBC =
  2036f4:	e59d3004 	ldr	r3, [sp, #4]
  2036f8:	e5934000 	ldr	r4, [r3]
  2036fc:	e59d3004 	ldr	r3, [sp, #4]
  203700:	e5d33004 	ldrb	r3, [r3, #4]
  203704:	e1a05003 	mov	r5, r3
                                                   XDMAC_CBC_BLEN((n / divisor) - 1);
  203708:	e59d1008 	ldr	r1, [sp, #8]
  20370c:	e59d0000 	ldr	r0, [sp]
  203710:	ebfff306 	bl	200330 <__aeabi_uidiv>
  203714:	e1a03000 	mov	r3, r0
  203718:	e2433001 	sub	r3, r3, #1
  20371c:	e7eb2053 	ubfx	r2, r3, #0, #12
      divisor = XDMAC_MAX_BT_SIZE / i;
      if (n % divisor)
        continue;
      if ((n / divisor) <= XDMAC_MAX_BLOCK_LEN) {
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(i);
        (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CBC =
  203720:	e1a03305 	lsl	r3, r5, #6
  203724:	e0843003 	add	r3, r4, r3
  203728:	e5832074 	str	r2, [r3, #116]	; 0x74
  20372c:	ea000008 	b	203754 <dmaChannelSetTransactionSize+0x124>
  else {
   /* If n exceeds XDMAC_MAX_BT_SIZE, split the transfer in microblocks */
    for (i = 2; i < XDMAC_MAX_BT_SIZE; i++) {
      divisor = XDMAC_MAX_BT_SIZE / i;
      if (n % divisor)
        continue;
  203730:	e1a00000 	nop			; (mov r0, r0)
    (dmachp)->xdmac->XDMAC_CHID[(dmachp)->chid].XDMAC_CUBC = XDMAC_CUBC_UBLEN(n);
  }
  /* Single block multiple microblocks */
  else {
   /* If n exceeds XDMAC_MAX_BT_SIZE, split the transfer in microblocks */
    for (i = 2; i < XDMAC_MAX_BT_SIZE; i++) {
  203734:	e59d300c 	ldr	r3, [sp, #12]
  203738:	e2833001 	add	r3, r3, #1
  20373c:	e58d300c 	str	r3, [sp, #12]
  203740:	e59d200c 	ldr	r2, [sp, #12]
  203744:	e30f3ffe 	movw	r3, #65534	; 0xfffe
  203748:	e34030ff 	movt	r3, #255	; 0xff
  20374c:	e1520003 	cmp	r2, r3
  203750:	9affffcb 	bls	203684 <dmaChannelSetTransactionSize+0x54>
        break;
      }
    }
    osalDbgAssert(n == XDMAC_MAX_BT_SIZE, "unsupported DMA transfer size");
  }
}
  203754:	e28dd014 	add	sp, sp, #20
  203758:	e8bd8030 	pop	{r4, r5, pc}
  20375c:	00000000 	andeq	r0, r0, r0

00203760 <dmaChannelAllocate>:
 *
 * @special
 */
sama_dma_channel_t* dmaChannelAllocate(uint32_t priority,
                                       sama_dmaisr_t func,
                                       void *param) {
  203760:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203764:	e24dd01c 	sub	sp, sp, #28
  203768:	e58d000c 	str	r0, [sp, #12]
  20376c:	e58d1008 	str	r1, [sp, #8]
  203770:	e58d2004 	str	r2, [sp, #4]

  sama_dma_channel_t *channel = NULL;
  203774:	e3a03000 	mov	r3, #0
  203778:	e58d3014 	str	r3, [sp, #20]
  uint8_t id;
  uint8_t chan;
  for (chan = 0; chan < XDMAC_CHANNELS_TOT; chan++) {
  20377c:	e3a03000 	mov	r3, #0
  203780:	e5cd3013 	strb	r3, [sp, #19]
  203784:	ea00000e 	b	2037c4 <dmaChannelAllocate+0x64>
    channel = &_sama_dma_channel_t[chan];
  203788:	e5dd3013 	ldrb	r3, [sp, #19]
  20378c:	e1a02203 	lsl	r2, r3, #4
  203790:	e30039f0 	movw	r3, #2544	; 0x9f0
  203794:	e3403021 	movt	r3, #33	; 0x21
  203798:	e0823003 	add	r3, r2, r3
  20379c:	e58d3014 	str	r3, [sp, #20]
    if (channel->state != SAMA_DMA_FREE) {
  2037a0:	e59d3014 	ldr	r3, [sp, #20]
  2037a4:	e5d33005 	ldrb	r3, [r3, #5]
  2037a8:	e3530000 	cmp	r3, #0
  2037ac:	0a000007 	beq	2037d0 <dmaChannelAllocate+0x70>
      channel = NULL;
  2037b0:	e3a03000 	mov	r3, #0
  2037b4:	e58d3014 	str	r3, [sp, #20]
                                       void *param) {

  sama_dma_channel_t *channel = NULL;
  uint8_t id;
  uint8_t chan;
  for (chan = 0; chan < XDMAC_CHANNELS_TOT; chan++) {
  2037b8:	e5dd3013 	ldrb	r3, [sp, #19]
  2037bc:	e2833001 	add	r3, r3, #1
  2037c0:	e5cd3013 	strb	r3, [sp, #19]
  2037c4:	e5dd3013 	ldrb	r3, [sp, #19]
  2037c8:	e353001f 	cmp	r3, #31
  2037cc:	9affffed 	bls	203788 <dmaChannelAllocate+0x28>
    else {
      break;
    }
  }

  if (channel != NULL) {
  2037d0:	e59d3014 	ldr	r3, [sp, #20]
  2037d4:	e3530000 	cmp	r3, #0
  2037d8:	0a000051 	beq	203924 <dmaChannelAllocate+0x1c4>
  /* Marks the channel as allocated.*/
    channel->state = SAMA_DMA_NOT_FREE;
  2037dc:	e59d3014 	ldr	r3, [sp, #20]
  2037e0:	e3a02001 	mov	r2, #1
  2037e4:	e5c32005 	strb	r2, [r3, #5]
    channel->dma_func = func;
  2037e8:	e59d3014 	ldr	r3, [sp, #20]
  2037ec:	e59d2008 	ldr	r2, [sp, #8]
  2037f0:	e5832008 	str	r2, [r3, #8]
    channel->dma_param = param;
  2037f4:	e59d3014 	ldr	r3, [sp, #20]
  2037f8:	e59d2004 	ldr	r2, [sp, #4]
  2037fc:	e583200c 	str	r2, [r3, #12]
    id = dmaGetControllerId(channel->xdmac);
  203800:	e59d3014 	ldr	r3, [sp, #20]
  203804:	e5932000 	ldr	r2, [r3]
  203808:	e3a03000 	mov	r3, #0
  20380c:	e34f3001 	movt	r3, #61441	; 0xf001
  203810:	e1520003 	cmp	r2, r3
  203814:	1a000001 	bne	203820 <dmaChannelAllocate+0xc0>
  203818:	e3a03006 	mov	r3, #6
  20381c:	ea000000 	b	203824 <dmaChannelAllocate+0xc4>
  203820:	e3a03007 	mov	r3, #7
  203824:	e5cd3012 	strb	r3, [sp, #18]

  /* Setting aic */
    aicSetSourcePriority(id, priority);
  203828:	e5dd3012 	ldrb	r3, [sp, #18]
  20382c:	e59d200c 	ldr	r2, [sp, #12]
  203830:	e6ef2072 	uxtb	r2, r2
  203834:	e1a01002 	mov	r1, r2
  203838:	e1a00003 	mov	r0, r3
  20383c:	ebfffe6b 	bl	2031f0 <aicSetSourcePriority>
    aicEnableInt(id);
  203840:	e5dd3012 	ldrb	r3, [sp, #18]
  203844:	e1a00003 	mov	r0, r3
  203848:	ebfffea0 	bl	2032d0 <aicEnableInt>

  /* Enabling DMA clocks required by the current channel set.*/
    if (id == ID_XDMAC0) {
  20384c:	e5dd3012 	ldrb	r3, [sp, #18]
  203850:	e3530006 	cmp	r3, #6
  203854:	1a000011 	bne	2038a0 <dmaChannelAllocate+0x140>
      pmcEnableXDMAC0();
  203858:	e3a03901 	mov	r3, #16384	; 0x4000
  20385c:	e34f3001 	movt	r3, #61441	; 0xf001
  203860:	e3a02c43 	mov	r2, #17152	; 0x4300
  203864:	e345204d 	movt	r2, #20557	; 0x504d
  203868:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  20386c:	e3a03901 	mov	r3, #16384	; 0x4000
  203870:	e34f3001 	movt	r3, #61441	; 0xf001
  203874:	e3a02901 	mov	r2, #16384	; 0x4000
  203878:	e34f2001 	movt	r2, #61441	; 0xf001
  20387c:	e5922010 	ldr	r2, [r2, #16]
  203880:	e3822040 	orr	r2, r2, #64	; 0x40
  203884:	e5832010 	str	r2, [r3, #16]
  203888:	e3a03901 	mov	r3, #16384	; 0x4000
  20388c:	e34f3001 	movt	r3, #61441	; 0xf001
  203890:	e3042301 	movw	r2, #17153	; 0x4301
  203894:	e345204d 	movt	r2, #20557	; 0x504d
  203898:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  20389c:	ea000010 	b	2038e4 <dmaChannelAllocate+0x184>
    }
    else {
      pmcEnableXDMAC1();
  2038a0:	e3a03901 	mov	r3, #16384	; 0x4000
  2038a4:	e34f3001 	movt	r3, #61441	; 0xf001
  2038a8:	e3a02c43 	mov	r2, #17152	; 0x4300
  2038ac:	e345204d 	movt	r2, #20557	; 0x504d
  2038b0:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  2038b4:	e3a03901 	mov	r3, #16384	; 0x4000
  2038b8:	e34f3001 	movt	r3, #61441	; 0xf001
  2038bc:	e3a02901 	mov	r2, #16384	; 0x4000
  2038c0:	e34f2001 	movt	r2, #61441	; 0xf001
  2038c4:	e5922010 	ldr	r2, [r2, #16]
  2038c8:	e3822080 	orr	r2, r2, #128	; 0x80
  2038cc:	e5832010 	str	r2, [r3, #16]
  2038d0:	e3a03901 	mov	r3, #16384	; 0x4000
  2038d4:	e34f3001 	movt	r3, #61441	; 0xf001
  2038d8:	e3042301 	movw	r2, #17153	; 0x4301
  2038dc:	e345204d 	movt	r2, #20557	; 0x504d
  2038e0:	e58320e4 	str	r2, [r3, #228]	; 0xe4
    }

  /* Enable channel interrupt */
    channel->xdmac->XDMAC_CHID[channel->chid].XDMAC_CIE =  XDMAC_CIE_BIE;
  2038e4:	e59d3014 	ldr	r3, [sp, #20]
  2038e8:	e5932000 	ldr	r2, [r3]
  2038ec:	e59d3014 	ldr	r3, [sp, #20]
  2038f0:	e5d33004 	ldrb	r3, [r3, #4]
  2038f4:	e1a03303 	lsl	r3, r3, #6
  2038f8:	e0823003 	add	r3, r2, r3
  2038fc:	e3a02001 	mov	r2, #1
  203900:	e5832050 	str	r2, [r3, #80]	; 0x50
    channel->xdmac->XDMAC_GIE = XDMAC_GIE_IE0 << (channel->chid);
  203904:	e59d3014 	ldr	r3, [sp, #20]
  203908:	e5933000 	ldr	r3, [r3]
  20390c:	e59d2014 	ldr	r2, [sp, #20]
  203910:	e5d22004 	ldrb	r2, [r2, #4]
  203914:	e1a01002 	mov	r1, r2
  203918:	e3a02001 	mov	r2, #1
  20391c:	e1a02112 	lsl	r2, r2, r1
  203920:	e583200c 	str	r2, [r3, #12]
  }
  return channel;
  203924:	e59d3014 	ldr	r3, [sp, #20]
}
  203928:	e1a00003 	mov	r0, r3
  20392c:	e28dd01c 	add	sp, sp, #28
  203930:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203940 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  203940:	e24dd018 	sub	sp, sp, #24
  203944:	e58d000c 	str	r0, [sp, #12]
  203948:	e58d1008 	str	r1, [sp, #8]
  20394c:	e58d2004 	str	r2, [sp, #4]

  uint32_t mskr = (mask);
  203950:	e59d3008 	ldr	r3, [sp, #8]
  203954:	e58d3014 	str	r3, [sp, #20]
  uint32_t cfgr = (mode & (PAL_SAMA_CFGR_MASK));
  203958:	e59d2004 	ldr	r2, [sp, #4]
  20395c:	e30f3703 	movw	r3, #63235	; 0xf703
  203960:	e3403003 	movt	r3, #3
  203964:	e0033002 	and	r3, r3, r2
  203968:	e58d3010 	str	r3, [sp, #16]

#if SAMA_HAL_IS_SECURE
  if(mode && PAL_SAMA_SECURE_MASK) {
  20396c:	e59d3004 	ldr	r3, [sp, #4]
  203970:	e3530000 	cmp	r3, #0
  203974:	0a000003 	beq	203988 <_pal_lld_setgroupmode+0x48>
    port->SIOSR = mask;
  203978:	e59d300c 	ldr	r3, [sp, #12]
  20397c:	e59d2008 	ldr	r2, [sp, #8]
  203980:	e5832034 	str	r2, [r3, #52]	; 0x34
  203984:	ea000002 	b	203994 <_pal_lld_setgroupmode+0x54>
  }
  else {
    port->SIONR = mask;
  203988:	e59d300c 	ldr	r3, [sp, #12]
  20398c:	e59d2008 	ldr	r2, [sp, #8]
  203990:	e5832030 	str	r2, [r3, #48]	; 0x30
  }
#endif /* SAMA_HAL_IS_SECURE */
  port->MSKR = mskr;
  203994:	e59d300c 	ldr	r3, [sp, #12]
  203998:	e59d2014 	ldr	r2, [sp, #20]
  20399c:	e5832000 	str	r2, [r3]
  port->CFGR = cfgr;
  2039a0:	e59d300c 	ldr	r3, [sp, #12]
  2039a4:	e59d2010 	ldr	r2, [sp, #16]
  2039a8:	e5832004 	str	r2, [r3, #4]
}
  2039ac:	e28dd018 	add	sp, sp, #24
  2039b0:	e12fff1e 	bx	lr
	...

002039c0 <port_lock_from_isr.lto_priv.22>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  2039c0:	e12fff1e 	bx	lr
	...

002039d0 <port_unlock_from_isr.lto_priv.20>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  2039d0:	e12fff1e 	bx	lr
	...

002039e0 <chSysLockFromISR.lto_priv.18>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  2039e0:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  2039e4:	ebfffff5 	bl	2039c0 <port_lock_from_isr.lto_priv.22>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  2039e8:	e8bd8010 	pop	{r4, pc}
  2039ec:	00000000 	andeq	r0, r0, r0

002039f0 <chSysUnlockFromISR.lto_priv.16>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  2039f0:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  2039f4:	ebfffff5 	bl	2039d0 <port_unlock_from_isr.lto_priv.20>
}
  2039f8:	e8bd8010 	pop	{r4, pc}
  2039fc:	00000000 	andeq	r0, r0, r0

00203a00 <osalSysLockFromISR.lto_priv.14>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
  203a00:	e92d4010 	push	{r4, lr}

  chSysLockFromISR();
  203a04:	ebfffff5 	bl	2039e0 <chSysLockFromISR.lto_priv.18>
}
  203a08:	e8bd8010 	pop	{r4, pc}
  203a0c:	00000000 	andeq	r0, r0, r0

00203a10 <osalSysUnlockFromISR.lto_priv.12>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
  203a10:	e92d4010 	push	{r4, lr}

  chSysUnlockFromISR();
  203a14:	ebfffff5 	bl	2039f0 <chSysUnlockFromISR.lto_priv.16>
}
  203a18:	e8bd8010 	pop	{r4, pc}
  203a1c:	00000000 	andeq	r0, r0, r0

00203a20 <osalEventBroadcastFlagsI.lto_priv.13>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
  203a20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203a24:	e24dd00c 	sub	sp, sp, #12
  203a28:	e58d0004 	str	r0, [sp, #4]
  203a2c:	e58d1000 	str	r1, [sp]

  chEvtBroadcastFlagsI(esp, flags);
  203a30:	e59d1000 	ldr	r1, [sp]
  203a34:	e59d0004 	ldr	r0, [sp, #4]
  203a38:	eb0005c4 	bl	205150 <chEvtBroadcastFlagsI>
}
  203a3c:	e28dd00c 	add	sp, sp, #12
  203a40:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203a50 <uart_init.lto_priv.11>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void uart_init(SerialDriver *sdp, const SerialConfig *config) {
  203a50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203a54:	e24dd014 	sub	sp, sp, #20
  203a58:	e58d0004 	str	r0, [sp, #4]
  203a5c:	e58d1000 	str	r1, [sp]
#if SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM
  if (sdp->uart != NULL)
#endif /* SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM */
#if SAMA_SERIAL_USE_UART
  {
    Uart *u = sdp->uart;
  203a60:	e59d3004 	ldr	r3, [sp, #4]
  203a64:	e5933054 	ldr	r3, [r3, #84]	; 0x54
  203a68:	e58d300c 	str	r3, [sp, #12]

    /* Disabling write protection */
    sdDisableWP(u);
  203a6c:	e59d200c 	ldr	r2, [sp, #12]
  203a70:	e3a03c52 	mov	r3, #20992	; 0x5200
  203a74:	e3453541 	movt	r3, #21825	; 0x5541
  203a78:	e58230e4 	str	r3, [r2, #228]	; 0xe4
    /* Baud rate setting.*/
    u->UART_BRGR = UART_BRGR_CD(sdp->clock / (16 * config->speed));
  203a7c:	e59d3004 	ldr	r3, [sp, #4]
  203a80:	e5932060 	ldr	r2, [r3, #96]	; 0x60
  203a84:	e59d3000 	ldr	r3, [sp]
  203a88:	e5933000 	ldr	r3, [r3]
  203a8c:	e1a03203 	lsl	r3, r3, #4
  203a90:	e1a01003 	mov	r1, r3
  203a94:	e1a00002 	mov	r0, r2
  203a98:	ebfff224 	bl	200330 <__aeabi_uidiv>
  203a9c:	e1a03000 	mov	r3, r0
  203aa0:	e6ff2073 	uxth	r2, r3
  203aa4:	e59d300c 	ldr	r3, [sp, #12]
  203aa8:	e5832020 	str	r2, [r3, #32]

    u->UART_CR = config->cr;
  203aac:	e59d3000 	ldr	r3, [sp]
  203ab0:	e5932004 	ldr	r2, [r3, #4]
  203ab4:	e59d300c 	ldr	r3, [sp, #12]
  203ab8:	e5832000 	str	r2, [r3]
    u->UART_MR = config->mr;
  203abc:	e59d3000 	ldr	r3, [sp]
  203ac0:	e5932008 	ldr	r2, [r3, #8]
  203ac4:	e59d300c 	ldr	r3, [sp, #12]
  203ac8:	e5832004 	str	r2, [r3, #4]
    u->UART_IER = UART_IER_RXRDY;
  203acc:	e59d300c 	ldr	r3, [sp, #12]
  203ad0:	e3a02001 	mov	r2, #1
  203ad4:	e5832008 	str	r2, [r3, #8]

    /* Clearing error status bit */
    u->UART_CR |= UART_CR_RSTSTA;
  203ad8:	e59d300c 	ldr	r3, [sp, #12]
  203adc:	e5933000 	ldr	r3, [r3]
  203ae0:	e3832c01 	orr	r2, r3, #256	; 0x100
  203ae4:	e59d300c 	ldr	r3, [sp, #12]
  203ae8:	e5832000 	str	r2, [r3]
    /* Enabling Tx and Rx */
    u->UART_CR |= UART_CR_RXEN | UART_CR_TXEN;
  203aec:	e59d300c 	ldr	r3, [sp, #12]
  203af0:	e5933000 	ldr	r3, [r3]
  203af4:	e3832050 	orr	r2, r3, #80	; 0x50
  203af8:	e59d300c 	ldr	r3, [sp, #12]
  203afc:	e5832000 	str	r2, [r3]
    /* Enabling write protection */
    sdEnableWP(u);
  203b00:	e59d200c 	ldr	r2, [sp, #12]
  203b04:	e3053201 	movw	r3, #20993	; 0x5201
  203b08:	e3453541 	movt	r3, #21825	; 0x5541
  203b0c:	e58230e4 	str	r3, [r2, #228]	; 0xe4
#if SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM
  else {
    osalDbgAssert(FALSE, "invalid state");
  }
#endif /* SAMA_SERIAL_USE_UART && SAMA_SERIAL_USE_FLEXCOM */
}
  203b10:	e28dd014 	add	sp, sp, #20
  203b14:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203b20 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
  203b20:	e12fff1e 	bx	lr
	...

00203b30 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
  203b30:	e92d4010 	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
  203b34:	ebfffff9 	bl	203b20 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
  203b38:	ebfffc3c 	bl	202c30 <hal_lld_init>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
  203b3c:	ebfffb6b 	bl	2028f0 <sdInit>
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
  203b40:	ebfffbc6 	bl	202a60 <uartInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
  203b44:	ebfff74d 	bl	201880 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
  203b48:	eb000000 	bl	203b50 <stInit>
#endif
}
  203b4c:	e8bd8010 	pop	{r4, pc}

00203b50 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
  203b50:	e92d4010 	push	{r4, lr}

  st_lld_init();
  203b54:	ebfffd65 	bl	2030f0 <st_lld_init>
}
  203b58:	e8bd8010 	pop	{r4, pc}
  203b5c:	00000000 	andeq	r0, r0, r0

00203b60 <port_lock.lto_priv.58>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  203b60:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  203b64:	e12fff1e 	bx	lr
	...

00203b70 <port_unlock.lto_priv.56>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  203b70:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  203b74:	e12fff1e 	bx	lr
	...

00203b80 <queue_init.lto_priv.54>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  203b80:	e24dd008 	sub	sp, sp, #8
  203b84:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  203b88:	e59d3004 	ldr	r3, [sp, #4]
  203b8c:	e59d2004 	ldr	r2, [sp, #4]
  203b90:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  203b94:	e59d3004 	ldr	r3, [sp, #4]
  203b98:	e59d2004 	ldr	r2, [sp, #4]
  203b9c:	e5832004 	str	r2, [r3, #4]
}
  203ba0:	e28dd008 	add	sp, sp, #8
  203ba4:	e12fff1e 	bx	lr
	...

00203bb0 <chSysLock.lto_priv.52>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  203bb0:	e92d4010 	push	{r4, lr}

  port_lock();
  203bb4:	ebffffe9 	bl	203b60 <port_lock.lto_priv.58>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  203bb8:	e8bd8010 	pop	{r4, pc}
  203bbc:	00000000 	andeq	r0, r0, r0

00203bc0 <chSysUnlock.lto_priv.49>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  203bc0:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  203bc4:	ebffffe9 	bl	203b70 <port_unlock.lto_priv.56>
}
  203bc8:	e8bd8010 	pop	{r4, pc}
  203bcc:	00000000 	andeq	r0, r0, r0

00203bd0 <chVTGetSystemTimeX.lto_priv.46>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
  203bd0:	e3003950 	movw	r3, #2384	; 0x950
  203bd4:	e3403021 	movt	r3, #33	; 0x21
  203bd8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  203bdc:	e1a00003 	mov	r0, r3
  203be0:	e12fff1e 	bx	lr
	...

00203bf0 <chThdQueueObjectInit.lto_priv.44>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
  203bf0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203bf4:	e24dd00c 	sub	sp, sp, #12
  203bf8:	e58d0004 	str	r0, [sp, #4]

  queue_init(tqp);
  203bfc:	e59d0004 	ldr	r0, [sp, #4]
  203c00:	ebffffde 	bl	203b80 <queue_init.lto_priv.54>
}
  203c04:	e28dd00c 	add	sp, sp, #12
  203c08:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  203c0c:	00000000 	andeq	r0, r0, r0

00203c10 <osalSysLock.lto_priv.26>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
  203c10:	e92d4010 	push	{r4, lr}

  chSysLock();
  203c14:	ebffffe5 	bl	203bb0 <chSysLock.lto_priv.52>
}
  203c18:	e8bd8010 	pop	{r4, pc}
  203c1c:	00000000 	andeq	r0, r0, r0

00203c20 <osalSysUnlock.lto_priv.23>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
  203c20:	e92d4010 	push	{r4, lr}

  chSysUnlock();
  203c24:	ebffffe5 	bl	203bc0 <chSysUnlock.lto_priv.49>
}
  203c28:	e8bd8010 	pop	{r4, pc}
  203c2c:	00000000 	andeq	r0, r0, r0

00203c30 <osalOsGetSystemTimeX.lto_priv.39>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
  203c30:	e92d4010 	push	{r4, lr}

  return chVTGetSystemTimeX();
  203c34:	ebffffe5 	bl	203bd0 <chVTGetSystemTimeX.lto_priv.46>
  203c38:	e1a03000 	mov	r3, r0
}
  203c3c:	e1a00003 	mov	r0, r3
  203c40:	e8bd8010 	pop	{r4, pc}
	...

00203c50 <osalThreadQueueObjectInit.lto_priv.42>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
  203c50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203c54:	e24dd00c 	sub	sp, sp, #12
  203c58:	e58d0004 	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
  203c5c:	e59d0004 	ldr	r0, [sp, #4]
  203c60:	ebffffe2 	bl	203bf0 <chThdQueueObjectInit.lto_priv.44>
}
  203c64:	e28dd00c 	add	sp, sp, #12
  203c68:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  203c6c:	00000000 	andeq	r0, r0, r0

00203c70 <osalThreadEnqueueTimeoutS.lto_priv.38>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
  203c70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203c74:	e24dd00c 	sub	sp, sp, #12
  203c78:	e58d0004 	str	r0, [sp, #4]
  203c7c:	e58d1000 	str	r1, [sp]

  return chThdEnqueueTimeoutS(tqp, time);
  203c80:	e59d1000 	ldr	r1, [sp]
  203c84:	e59d0004 	ldr	r0, [sp, #4]
  203c88:	eb0004f0 	bl	205050 <chThdEnqueueTimeoutS>
  203c8c:	e1a03000 	mov	r3, r0
}
  203c90:	e1a00003 	mov	r0, r3
  203c94:	e28dd00c 	add	sp, sp, #12
  203c98:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  203c9c:	00000000 	andeq	r0, r0, r0

00203ca0 <osalThreadDequeueNextI.lto_priv.40>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  203ca0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203ca4:	e24dd00c 	sub	sp, sp, #12
  203ca8:	e58d0004 	str	r0, [sp, #4]
  203cac:	e58d1000 	str	r1, [sp]

  chThdDequeueNextI(tqp, msg);
  203cb0:	e59d1000 	ldr	r1, [sp]
  203cb4:	e59d0004 	ldr	r0, [sp, #4]
  203cb8:	eb0004fc 	bl	2050b0 <chThdDequeueNextI>
}
  203cbc:	e28dd00c 	add	sp, sp, #12
  203cc0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203cd0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
  203cd0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203cd4:	e24dd014 	sub	sp, sp, #20
  203cd8:	e58d000c 	str	r0, [sp, #12]
  203cdc:	e58d1008 	str	r1, [sp, #8]
  203ce0:	e58d2004 	str	r2, [sp, #4]
  203ce4:	e58d3000 	str	r3, [sp]

  osalThreadQueueObjectInit(&iqp->q_waiting);
  203ce8:	e59d300c 	ldr	r3, [sp, #12]
  203cec:	e1a00003 	mov	r0, r3
  203cf0:	ebffffd6 	bl	203c50 <osalThreadQueueObjectInit.lto_priv.42>
  iqp->q_counter = 0;
  203cf4:	e59d300c 	ldr	r3, [sp, #12]
  203cf8:	e3a02000 	mov	r2, #0
  203cfc:	e5832008 	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
  203d00:	e59d300c 	ldr	r3, [sp, #12]
  203d04:	e59d2008 	ldr	r2, [sp, #8]
  203d08:	e583200c 	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
  203d0c:	e59d300c 	ldr	r3, [sp, #12]
  203d10:	e59d2008 	ldr	r2, [sp, #8]
  203d14:	e5832018 	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
  203d18:	e59d300c 	ldr	r3, [sp, #12]
  203d1c:	e59d2008 	ldr	r2, [sp, #8]
  203d20:	e5832014 	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
  203d24:	e59d2008 	ldr	r2, [sp, #8]
  203d28:	e59d3004 	ldr	r3, [sp, #4]
  203d2c:	e0822003 	add	r2, r2, r3
  203d30:	e59d300c 	ldr	r3, [sp, #12]
  203d34:	e5832010 	str	r2, [r3, #16]
  iqp->q_notify  = infy;
  203d38:	e59d300c 	ldr	r3, [sp, #12]
  203d3c:	e59d2000 	ldr	r2, [sp]
  203d40:	e583201c 	str	r2, [r3, #28]
  iqp->q_link    = link;
  203d44:	e59d300c 	ldr	r3, [sp, #12]
  203d48:	e59d2018 	ldr	r2, [sp, #24]
  203d4c:	e5832020 	str	r2, [r3, #32]
}
  203d50:	e28dd014 	add	sp, sp, #20
  203d54:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203d60 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
  203d60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203d64:	e24dd00c 	sub	sp, sp, #12
  203d68:	e58d0004 	str	r0, [sp, #4]
  203d6c:	e1a03001 	mov	r3, r1
  203d70:	e5cd3003 	strb	r3, [sp, #3]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
  203d74:	e59d3004 	ldr	r3, [sp, #4]
  203d78:	e5932014 	ldr	r2, [r3, #20]
  203d7c:	e59d3004 	ldr	r3, [sp, #4]
  203d80:	e5933018 	ldr	r3, [r3, #24]
  203d84:	e1520003 	cmp	r2, r3
  203d88:	1a000005 	bne	203da4 <iqPutI+0x44>
  203d8c:	e59d3004 	ldr	r3, [sp, #4]
  203d90:	e5933008 	ldr	r3, [r3, #8]
  203d94:	e3530000 	cmp	r3, #0
  203d98:	0a000001 	beq	203da4 <iqPutI+0x44>
  203d9c:	e3a03001 	mov	r3, #1
  203da0:	ea000000 	b	203da8 <iqPutI+0x48>
  203da4:	e3a03000 	mov	r3, #0
  203da8:	e2033001 	and	r3, r3, #1
  203dac:	e3530000 	cmp	r3, #0
  203db0:	0a000001 	beq	203dbc <iqPutI+0x5c>
    return MSG_TIMEOUT;
  203db4:	e3e03000 	mvn	r3, #0
  203db8:	ea00001a 	b	203e28 <iqPutI+0xc8>
  }

  iqp->q_counter++;
  203dbc:	e59d3004 	ldr	r3, [sp, #4]
  203dc0:	e5933008 	ldr	r3, [r3, #8]
  203dc4:	e2832001 	add	r2, r3, #1
  203dc8:	e59d3004 	ldr	r3, [sp, #4]
  203dcc:	e5832008 	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
  203dd0:	e59d3004 	ldr	r3, [sp, #4]
  203dd4:	e5933014 	ldr	r3, [r3, #20]
  203dd8:	e2831001 	add	r1, r3, #1
  203ddc:	e59d2004 	ldr	r2, [sp, #4]
  203de0:	e5821014 	str	r1, [r2, #20]
  203de4:	e5dd2003 	ldrb	r2, [sp, #3]
  203de8:	e5c32000 	strb	r2, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
  203dec:	e59d3004 	ldr	r3, [sp, #4]
  203df0:	e5932014 	ldr	r2, [r3, #20]
  203df4:	e59d3004 	ldr	r3, [sp, #4]
  203df8:	e5933010 	ldr	r3, [r3, #16]
  203dfc:	e1520003 	cmp	r2, r3
  203e00:	3a000003 	bcc	203e14 <iqPutI+0xb4>
    iqp->q_wrptr = iqp->q_buffer;
  203e04:	e59d3004 	ldr	r3, [sp, #4]
  203e08:	e593200c 	ldr	r2, [r3, #12]
  203e0c:	e59d3004 	ldr	r3, [sp, #4]
  203e10:	e5832014 	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
  203e14:	e59d3004 	ldr	r3, [sp, #4]
  203e18:	e3a01000 	mov	r1, #0
  203e1c:	e1a00003 	mov	r0, r3
  203e20:	ebffff9e 	bl	203ca0 <osalThreadDequeueNextI.lto_priv.40>

  return MSG_OK;
  203e24:	e3a03000 	mov	r3, #0
}
  203e28:	e1a00003 	mov	r0, r3
  203e2c:	e28dd00c 	add	sp, sp, #12
  203e30:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203e40 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
  203e40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  203e44:	e24dd00c 	sub	sp, sp, #12
  203e48:	e58d0004 	str	r0, [sp, #4]
  203e4c:	e58d1000 	str	r1, [sp]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  203e50:	e59d3004 	ldr	r3, [sp, #4]
  203e54:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  203e58:	e59d3000 	ldr	r3, [sp]
  203e5c:	e1822003 	orr	r2, r2, r3
  203e60:	e59d3004 	ldr	r3, [sp, #4]
  203e64:	e5832038 	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
  203e68:	e59d3004 	ldr	r3, [sp, #4]
  203e6c:	e5d33020 	ldrb	r3, [r3, #32]
  203e70:	e353000a 	cmp	r3, #10
  203e74:	1a000006 	bne	203e94 <chEvtSignalI+0x54>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  203e78:	e59d3004 	ldr	r3, [sp, #4]
  203e7c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  203e80:	e59d3004 	ldr	r3, [sp, #4]
  203e84:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  203e88:	e0033002 	and	r3, r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
  203e8c:	e3530000 	cmp	r3, #0
  203e90:	1a00000c 	bne	203ec8 <chEvtSignalI+0x88>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
  203e94:	e59d3004 	ldr	r3, [sp, #4]
  203e98:	e5d33020 	ldrb	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  203e9c:	e353000b 	cmp	r3, #11
  203ea0:	1a00000d 	bne	203edc <chEvtSignalI+0x9c>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  203ea4:	e59d3004 	ldr	r3, [sp, #4]
  203ea8:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  203eac:	e59d3004 	ldr	r3, [sp, #4]
  203eb0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  203eb4:	e0022003 	and	r2, r2, r3
  203eb8:	e59d3004 	ldr	r3, [sp, #4]
  203ebc:	e5933028 	ldr	r3, [r3, #40]	; 0x28

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
  203ec0:	e1520003 	cmp	r2, r3
  203ec4:	1a000004 	bne	203edc <chEvtSignalI+0x9c>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
  203ec8:	e59d3004 	ldr	r3, [sp, #4]
  203ecc:	e3a02000 	mov	r2, #0
  203ed0:	e5832028 	str	r2, [r3, #40]	; 0x28
    (void) chSchReadyI(tp);
  203ed4:	e59d0004 	ldr	r0, [sp, #4]
  203ed8:	eb000200 	bl	2046e0 <chSchReadyI>
  }
}
  203edc:	e28dd00c 	add	sp, sp, #12
  203ee0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00203ef0 <port_lock.lto_priv.77>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  203ef0:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  203ef4:	e12fff1e 	bx	lr
	...

00203f00 <port_unlock.lto_priv.71>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  203f00:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  203f04:	e12fff1e 	bx	lr
	...

00203f10 <chSysLock.lto_priv.90>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  203f10:	e92d4010 	push	{r4, lr}

  port_lock();
  203f14:	ebfffff5 	bl	203ef0 <port_lock.lto_priv.77>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  203f18:	e8bd8010 	pop	{r4, pc}
  203f1c:	00000000 	andeq	r0, r0, r0

00203f20 <chSysUnlock.lto_priv.84>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  203f20:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  203f24:	ebfffff5 	bl	203f00 <port_unlock.lto_priv.71>
}
  203f28:	e8bd8010 	pop	{r4, pc}
  203f2c:	00000000 	andeq	r0, r0, r0

00203f30 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
  203f30:	e30039c8 	movw	r3, #2504	; 0x9c8
  203f34:	e3403021 	movt	r3, #33	; 0x21
  203f38:	e3002cec 	movw	r2, #3308	; 0xcec
  203f3c:	e3402021 	movt	r2, #33	; 0x21
  203f40:	e5832000 	str	r2, [r3]
  ch_memcore.endmem  = __heap_end__;
  203f44:	e30039c8 	movw	r3, #2504	; 0x9c8
  203f48:	e3403021 	movt	r3, #33	; 0x21
  203f4c:	e3002000 	movw	r2, #0
  203f50:	e3402022 	movt	r2, #34	; 0x22
  203f54:	e5832004 	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
  203f58:	e12fff1e 	bx	lr
  203f5c:	00000000 	andeq	r0, r0, r0

00203f60 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
  203f60:	e24dd018 	sub	sp, sp, #24
  203f64:	e58d000c 	str	r0, [sp, #12]
  203f68:	e58d1008 	str	r1, [sp, #8]
  203f6c:	e58d2004 	str	r2, [sp, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  203f70:	e59d2008 	ldr	r2, [sp, #8]
  203f74:	e59d300c 	ldr	r3, [sp, #12]
  203f78:	e0823003 	add	r3, r2, r3
  203f7c:	e2432001 	sub	r2, r3, #1
  203f80:	e59d3008 	ldr	r3, [sp, #8]
  203f84:	e2633000 	rsb	r3, r3, #0
  203f88:	e0033002 	and	r3, r3, r2
  203f8c:	e58d300c 	str	r3, [sp, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  203f90:	e30039c8 	movw	r3, #2504	; 0x9c8
  203f94:	e3403021 	movt	r3, #33	; 0x21
  203f98:	e5932000 	ldr	r2, [r3]
  203f9c:	e59d3004 	ldr	r3, [sp, #4]
  203fa0:	e0823003 	add	r3, r2, r3
  203fa4:	e1a02003 	mov	r2, r3
  203fa8:	e59d3008 	ldr	r3, [sp, #8]
  203fac:	e0823003 	add	r3, r2, r3
  203fb0:	e2432001 	sub	r2, r3, #1
  203fb4:	e59d3008 	ldr	r3, [sp, #8]
  203fb8:	e2633000 	rsb	r3, r3, #0
  203fbc:	e0033002 	and	r3, r3, r2
  203fc0:	e58d3014 	str	r3, [sp, #20]
  next = p + size;
  203fc4:	e59d2014 	ldr	r2, [sp, #20]
  203fc8:	e59d300c 	ldr	r3, [sp, #12]
  203fcc:	e0823003 	add	r3, r2, r3
  203fd0:	e58d3010 	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  203fd4:	e30039c8 	movw	r3, #2504	; 0x9c8
  203fd8:	e3403021 	movt	r3, #33	; 0x21
  203fdc:	e5932004 	ldr	r2, [r3, #4]
  203fe0:	e59d3010 	ldr	r3, [sp, #16]
  203fe4:	e1520003 	cmp	r2, r3
  203fe8:	3a000005 	bcc	204004 <chCoreAllocAlignedWithOffsetI+0xa4>
  203fec:	e30039c8 	movw	r3, #2504	; 0x9c8
  203ff0:	e3403021 	movt	r3, #33	; 0x21
  203ff4:	e5932000 	ldr	r2, [r3]
  203ff8:	e59d3010 	ldr	r3, [sp, #16]
  203ffc:	e1520003 	cmp	r2, r3
  204000:	9a000001 	bls	20400c <chCoreAllocAlignedWithOffsetI+0xac>
    return NULL;
  204004:	e3a03000 	mov	r3, #0
  204008:	ea000004 	b	204020 <chCoreAllocAlignedWithOffsetI+0xc0>
  }

  ch_memcore.nextmem = next;
  20400c:	e30039c8 	movw	r3, #2504	; 0x9c8
  204010:	e3403021 	movt	r3, #33	; 0x21
  204014:	e59d2010 	ldr	r2, [sp, #16]
  204018:	e5832000 	str	r2, [r3]

  return p;
  20401c:	e59d3014 	ldr	r3, [sp, #20]
}
  204020:	e1a00003 	mov	r0, r3
  204024:	e28dd018 	add	sp, sp, #24
  204028:	e12fff1e 	bx	lr
  20402c:	00000000 	andeq	r0, r0, r0

00204030 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
  204030:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204034:	e24dd01c 	sub	sp, sp, #28
  204038:	e58d000c 	str	r0, [sp, #12]
  20403c:	e58d1008 	str	r1, [sp, #8]
  204040:	e58d2004 	str	r2, [sp, #4]
  void *p;

  chSysLock();
  204044:	ebffffb1 	bl	203f10 <chSysLock.lto_priv.90>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  204048:	e59d2004 	ldr	r2, [sp, #4]
  20404c:	e59d1008 	ldr	r1, [sp, #8]
  204050:	e59d000c 	ldr	r0, [sp, #12]
  204054:	ebffffc1 	bl	203f60 <chCoreAllocAlignedWithOffsetI>
  204058:	e58d0014 	str	r0, [sp, #20]
  chSysUnlock();
  20405c:	ebffffaf 	bl	203f20 <chSysUnlock.lto_priv.84>

  return p;
  204060:	e59d3014 	ldr	r3, [sp, #20]
}
  204064:	e1a00003 	mov	r0, r3
  204068:	e28dd01c 	add	sp, sp, #28
  20406c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00204070 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
  204070:	e92d4010 	push	{r4, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
  204074:	e30039d0 	movw	r3, #2512	; 0x9d0
  204078:	e3403021 	movt	r3, #33	; 0x21
  20407c:	e3042030 	movw	r2, #16432	; 0x4030
  204080:	e3402020 	movt	r2, #32
  204084:	e5832000 	str	r2, [r3]
  H_NEXT(&default_heap.header) = NULL;
  204088:	e30039d0 	movw	r3, #2512	; 0x9d0
  20408c:	e3403021 	movt	r3, #33	; 0x21
  204090:	e3a02000 	mov	r2, #0
  204094:	e5832008 	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
  204098:	e30039d0 	movw	r3, #2512	; 0x9d0
  20409c:	e3403021 	movt	r3, #33	; 0x21
  2040a0:	e3a02000 	mov	r2, #0
  2040a4:	e583200c 	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
  2040a8:	e30009e0 	movw	r0, #2528	; 0x9e0
  2040ac:	e3400021 	movt	r0, #33	; 0x21
  2040b0:	eb00041a 	bl	205120 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
  2040b4:	e8bd8010 	pop	{r4, pc}
	...

002040c0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
  2040c0:	e12fff1e 	bx	lr
	...

002040d0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
  2040d0:	eafffffe 	b	2040d0 <__default_exit>
	...

002040e0 <port_init>:
/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

}
  2040e0:	e12fff1e 	bx	lr
	...

002040f0 <port_lock_from_isr.lto_priv.148>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  2040f0:	e12fff1e 	bx	lr
	...

00204100 <port_unlock_from_isr.lto_priv.146>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  204100:	e12fff1e 	bx	lr
	...

00204110 <port_disable>:
 * @details In this port it disables FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_disable(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  204110:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  204114:	e12fff1e 	bx	lr
	...

00204120 <port_enable>:
 * @brief   Enables all the interrupt sources.
 * @note    In this port it enables the FIQ sources.
 */
static inline void port_enable(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  204120:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  204124:	e12fff1e 	bx	lr
	...

00204130 <port_wait_for_interrupt>:
 *          modes.
 * @note    Implemented as an inlined @p WFI instruction.
 */
static inline void port_wait_for_interrupt(void) {

  asm volatile ("wfi" : : : "memory");
  204130:	e320f003 	wfi
}
  204134:	e12fff1e 	bx	lr
	...

00204140 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
  204140:	e92d4010 	push	{r4, lr}

  _dbg_check_enable();
  port_enable();
  204144:	ebfffff5 	bl	204120 <port_enable>
}
  204148:	e8bd8010 	pop	{r4, pc}
  20414c:	00000000 	andeq	r0, r0, r0

00204150 <chSysLockFromISR.lto_priv.144>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  204150:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  204154:	ebffffe5 	bl	2040f0 <port_lock_from_isr.lto_priv.148>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  204158:	e8bd8010 	pop	{r4, pc}
  20415c:	00000000 	andeq	r0, r0, r0

00204160 <chSysUnlockFromISR.lto_priv.142>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  204160:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  204164:	ebffffe5 	bl	204100 <port_unlock_from_isr.lto_priv.146>
}
  204168:	e8bd8010 	pop	{r4, pc}
  20416c:	00000000 	andeq	r0, r0, r0

00204170 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
  204170:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204174:	e24dd00c 	sub	sp, sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  204178:	e3003950 	movw	r3, #2384	; 0x950
  20417c:	e3403021 	movt	r3, #33	; 0x21
  204180:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  204184:	e2832001 	add	r2, r3, #1
  204188:	e3003950 	movw	r3, #2384	; 0x950
  20418c:	e3403021 	movt	r3, #33	; 0x21
  204190:	e5832028 	str	r2, [r3, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  204194:	e3003950 	movw	r3, #2384	; 0x950
  204198:	e3403021 	movt	r3, #33	; 0x21
  20419c:	e593301c 	ldr	r3, [r3, #28]
  2041a0:	e300296c 	movw	r2, #2412	; 0x96c
  2041a4:	e3402021 	movt	r2, #33	; 0x21
  2041a8:	e1530002 	cmp	r3, r2
  2041ac:	0a000027 	beq	204250 <chVTDoTickI+0xe0>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
  2041b0:	e3003950 	movw	r3, #2384	; 0x950
  2041b4:	e3403021 	movt	r3, #33	; 0x21
  2041b8:	e593301c 	ldr	r3, [r3, #28]
  2041bc:	e5932008 	ldr	r2, [r3, #8]
  2041c0:	e2422001 	sub	r2, r2, #1
  2041c4:	e5832008 	str	r2, [r3, #8]
  2041c8:	ea00001a 	b	204238 <chVTDoTickI+0xc8>
    while (ch.vtlist.next->delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.next;
  2041cc:	e3003950 	movw	r3, #2384	; 0x950
  2041d0:	e3403021 	movt	r3, #33	; 0x21
  2041d4:	e593301c 	ldr	r3, [r3, #28]
  2041d8:	e58d3004 	str	r3, [sp, #4]
      fn = vtp->func;
  2041dc:	e59d3004 	ldr	r3, [sp, #4]
  2041e0:	e593300c 	ldr	r3, [r3, #12]
  2041e4:	e58d3000 	str	r3, [sp]
      vtp->func = NULL;
  2041e8:	e59d3004 	ldr	r3, [sp, #4]
  2041ec:	e3a02000 	mov	r2, #0
  2041f0:	e583200c 	str	r2, [r3, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  2041f4:	e59d3004 	ldr	r3, [sp, #4]
  2041f8:	e5933000 	ldr	r3, [r3]
  2041fc:	e300296c 	movw	r2, #2412	; 0x96c
  204200:	e3402021 	movt	r2, #33	; 0x21
  204204:	e5832004 	str	r2, [r3, #4]
      ch.vtlist.next = vtp->next;
  204208:	e59d3004 	ldr	r3, [sp, #4]
  20420c:	e5932000 	ldr	r2, [r3]
  204210:	e3003950 	movw	r3, #2384	; 0x950
  204214:	e3403021 	movt	r3, #33	; 0x21
  204218:	e583201c 	str	r2, [r3, #28]
      chSysUnlockFromISR();
  20421c:	ebffffcf 	bl	204160 <chSysUnlockFromISR.lto_priv.142>
      fn(vtp->par);
  204220:	e59d3004 	ldr	r3, [sp, #4]
  204224:	e5932010 	ldr	r2, [r3, #16]
  204228:	e59d3000 	ldr	r3, [sp]
  20422c:	e1a00002 	mov	r0, r2
  204230:	e12fff33 	blx	r3
      chSysLockFromISR();
  204234:	ebffffc5 	bl	204150 <chSysLockFromISR.lto_priv.144>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
    while (ch.vtlist.next->delta == (systime_t)0) {
  204238:	e3003950 	movw	r3, #2384	; 0x950
  20423c:	e3403021 	movt	r3, #33	; 0x21
  204240:	e593301c 	ldr	r3, [r3, #28]
  204244:	e5933008 	ldr	r3, [r3, #8]
  204248:	e3530000 	cmp	r3, #0
  20424c:	0affffde 	beq	2041cc <chVTDoTickI+0x5c>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  204250:	e28dd00c 	add	sp, sp, #12
  204254:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204260 <_idle_thread.lto_priv.9>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
  204260:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204264:	e24dd00c 	sub	sp, sp, #12
  204268:	e58d0004 	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
  20426c:	ebffffaf 	bl	204130 <port_wait_for_interrupt>
  204270:	eafffffd 	b	20426c <_idle_thread.lto_priv.9+0xc>
	...

00204280 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
  204280:	e92d4010 	push	{r4, lr}

  _scheduler_init();
  204284:	eb000101 	bl	204690 <_scheduler_init>
  _vt_init();
  204288:	eb000034 	bl	204360 <_vt_init>
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
  20428c:	ebffff27 	bl	203f30 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
  204290:	ebffff76 	bl	204070 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  204294:	e3a02080 	mov	r2, #128	; 0x80
  204298:	e3051230 	movw	r1, #21040	; 0x5230
  20429c:	e3401020 	movt	r1, #32
  2042a0:	e3000980 	movw	r0, #2432	; 0x980
  2042a4:	e3400021 	movt	r0, #33	; 0x21
  2042a8:	eb0002a8 	bl	204d50 <_thread_init>
  2042ac:	e1a02000 	mov	r2, r0
  2042b0:	e3003950 	movw	r3, #2384	; 0x950
  2042b4:	e3403021 	movt	r3, #33	; 0x21
  2042b8:	e5832018 	str	r2, [r3, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
  2042bc:	e3003950 	movw	r3, #2384	; 0x950
  2042c0:	e3403021 	movt	r3, #33	; 0x21
  2042c4:	e5933018 	ldr	r3, [r3, #24]
  2042c8:	e3a02000 	mov	r2, #0
  2042cc:	e583201c 	str	r2, [r3, #28]
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
  2042d0:	e3003950 	movw	r3, #2384	; 0x950
  2042d4:	e3403021 	movt	r3, #33	; 0x21
  2042d8:	e5933018 	ldr	r3, [r3, #24]
  2042dc:	e3a02001 	mov	r2, #1
  2042e0:	e5c32020 	strb	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
  2042e4:	ebffff7d 	bl	2040e0 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
  2042e8:	ebffff94 	bl	204140 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
  2042ec:	e3050210 	movw	r0, #21008	; 0x5210
  2042f0:	e3400020 	movt	r0, #32
  2042f4:	eb000301 	bl	204f00 <chThdCreate>
  }
#endif
}
  2042f8:	e8bd8010 	pop	{r4, pc}
  2042fc:	00000000 	andeq	r0, r0, r0

00204300 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
  204300:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204304:	e24dd00c 	sub	sp, sp, #12
  204308:	e58d0004 	str	r0, [sp, #4]

  port_disable();
  20430c:	ebffff7f 	bl	204110 <port_disable>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
  204310:	e3003950 	movw	r3, #2384	; 0x950
  204314:	e3403021 	movt	r3, #33	; 0x21
  204318:	e59d2004 	ldr	r2, [sp, #4]
  20431c:	e583202c 	str	r2, [r3, #44]	; 0x2c
  204320:	eafffffe 	b	204320 <chSysHalt+0x20>
	...

00204330 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
  204330:	e92d4010 	push	{r4, lr}
    /* Decrement remaining quantum.*/
    currp->preempt--;
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
  204334:	e3003950 	movw	r3, #2384	; 0x950
  204338:	e3403021 	movt	r3, #33	; 0x21
  20433c:	e5933018 	ldr	r3, [r3, #24]
  204340:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  204344:	e2822001 	add	r2, r2, #1
  204348:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif
  chVTDoTickI();
  20434c:	ebffff87 	bl	204170 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
  204350:	e8bd8010 	pop	{r4, pc}
	...

00204360 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  204360:	e3003950 	movw	r3, #2384	; 0x950
  204364:	e3403021 	movt	r3, #33	; 0x21
  204368:	e300296c 	movw	r2, #2412	; 0x96c
  20436c:	e3402021 	movt	r2, #33	; 0x21
  204370:	e583201c 	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  204374:	e3003950 	movw	r3, #2384	; 0x950
  204378:	e3403021 	movt	r3, #33	; 0x21
  20437c:	e300296c 	movw	r2, #2412	; 0x96c
  204380:	e3402021 	movt	r2, #33	; 0x21
  204384:	e5832020 	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
  204388:	e3003950 	movw	r3, #2384	; 0x950
  20438c:	e3403021 	movt	r3, #33	; 0x21
  204390:	e3e02000 	mvn	r2, #0
  204394:	e5832024 	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
  204398:	e3003950 	movw	r3, #2384	; 0x950
  20439c:	e3403021 	movt	r3, #33	; 0x21
  2043a0:	e3a02000 	mov	r2, #0
  2043a4:	e5832028 	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  2043a8:	e12fff1e 	bx	lr
  2043ac:	00000000 	andeq	r0, r0, r0

002043b0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  2043b0:	e24dd018 	sub	sp, sp, #24
  2043b4:	e58d000c 	str	r0, [sp, #12]
  2043b8:	e58d1008 	str	r1, [sp, #8]
  2043bc:	e58d2004 	str	r2, [sp, #4]
  2043c0:	e58d3000 	str	r3, [sp]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  2043c4:	e59d300c 	ldr	r3, [sp, #12]
  2043c8:	e59d2000 	ldr	r2, [sp]
  2043cc:	e5832010 	str	r2, [r3, #16]
  vtp->func = vtfunc;
  2043d0:	e59d300c 	ldr	r3, [sp, #12]
  2043d4:	e59d2004 	ldr	r2, [sp, #4]
  2043d8:	e583200c 	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
  2043dc:	e59d3008 	ldr	r3, [sp, #8]
  2043e0:	e58d3010 	str	r3, [sp, #16]

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
  2043e4:	e3003950 	movw	r3, #2384	; 0x950
  2043e8:	e3403021 	movt	r3, #33	; 0x21
  2043ec:	e593301c 	ldr	r3, [r3, #28]
  2043f0:	e58d3014 	str	r3, [sp, #20]
  2043f4:	ea000007 	b	204418 <chVTDoSetI+0x68>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
  2043f8:	e59d3014 	ldr	r3, [sp, #20]
  2043fc:	e5933008 	ldr	r3, [r3, #8]
  204400:	e59d2010 	ldr	r2, [sp, #16]
  204404:	e0633002 	rsb	r3, r3, r2
  204408:	e58d3010 	str	r3, [sp, #16]
    p = p->next;
  20440c:	e59d3014 	ldr	r3, [sp, #20]
  204410:	e5933000 	ldr	r3, [r3]
  204414:	e58d3014 	str	r3, [sp, #20]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
  204418:	e59d3014 	ldr	r3, [sp, #20]
  20441c:	e5932008 	ldr	r2, [r3, #8]
  204420:	e59d3010 	ldr	r3, [sp, #16]
  204424:	e1520003 	cmp	r2, r3
  204428:	3afffff2 	bcc	2043f8 <chVTDoSetI+0x48>
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  20442c:	e59d300c 	ldr	r3, [sp, #12]
  204430:	e59d2014 	ldr	r2, [sp, #20]
  204434:	e5832000 	str	r2, [r3]
  vtp->prev = vtp->next->prev;
  204438:	e59d300c 	ldr	r3, [sp, #12]
  20443c:	e5933000 	ldr	r3, [r3]
  204440:	e5932004 	ldr	r2, [r3, #4]
  204444:	e59d300c 	ldr	r3, [sp, #12]
  204448:	e5832004 	str	r2, [r3, #4]
  vtp->prev->next = vtp;
  20444c:	e59d300c 	ldr	r3, [sp, #12]
  204450:	e5933004 	ldr	r3, [r3, #4]
  204454:	e59d200c 	ldr	r2, [sp, #12]
  204458:	e5832000 	str	r2, [r3]
  p->prev = vtp;
  20445c:	e59d3014 	ldr	r3, [sp, #20]
  204460:	e59d200c 	ldr	r2, [sp, #12]
  204464:	e5832004 	str	r2, [r3, #4]
  vtp->delta = delta
  204468:	e59d300c 	ldr	r3, [sp, #12]
  20446c:	e59d2010 	ldr	r2, [sp, #16]
  204470:	e5832008 	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  204474:	e59d3014 	ldr	r3, [sp, #20]
  204478:	e5932008 	ldr	r2, [r3, #8]
  20447c:	e59d3010 	ldr	r3, [sp, #16]
  204480:	e0632002 	rsb	r2, r3, r2
  204484:	e59d3014 	ldr	r3, [sp, #20]
  204488:	e5832008 	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
  20448c:	e3003950 	movw	r3, #2384	; 0x950
  204490:	e3403021 	movt	r3, #33	; 0x21
  204494:	e3e02000 	mvn	r2, #0
  204498:	e5832024 	str	r2, [r3, #36]	; 0x24
}
  20449c:	e28dd018 	add	sp, sp, #24
  2044a0:	e12fff1e 	bx	lr
	...

002044b0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
  2044b0:	e24dd008 	sub	sp, sp, #8
  2044b4:	e58d0004 	str	r0, [sp, #4]
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
  2044b8:	e59d3004 	ldr	r3, [sp, #4]
  2044bc:	e5933000 	ldr	r3, [r3]
  2044c0:	e59d2004 	ldr	r2, [sp, #4]
  2044c4:	e5922000 	ldr	r2, [r2]
  2044c8:	e5921008 	ldr	r1, [r2, #8]
  2044cc:	e59d2004 	ldr	r2, [sp, #4]
  2044d0:	e5922008 	ldr	r2, [r2, #8]
  2044d4:	e0812002 	add	r2, r1, r2
  2044d8:	e5832008 	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
  2044dc:	e59d3004 	ldr	r3, [sp, #4]
  2044e0:	e5933004 	ldr	r3, [r3, #4]
  2044e4:	e59d2004 	ldr	r2, [sp, #4]
  2044e8:	e5922000 	ldr	r2, [r2]
  2044ec:	e5832000 	str	r2, [r3]
  vtp->next->prev = vtp->prev;
  2044f0:	e59d3004 	ldr	r3, [sp, #4]
  2044f4:	e5933000 	ldr	r3, [r3]
  2044f8:	e59d2004 	ldr	r2, [sp, #4]
  2044fc:	e5922004 	ldr	r2, [r2, #4]
  204500:	e5832004 	str	r2, [r3, #4]
  vtp->func = NULL;
  204504:	e59d3004 	ldr	r3, [sp, #4]
  204508:	e3a02000 	mov	r2, #0
  20450c:	e583200c 	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
  204510:	e3003950 	movw	r3, #2384	; 0x950
  204514:	e3403021 	movt	r3, #33	; 0x21
  204518:	e3e02000 	mvn	r2, #0
  20451c:	e5832024 	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  204520:	e28dd008 	add	sp, sp, #8
  204524:	e12fff1e 	bx	lr
	...

00204530 <port_lock_from_isr.lto_priv.149>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
  204530:	e12fff1e 	bx	lr
	...

00204540 <port_unlock_from_isr.lto_priv.147>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    Empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
  204540:	e12fff1e 	bx	lr
	...

00204550 <queue_init.lto_priv.131>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  204550:	e24dd008 	sub	sp, sp, #8
  204554:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  204558:	e59d3004 	ldr	r3, [sp, #4]
  20455c:	e59d2004 	ldr	r2, [sp, #4]
  204560:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  204564:	e59d3004 	ldr	r3, [sp, #4]
  204568:	e59d2004 	ldr	r2, [sp, #4]
  20456c:	e5832004 	str	r2, [r3, #4]
}
  204570:	e28dd008 	add	sp, sp, #8
  204574:	e12fff1e 	bx	lr
	...

00204580 <queue_fifo_remove.lto_priv.121>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  204580:	e24dd010 	sub	sp, sp, #16
  204584:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
  204588:	e59d3004 	ldr	r3, [sp, #4]
  20458c:	e5933000 	ldr	r3, [r3]
  204590:	e58d300c 	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
  204594:	e59d300c 	ldr	r3, [sp, #12]
  204598:	e5932000 	ldr	r2, [r3]
  20459c:	e59d3004 	ldr	r3, [sp, #4]
  2045a0:	e5832000 	str	r2, [r3]
  tqp->next->queue.prev = (thread_t *)tqp;
  2045a4:	e59d3004 	ldr	r3, [sp, #4]
  2045a8:	e5933000 	ldr	r3, [r3]
  2045ac:	e59d2004 	ldr	r2, [sp, #4]
  2045b0:	e5832004 	str	r2, [r3, #4]

  return tp;
  2045b4:	e59d300c 	ldr	r3, [sp, #12]
}
  2045b8:	e1a00003 	mov	r0, r3
  2045bc:	e28dd010 	add	sp, sp, #16
  2045c0:	e12fff1e 	bx	lr
	...

002045d0 <queue_dequeue.lto_priv.136>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
  2045d0:	e24dd008 	sub	sp, sp, #8
  2045d4:	e58d0004 	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
  2045d8:	e59d3004 	ldr	r3, [sp, #4]
  2045dc:	e5933004 	ldr	r3, [r3, #4]
  2045e0:	e59d2004 	ldr	r2, [sp, #4]
  2045e4:	e5922000 	ldr	r2, [r2]
  2045e8:	e5832000 	str	r2, [r3]
  tp->queue.next->queue.prev = tp->queue.prev;
  2045ec:	e59d3004 	ldr	r3, [sp, #4]
  2045f0:	e5933000 	ldr	r3, [r3]
  2045f4:	e59d2004 	ldr	r2, [sp, #4]
  2045f8:	e5922004 	ldr	r2, [r2, #4]
  2045fc:	e5832004 	str	r2, [r3, #4]

  return tp;
  204600:	e59d3004 	ldr	r3, [sp, #4]
}
  204604:	e1a00003 	mov	r0, r3
  204608:	e28dd008 	add	sp, sp, #8
  20460c:	e12fff1e 	bx	lr

00204610 <chSysLockFromISR.lto_priv.145>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
  204610:	e92d4010 	push	{r4, lr}

  port_lock_from_isr();
  204614:	ebffffc5 	bl	204530 <port_lock_from_isr.lto_priv.149>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
  204618:	e8bd8010 	pop	{r4, pc}
  20461c:	00000000 	andeq	r0, r0, r0

00204620 <chSysUnlockFromISR.lto_priv.143>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
  204620:	e92d4010 	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
  204624:	ebffffc5 	bl	204540 <port_unlock_from_isr.lto_priv.147>
}
  204628:	e8bd8010 	pop	{r4, pc}
  20462c:	00000000 	andeq	r0, r0, r0

00204630 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
  204630:	e24dd008 	sub	sp, sp, #8
  204634:	e58d0004 	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->func != NULL);
  204638:	e59d3004 	ldr	r3, [sp, #4]
  20463c:	e593300c 	ldr	r3, [r3, #12]
  204640:	e3530000 	cmp	r3, #0
  204644:	13a03001 	movne	r3, #1
  204648:	03a03000 	moveq	r3, #0
  20464c:	e6ef3073 	uxtb	r3, r3
}
  204650:	e1a00003 	mov	r0, r3
  204654:	e28dd008 	add	sp, sp, #8
  204658:	e12fff1e 	bx	lr
  20465c:	00000000 	andeq	r0, r0, r0

00204660 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
  204660:	e24dd008 	sub	sp, sp, #8
  204664:	e58d0004 	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->cnt++;
  204668:	e59d3004 	ldr	r3, [sp, #4]
  20466c:	e5933008 	ldr	r3, [r3, #8]
  204670:	e2832001 	add	r2, r3, #1
  204674:	e59d3004 	ldr	r3, [sp, #4]
  204678:	e5832008 	str	r2, [r3, #8]
}
  20467c:	e28dd008 	add	sp, sp, #8
  204680:	e12fff1e 	bx	lr
	...

00204690 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
  204690:	e92d4010 	push	{r4, lr}

  queue_init(&ch.rlist.queue);
  204694:	e3000950 	movw	r0, #2384	; 0x950
  204698:	e3400021 	movt	r0, #33	; 0x21
  20469c:	ebffffab 	bl	204550 <queue_init.lto_priv.131>
  ch.rlist.prio = NOPRIO;
  2046a0:	e3003950 	movw	r3, #2384	; 0x950
  2046a4:	e3403021 	movt	r3, #33	; 0x21
  2046a8:	e3a02000 	mov	r2, #0
  2046ac:	e5832008 	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
  2046b0:	e3003950 	movw	r3, #2384	; 0x950
  2046b4:	e3403021 	movt	r3, #33	; 0x21
  2046b8:	e3002950 	movw	r2, #2384	; 0x950
  2046bc:	e3402021 	movt	r2, #33	; 0x21
  2046c0:	e5832010 	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
  2046c4:	e3003950 	movw	r3, #2384	; 0x950
  2046c8:	e3403021 	movt	r3, #33	; 0x21
  2046cc:	e3002950 	movw	r2, #2384	; 0x950
  2046d0:	e3402021 	movt	r2, #33	; 0x21
  2046d4:	e5832014 	str	r2, [r3, #20]
#endif
}
  2046d8:	e8bd8010 	pop	{r4, pc}
  2046dc:	00000000 	andeq	r0, r0, r0

002046e0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
  2046e0:	e24dd010 	sub	sp, sp, #16
  2046e4:	e58d0004 	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  2046e8:	e59d3004 	ldr	r3, [sp, #4]
  2046ec:	e3a02000 	mov	r2, #0
  2046f0:	e5c32020 	strb	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
  2046f4:	e3003950 	movw	r3, #2384	; 0x950
  2046f8:	e3403021 	movt	r3, #33	; 0x21
  2046fc:	e58d300c 	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
  204700:	e59d300c 	ldr	r3, [sp, #12]
  204704:	e5933000 	ldr	r3, [r3]
  204708:	e58d300c 	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
  20470c:	e59d300c 	ldr	r3, [sp, #12]
  204710:	e5932008 	ldr	r2, [r3, #8]
  204714:	e59d3004 	ldr	r3, [sp, #4]
  204718:	e5933008 	ldr	r3, [r3, #8]
  20471c:	e1520003 	cmp	r2, r3
  204720:	2afffff6 	bcs	204700 <chSchReadyI+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  204724:	e59d3004 	ldr	r3, [sp, #4]
  204728:	e59d200c 	ldr	r2, [sp, #12]
  20472c:	e5832000 	str	r2, [r3]
  tp->queue.prev             = cp->queue.prev;
  204730:	e59d300c 	ldr	r3, [sp, #12]
  204734:	e5932004 	ldr	r2, [r3, #4]
  204738:	e59d3004 	ldr	r3, [sp, #4]
  20473c:	e5832004 	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  204740:	e59d3004 	ldr	r3, [sp, #4]
  204744:	e5933004 	ldr	r3, [r3, #4]
  204748:	e59d2004 	ldr	r2, [sp, #4]
  20474c:	e5832000 	str	r2, [r3]
  cp->queue.prev             = tp;
  204750:	e59d300c 	ldr	r3, [sp, #12]
  204754:	e59d2004 	ldr	r2, [sp, #4]
  204758:	e5832004 	str	r2, [r3, #4]

  return tp;
  20475c:	e59d3004 	ldr	r3, [sp, #4]
}
  204760:	e1a00003 	mov	r0, r3
  204764:	e28dd010 	add	sp, sp, #16
  204768:	e12fff1e 	bx	lr
  20476c:	00000000 	andeq	r0, r0, r0

00204770 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  204770:	e24dd010 	sub	sp, sp, #16
  204774:	e58d0004 	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  204778:	e59d3004 	ldr	r3, [sp, #4]
  20477c:	e3a02000 	mov	r2, #0
  204780:	e5c32020 	strb	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
  204784:	e3003950 	movw	r3, #2384	; 0x950
  204788:	e3403021 	movt	r3, #33	; 0x21
  20478c:	e58d300c 	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
  204790:	e59d300c 	ldr	r3, [sp, #12]
  204794:	e5933000 	ldr	r3, [r3]
  204798:	e58d300c 	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
  20479c:	e59d300c 	ldr	r3, [sp, #12]
  2047a0:	e5932008 	ldr	r2, [r3, #8]
  2047a4:	e59d3004 	ldr	r3, [sp, #4]
  2047a8:	e5933008 	ldr	r3, [r3, #8]
  2047ac:	e1520003 	cmp	r2, r3
  2047b0:	8afffff6 	bhi	204790 <chSchReadyAheadI+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  2047b4:	e59d3004 	ldr	r3, [sp, #4]
  2047b8:	e59d200c 	ldr	r2, [sp, #12]
  2047bc:	e5832000 	str	r2, [r3]
  tp->queue.prev             = cp->queue.prev;
  2047c0:	e59d300c 	ldr	r3, [sp, #12]
  2047c4:	e5932004 	ldr	r2, [r3, #4]
  2047c8:	e59d3004 	ldr	r3, [sp, #4]
  2047cc:	e5832004 	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  2047d0:	e59d3004 	ldr	r3, [sp, #4]
  2047d4:	e5933004 	ldr	r3, [r3, #4]
  2047d8:	e59d2004 	ldr	r2, [sp, #4]
  2047dc:	e5832000 	str	r2, [r3]
  cp->queue.prev             = tp;
  2047e0:	e59d300c 	ldr	r3, [sp, #12]
  2047e4:	e59d2004 	ldr	r2, [sp, #4]
  2047e8:	e5832004 	str	r2, [r3, #4]

  return tp;
  2047ec:	e59d3004 	ldr	r3, [sp, #4]
}
  2047f0:	e1a00003 	mov	r0, r3
  2047f4:	e28dd010 	add	sp, sp, #16
  2047f8:	e12fff1e 	bx	lr
  2047fc:	00000000 	andeq	r0, r0, r0

00204800 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  204800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204804:	e24dd014 	sub	sp, sp, #20
  204808:	e1a03000 	mov	r3, r0
  20480c:	e5cd3007 	strb	r3, [sp, #7]
  thread_t *otp = currp;
  204810:	e3003950 	movw	r3, #2384	; 0x950
  204814:	e3403021 	movt	r3, #33	; 0x21
  204818:	e5933018 	ldr	r3, [r3, #24]
  20481c:	e58d300c 	str	r3, [sp, #12]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
  204820:	e59d300c 	ldr	r3, [sp, #12]
  204824:	e5dd2007 	ldrb	r2, [sp, #7]
  204828:	e5c32020 	strb	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  20482c:	e3000950 	movw	r0, #2384	; 0x950
  204830:	e3400021 	movt	r0, #33	; 0x21
  204834:	ebffff51 	bl	204580 <queue_fifo_remove.lto_priv.121>
  204838:	e1a02000 	mov	r2, r0
  20483c:	e3003950 	movw	r3, #2384	; 0x950
  204840:	e3403021 	movt	r3, #33	; 0x21
  204844:	e5832018 	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
  204848:	e3003950 	movw	r3, #2384	; 0x950
  20484c:	e3403021 	movt	r3, #33	; 0x21
  204850:	e5933018 	ldr	r3, [r3, #24]
  204854:	e3a02001 	mov	r2, #1
  204858:	e5c32020 	strb	r2, [r3, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  20485c:	e3003950 	movw	r3, #2384	; 0x950
  204860:	e3403021 	movt	r3, #33	; 0x21
  204864:	e5933018 	ldr	r3, [r3, #24]
  204868:	e59d100c 	ldr	r1, [sp, #12]
  20486c:	e1a00003 	mov	r0, r3
  204870:	ebffee4a 	bl	2001a0 <_port_switch_arm>
}
  204874:	e28dd014 	add	sp, sp, #20
  204878:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20487c:	00000000 	andeq	r0, r0, r0

00204880 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
  204880:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204884:	e24dd014 	sub	sp, sp, #20
  204888:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
  20488c:	e59d3004 	ldr	r3, [sp, #4]
  204890:	e58d300c 	str	r3, [sp, #12]

  chSysLockFromISR();
  204894:	ebffff5d 	bl	204610 <chSysLockFromISR.lto_priv.145>
  switch (tp->state) {
  204898:	e59d300c 	ldr	r3, [sp, #12]
  20489c:	e5d33020 	ldrb	r3, [r3, #32]
  2048a0:	e3530007 	cmp	r3, #7
  2048a4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  2048a8:	ea000014 	b	204900 <wakeup+0x80>
  2048ac:	002048cc 	.word	0x002048cc
  2048b0:	00204900 	.word	0x00204900
  2048b4:	00204900 	.word	0x00204900
  2048b8:	002048d4 	.word	0x002048d4
  2048bc:	002048f8 	.word	0x002048f8
  2048c0:	002048e8 	.word	0x002048e8
  2048c4:	00204900 	.word	0x00204900
  2048c8:	002048f8 	.word	0x002048f8
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
  2048cc:	ebffff53 	bl	204620 <chSysUnlockFromISR.lto_priv.143>
  2048d0:	ea000010 	b	204918 <wakeup+0x98>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
  2048d4:	e59d300c 	ldr	r3, [sp, #12]
  2048d8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  2048dc:	e3a02000 	mov	r2, #0
  2048e0:	e5832000 	str	r2, [r3]
  2048e4:	ea000005 	b	204900 <wakeup+0x80>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
  2048e8:	e59d300c 	ldr	r3, [sp, #12]
  2048ec:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  2048f0:	e1a00003 	mov	r0, r3
  2048f4:	ebffff59 	bl	204660 <chSemFastSignalI>
  case CH_STATE_WTCOND:
    /* Falls into, intentional. */
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
  2048f8:	e59d000c 	ldr	r0, [sp, #12]
  2048fc:	ebffff33 	bl	2045d0 <queue_dequeue.lto_priv.136>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  204900:	e59d300c 	ldr	r3, [sp, #12]
  204904:	e3e02000 	mvn	r2, #0
  204908:	e5832028 	str	r2, [r3, #40]	; 0x28
  (void) chSchReadyI(tp);
  20490c:	e59d000c 	ldr	r0, [sp, #12]
  204910:	ebffff72 	bl	2046e0 <chSchReadyI>
  chSysUnlockFromISR();
  204914:	ebffff41 	bl	204620 <chSysUnlockFromISR.lto_priv.143>
}
  204918:	e28dd014 	add	sp, sp, #20
  20491c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00204920 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
  204920:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204924:	e24dd024 	sub	sp, sp, #36	; 0x24
  204928:	e1a03000 	mov	r3, r0
  20492c:	e58d1000 	str	r1, [sp]
  204930:	e5cd3007 	strb	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
  204934:	e59d3000 	ldr	r3, [sp]
  204938:	e3730001 	cmn	r3, #1
  20493c:	0a000014 	beq	204994 <chSchGoSleepTimeoutS+0x74>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
  204940:	e3003950 	movw	r3, #2384	; 0x950
  204944:	e3403021 	movt	r3, #33	; 0x21
  204948:	e5933018 	ldr	r3, [r3, #24]
  20494c:	e28d000c 	add	r0, sp, #12
  204950:	e3042880 	movw	r2, #18560	; 0x4880
  204954:	e3402020 	movt	r2, #32
  204958:	e59d1000 	ldr	r1, [sp]
  20495c:	ebfffe93 	bl	2043b0 <chVTDoSetI>
    chSchGoSleepS(newstate);
  204960:	e5dd3007 	ldrb	r3, [sp, #7]
  204964:	e1a00003 	mov	r0, r3
  204968:	ebffffa4 	bl	204800 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
  20496c:	e28d300c 	add	r3, sp, #12
  204970:	e1a00003 	mov	r0, r3
  204974:	ebffff2d 	bl	204630 <chVTIsArmedI>
  204978:	e1a03000 	mov	r3, r0
  20497c:	e3530000 	cmp	r3, #0
  204980:	0a000006 	beq	2049a0 <chSchGoSleepTimeoutS+0x80>
      chVTDoResetI(&vt);
  204984:	e28d300c 	add	r3, sp, #12
  204988:	e1a00003 	mov	r0, r3
  20498c:	ebfffec7 	bl	2044b0 <chVTDoResetI>
  204990:	ea000002 	b	2049a0 <chSchGoSleepTimeoutS+0x80>
    }
  }
  else {
    chSchGoSleepS(newstate);
  204994:	e5dd3007 	ldrb	r3, [sp, #7]
  204998:	e1a00003 	mov	r0, r3
  20499c:	ebffff97 	bl	204800 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
  2049a0:	e3003950 	movw	r3, #2384	; 0x950
  2049a4:	e3403021 	movt	r3, #33	; 0x21
  2049a8:	e5933018 	ldr	r3, [r3, #24]
  2049ac:	e5933028 	ldr	r3, [r3, #40]	; 0x28
}
  2049b0:	e1a00003 	mov	r0, r3
  2049b4:	e28dd024 	add	sp, sp, #36	; 0x24
  2049b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2049bc:	00000000 	andeq	r0, r0, r0

002049c0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  2049c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2049c4:	e24dd014 	sub	sp, sp, #20
  2049c8:	e58d0004 	str	r0, [sp, #4]
  2049cc:	e58d1000 	str	r1, [sp]
  thread_t *otp = currp;
  2049d0:	e3003950 	movw	r3, #2384	; 0x950
  2049d4:	e3403021 	movt	r3, #33	; 0x21
  2049d8:	e5933018 	ldr	r3, [r3, #24]
  2049dc:	e58d300c 	str	r3, [sp, #12]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
  2049e0:	e59d3004 	ldr	r3, [sp, #4]
  2049e4:	e59d2000 	ldr	r2, [sp]
  2049e8:	e5832028 	str	r2, [r3, #40]	; 0x28

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
  2049ec:	e59d3004 	ldr	r3, [sp, #4]
  2049f0:	e5932008 	ldr	r2, [r3, #8]
  2049f4:	e59d300c 	ldr	r3, [sp, #12]
  2049f8:	e5933008 	ldr	r3, [r3, #8]
  2049fc:	e1520003 	cmp	r2, r3
  204a00:	8a000002 	bhi	204a10 <chSchWakeupS+0x50>
    (void) chSchReadyI(ntp);
  204a04:	e59d0004 	ldr	r0, [sp, #4]
  204a08:	ebffff34 	bl	2046e0 <chSchReadyI>
  204a0c:	ea00000c 	b	204a44 <chSchWakeupS+0x84>
  }
  else {
    otp = chSchReadyI(otp);
  204a10:	e59d000c 	ldr	r0, [sp, #12]
  204a14:	ebffff31 	bl	2046e0 <chSchReadyI>
  204a18:	e58d000c 	str	r0, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
  204a1c:	e3003950 	movw	r3, #2384	; 0x950
  204a20:	e3403021 	movt	r3, #33	; 0x21
  204a24:	e59d2004 	ldr	r2, [sp, #4]
  204a28:	e5832018 	str	r2, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
  204a2c:	e59d3004 	ldr	r3, [sp, #4]
  204a30:	e3a02001 	mov	r2, #1
  204a34:	e5c32020 	strb	r2, [r3, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  204a38:	e59d100c 	ldr	r1, [sp, #12]
  204a3c:	e59d0004 	ldr	r0, [sp, #4]
  204a40:	ebffedd6 	bl	2001a0 <_port_switch_arm>
  }
}
  204a44:	e28dd014 	add	sp, sp, #20
  204a48:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  204a4c:	00000000 	andeq	r0, r0, r0

00204a50 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  204a50:	e24dd008 	sub	sp, sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
  204a54:	e3003950 	movw	r3, #2384	; 0x950
  204a58:	e3403021 	movt	r3, #33	; 0x21
  204a5c:	e5933000 	ldr	r3, [r3]
  204a60:	e5933008 	ldr	r3, [r3, #8]
  204a64:	e58d3004 	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
  204a68:	e3003950 	movw	r3, #2384	; 0x950
  204a6c:	e3403021 	movt	r3, #33	; 0x21
  204a70:	e5933018 	ldr	r3, [r3, #24]
  204a74:	e5933008 	ldr	r3, [r3, #8]
  204a78:	e58d3000 	str	r3, [sp]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
  204a7c:	e59d2004 	ldr	r2, [sp, #4]
  204a80:	e59d3000 	ldr	r3, [sp]
  204a84:	e1520003 	cmp	r2, r3
  204a88:	83a03001 	movhi	r3, #1
  204a8c:	93a03000 	movls	r3, #0
  204a90:	e6ef3073 	uxtb	r3, r3
#endif
}
  204a94:	e1a00003 	mov	r0, r3
  204a98:	e28dd008 	add	sp, sp, #8
  204a9c:	e12fff1e 	bx	lr

00204aa0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  204aa0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204aa4:	e24dd00c 	sub	sp, sp, #12
  thread_t *otp = currp;
  204aa8:	e3003950 	movw	r3, #2384	; 0x950
  204aac:	e3403021 	movt	r3, #33	; 0x21
  204ab0:	e5933018 	ldr	r3, [r3, #24]
  204ab4:	e58d3004 	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  204ab8:	e3000950 	movw	r0, #2384	; 0x950
  204abc:	e3400021 	movt	r0, #33	; 0x21
  204ac0:	ebfffeae 	bl	204580 <queue_fifo_remove.lto_priv.121>
  204ac4:	e1a02000 	mov	r2, r0
  204ac8:	e3003950 	movw	r3, #2384	; 0x950
  204acc:	e3403021 	movt	r3, #33	; 0x21
  204ad0:	e5832018 	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
  204ad4:	e3003950 	movw	r3, #2384	; 0x950
  204ad8:	e3403021 	movt	r3, #33	; 0x21
  204adc:	e5933018 	ldr	r3, [r3, #24]
  204ae0:	e3a02001 	mov	r2, #1
  204ae4:	e5c32020 	strb	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
  204ae8:	e59d0004 	ldr	r0, [sp, #4]
  204aec:	ebffff1f 	bl	204770 <chSchReadyAheadI>
  204af0:	e58d0004 	str	r0, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  204af4:	e3003950 	movw	r3, #2384	; 0x950
  204af8:	e3403021 	movt	r3, #33	; 0x21
  204afc:	e5933018 	ldr	r3, [r3, #24]
  204b00:	e59d1004 	ldr	r1, [sp, #4]
  204b04:	e1a00003 	mov	r0, r3
  204b08:	ebffeda4 	bl	2001a0 <_port_switch_arm>
}
  204b0c:	e28dd00c 	add	sp, sp, #12
  204b10:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204b20 <port_lock.lto_priv.101>:
 * @details In this port it disables the FIQ sources and keeps IRQ sources
 *          disabled.
 */
static inline void port_lock(void) {

  __asm volatile ("msr     CPSR_c, #0xDF" : : : "memory");
  204b20:	e321f0df 	msr	CPSR_c, #223	; 0xdf
}
  204b24:	e12fff1e 	bx	lr
	...

00204b30 <port_unlock.lto_priv.94>:
 * @brief   Kernel-unlock action.
 * @details In this port it enables the FIQ sources.
 */
static inline void port_unlock(void) {

  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
  204b30:	e321f09f 	msr	CPSR_c, #159	; 0x9f
}
  204b34:	e12fff1e 	bx	lr
	...

00204b40 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
  204b40:	e24dd008 	sub	sp, sp, #8
  204b44:	e58d0004 	str	r0, [sp, #4]

  tlp->next = (thread_t *)tlp;
  204b48:	e59d3004 	ldr	r3, [sp, #4]
  204b4c:	e59d2004 	ldr	r2, [sp, #4]
  204b50:	e5832000 	str	r2, [r3]
}
  204b54:	e28dd008 	add	sp, sp, #8
  204b58:	e12fff1e 	bx	lr
  204b5c:	00000000 	andeq	r0, r0, r0

00204b60 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
  204b60:	e24dd008 	sub	sp, sp, #8
  204b64:	e58d0004 	str	r0, [sp, #4]

  return (bool)(tlp->next != (thread_t *)tlp);
  204b68:	e59d3004 	ldr	r3, [sp, #4]
  204b6c:	e5932000 	ldr	r2, [r3]
  204b70:	e59d3004 	ldr	r3, [sp, #4]
  204b74:	e1520003 	cmp	r2, r3
  204b78:	13a03001 	movne	r3, #1
  204b7c:	03a03000 	moveq	r3, #0
  204b80:	e6ef3073 	uxtb	r3, r3
}
  204b84:	e1a00003 	mov	r0, r3
  204b88:	e28dd008 	add	sp, sp, #8
  204b8c:	e12fff1e 	bx	lr

00204b90 <queue_init.lto_priv.132>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  204b90:	e24dd008 	sub	sp, sp, #8
  204b94:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  204b98:	e59d3004 	ldr	r3, [sp, #4]
  204b9c:	e59d2004 	ldr	r2, [sp, #4]
  204ba0:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  204ba4:	e59d3004 	ldr	r3, [sp, #4]
  204ba8:	e59d2004 	ldr	r2, [sp, #4]
  204bac:	e5832004 	str	r2, [r3, #4]
}
  204bb0:	e28dd008 	add	sp, sp, #8
  204bb4:	e12fff1e 	bx	lr
	...

00204bc0 <queue_notempty.lto_priv.128>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
  204bc0:	e24dd008 	sub	sp, sp, #8
  204bc4:	e58d0004 	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
  204bc8:	e59d3004 	ldr	r3, [sp, #4]
  204bcc:	e5932000 	ldr	r2, [r3]
  204bd0:	e59d3004 	ldr	r3, [sp, #4]
  204bd4:	e1520003 	cmp	r2, r3
  204bd8:	13a03001 	movne	r3, #1
  204bdc:	03a03000 	moveq	r3, #0
  204be0:	e6ef3073 	uxtb	r3, r3
}
  204be4:	e1a00003 	mov	r0, r3
  204be8:	e28dd008 	add	sp, sp, #8
  204bec:	e12fff1e 	bx	lr

00204bf0 <list_remove>:

  tp->queue.next = tlp->next;
  tlp->next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
  204bf0:	e24dd010 	sub	sp, sp, #16
  204bf4:	e58d0004 	str	r0, [sp, #4]

  thread_t *tp = tlp->next;
  204bf8:	e59d3004 	ldr	r3, [sp, #4]
  204bfc:	e5933000 	ldr	r3, [r3]
  204c00:	e58d300c 	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
  204c04:	e59d300c 	ldr	r3, [sp, #12]
  204c08:	e5932000 	ldr	r2, [r3]
  204c0c:	e59d3004 	ldr	r3, [sp, #4]
  204c10:	e5832000 	str	r2, [r3]

  return tp;
  204c14:	e59d300c 	ldr	r3, [sp, #12]
}
  204c18:	e1a00003 	mov	r0, r3
  204c1c:	e28dd010 	add	sp, sp, #16
  204c20:	e12fff1e 	bx	lr
	...

00204c30 <queue_insert.lto_priv.138>:
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
  204c30:	e24dd008 	sub	sp, sp, #8
  204c34:	e58d0004 	str	r0, [sp, #4]
  204c38:	e58d1000 	str	r1, [sp]

  tp->queue.next             = (thread_t *)tqp;
  204c3c:	e59d3004 	ldr	r3, [sp, #4]
  204c40:	e59d2000 	ldr	r2, [sp]
  204c44:	e5832000 	str	r2, [r3]
  tp->queue.prev             = tqp->prev;
  204c48:	e59d3000 	ldr	r3, [sp]
  204c4c:	e5932004 	ldr	r2, [r3, #4]
  204c50:	e59d3004 	ldr	r3, [sp, #4]
  204c54:	e5832004 	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  204c58:	e59d3004 	ldr	r3, [sp, #4]
  204c5c:	e5933004 	ldr	r3, [r3, #4]
  204c60:	e59d2004 	ldr	r2, [sp, #4]
  204c64:	e5832000 	str	r2, [r3]
  tqp->prev                  = tp;
  204c68:	e59d3000 	ldr	r3, [sp]
  204c6c:	e59d2004 	ldr	r2, [sp, #4]
  204c70:	e5832004 	str	r2, [r3, #4]
}
  204c74:	e28dd008 	add	sp, sp, #8
  204c78:	e12fff1e 	bx	lr
  204c7c:	00000000 	andeq	r0, r0, r0

00204c80 <queue_fifo_remove.lto_priv.122>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  204c80:	e24dd010 	sub	sp, sp, #16
  204c84:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
  204c88:	e59d3004 	ldr	r3, [sp, #4]
  204c8c:	e5933000 	ldr	r3, [r3]
  204c90:	e58d300c 	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
  204c94:	e59d300c 	ldr	r3, [sp, #12]
  204c98:	e5932000 	ldr	r2, [r3]
  204c9c:	e59d3004 	ldr	r3, [sp, #4]
  204ca0:	e5832000 	str	r2, [r3]
  tqp->next->queue.prev = (thread_t *)tqp;
  204ca4:	e59d3004 	ldr	r3, [sp, #4]
  204ca8:	e5933000 	ldr	r3, [r3]
  204cac:	e59d2004 	ldr	r2, [sp, #4]
  204cb0:	e5832004 	str	r2, [r3, #4]

  return tp;
  204cb4:	e59d300c 	ldr	r3, [sp, #12]
}
  204cb8:	e1a00003 	mov	r0, r3
  204cbc:	e28dd010 	add	sp, sp, #16
  204cc0:	e12fff1e 	bx	lr
	...

00204cd0 <chSysLock.lto_priv.116>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
  204cd0:	e92d4010 	push	{r4, lr}

  port_lock();
  204cd4:	ebffff91 	bl	204b20 <port_lock.lto_priv.101>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
  204cd8:	e8bd8010 	pop	{r4, pc}
  204cdc:	00000000 	andeq	r0, r0, r0

00204ce0 <chSysUnlock.lto_priv.110>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
  204ce0:	e92d4010 	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
  204ce4:	ebffff91 	bl	204b30 <port_unlock.lto_priv.94>
}
  204ce8:	e8bd8010 	pop	{r4, pc}
  204cec:	00000000 	andeq	r0, r0, r0

00204cf0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
  204cf0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204cf4:	e24dd00c 	sub	sp, sp, #12
  204cf8:	e58d0004 	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
  204cfc:	e59d1004 	ldr	r1, [sp, #4]
  204d00:	e3a00008 	mov	r0, #8
  204d04:	ebffff05 	bl	204920 <chSchGoSleepTimeoutS>
}
  204d08:	e28dd00c 	add	sp, sp, #12
  204d0c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00204d10 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  204d10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204d14:	e24dd014 	sub	sp, sp, #20
  204d18:	e58d0004 	str	r0, [sp, #4]
  204d1c:	e58d1000 	str	r1, [sp]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
  204d20:	e59d0004 	ldr	r0, [sp, #4]
  204d24:	ebffffd5 	bl	204c80 <queue_fifo_remove.lto_priv.122>
  204d28:	e58d000c 	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  204d2c:	e59d300c 	ldr	r3, [sp, #12]
  204d30:	e59d2000 	ldr	r2, [sp]
  204d34:	e5832028 	str	r2, [r3, #40]	; 0x28
  (void) chSchReadyI(tp);
  204d38:	e59d000c 	ldr	r0, [sp, #12]
  204d3c:	ebfffe67 	bl	2046e0 <chSchReadyI>
}
  204d40:	e28dd014 	add	sp, sp, #20
  204d44:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204d50 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
  204d50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204d54:	e24dd014 	sub	sp, sp, #20
  204d58:	e58d000c 	str	r0, [sp, #12]
  204d5c:	e58d1008 	str	r1, [sp, #8]
  204d60:	e58d2004 	str	r2, [sp, #4]

  tp->prio      = prio;
  204d64:	e59d300c 	ldr	r3, [sp, #12]
  204d68:	e59d2004 	ldr	r2, [sp, #4]
  204d6c:	e5832008 	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
  204d70:	e59d300c 	ldr	r3, [sp, #12]
  204d74:	e3a02002 	mov	r2, #2
  204d78:	e5c32020 	strb	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
  204d7c:	e59d300c 	ldr	r3, [sp, #12]
  204d80:	e3a02000 	mov	r2, #0
  204d84:	e5c32021 	strb	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  204d88:	e59d300c 	ldr	r3, [sp, #12]
  204d8c:	e59d2004 	ldr	r2, [sp, #4]
  204d90:	e5832040 	str	r2, [r3, #64]	; 0x40
  tp->mtxlist   = NULL;
  204d94:	e59d300c 	ldr	r3, [sp, #12]
  204d98:	e3a02000 	mov	r2, #0
  204d9c:	e583203c 	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
  204da0:	e59d300c 	ldr	r3, [sp, #12]
  204da4:	e3a02000 	mov	r2, #0
  204da8:	e5832038 	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
  204dac:	e59d300c 	ldr	r3, [sp, #12]
  204db0:	e3a02000 	mov	r2, #0
  204db4:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  204db8:	e59d300c 	ldr	r3, [sp, #12]
  204dbc:	e3a02001 	mov	r2, #1
  204dc0:	e5c32022 	strb	r2, [r3, #34]	; 0x22
  tp->name      = name;
  204dc4:	e59d300c 	ldr	r3, [sp, #12]
  204dc8:	e59d2008 	ldr	r2, [sp, #8]
  204dcc:	e5832018 	str	r2, [r3, #24]
  REG_INSERT(tp);
  204dd0:	e59d200c 	ldr	r2, [sp, #12]
  204dd4:	e3003950 	movw	r3, #2384	; 0x950
  204dd8:	e3403021 	movt	r3, #33	; 0x21
  204ddc:	e5823010 	str	r3, [r2, #16]
  204de0:	e3003950 	movw	r3, #2384	; 0x950
  204de4:	e3403021 	movt	r3, #33	; 0x21
  204de8:	e5932014 	ldr	r2, [r3, #20]
  204dec:	e59d300c 	ldr	r3, [sp, #12]
  204df0:	e5832014 	str	r2, [r3, #20]
  204df4:	e59d300c 	ldr	r3, [sp, #12]
  204df8:	e5933014 	ldr	r3, [r3, #20]
  204dfc:	e59d200c 	ldr	r2, [sp, #12]
  204e00:	e5832010 	str	r2, [r3, #16]
  204e04:	e3003950 	movw	r3, #2384	; 0x950
  204e08:	e3403021 	movt	r3, #33	; 0x21
  204e0c:	e59d200c 	ldr	r2, [sp, #12]
  204e10:	e5832014 	str	r2, [r3, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
  204e14:	e59d300c 	ldr	r3, [sp, #12]
  204e18:	e283302c 	add	r3, r3, #44	; 0x2c
  204e1c:	e1a00003 	mov	r0, r3
  204e20:	ebffff46 	bl	204b40 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
  204e24:	e59d300c 	ldr	r3, [sp, #12]
  204e28:	e2833030 	add	r3, r3, #48	; 0x30
  204e2c:	e1a00003 	mov	r0, r3
  204e30:	ebffff56 	bl	204b90 <queue_init.lto_priv.132>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
  204e34:	e59d300c 	ldr	r3, [sp, #12]
}
  204e38:	e1a00003 	mov	r0, r3
  204e3c:	e28dd014 	add	sp, sp, #20
  204e40:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204e50 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  204e50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204e54:	e24dd014 	sub	sp, sp, #20
  204e58:	e58d0004 	str	r0, [sp, #4]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
  204e5c:	e59d3004 	ldr	r3, [sp, #4]
  204e60:	e5933008 	ldr	r3, [r3, #8]
  204e64:	e2433048 	sub	r3, r3, #72	; 0x48
  204e68:	e58d300c 	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
  204e6c:	e59d3004 	ldr	r3, [sp, #4]
  204e70:	e5932004 	ldr	r2, [r3, #4]
  204e74:	e59d300c 	ldr	r3, [sp, #12]
  204e78:	e583201c 	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204e7c:	e59d300c 	ldr	r3, [sp, #12]
  204e80:	e2432024 	sub	r2, r3, #36	; 0x24
  204e84:	e59d300c 	ldr	r3, [sp, #12]
  204e88:	e583200c 	str	r2, [r3, #12]
  204e8c:	e59d300c 	ldr	r3, [sp, #12]
  204e90:	e593300c 	ldr	r3, [r3, #12]
  204e94:	e59d2004 	ldr	r2, [sp, #4]
  204e98:	e5922010 	ldr	r2, [r2, #16]
  204e9c:	e5832000 	str	r2, [r3]
  204ea0:	e59d300c 	ldr	r3, [sp, #12]
  204ea4:	e593300c 	ldr	r3, [r3, #12]
  204ea8:	e59d2004 	ldr	r2, [sp, #4]
  204eac:	e5922014 	ldr	r2, [r2, #20]
  204eb0:	e5832004 	str	r2, [r3, #4]
  204eb4:	e59d300c 	ldr	r3, [sp, #12]
  204eb8:	e593200c 	ldr	r2, [r3, #12]
  204ebc:	e3003300 	movw	r3, #768	; 0x300
  204ec0:	e3403020 	movt	r3, #32
  204ec4:	e5823020 	str	r3, [r2, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
  204ec8:	e59d3004 	ldr	r3, [sp, #4]
  204ecc:	e5931000 	ldr	r1, [r3]
  204ed0:	e59d3004 	ldr	r3, [sp, #4]
  204ed4:	e593300c 	ldr	r3, [r3, #12]
  204ed8:	e1a02003 	mov	r2, r3
  204edc:	e59d000c 	ldr	r0, [sp, #12]
  204ee0:	ebffff9a 	bl	204d50 <_thread_init>
  204ee4:	e1a03000 	mov	r3, r0
}
  204ee8:	e1a00003 	mov	r0, r3
  204eec:	e28dd014 	add	sp, sp, #20
  204ef0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00204f00 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  204f00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204f04:	e24dd014 	sub	sp, sp, #20
  204f08:	e58d0004 	str	r0, [sp, #4]
  _thread_memfill((uint8_t *)tdp->wbase,
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  204f0c:	ebffff6f 	bl	204cd0 <chSysLock.lto_priv.116>
  tp = chThdCreateSuspendedI(tdp);
  204f10:	e59d0004 	ldr	r0, [sp, #4]
  204f14:	ebffffcd 	bl	204e50 <chThdCreateSuspendedI>
  204f18:	e58d000c 	str	r0, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
  204f1c:	e3a01000 	mov	r1, #0
  204f20:	e59d000c 	ldr	r0, [sp, #12]
  204f24:	ebfffea5 	bl	2049c0 <chSchWakeupS>
  chSysUnlock();
  204f28:	ebffff6c 	bl	204ce0 <chSysUnlock.lto_priv.110>

  return tp;
  204f2c:	e59d300c 	ldr	r3, [sp, #12]
}
  204f30:	e1a00003 	mov	r0, r3
  204f34:	e28dd014 	add	sp, sp, #20
  204f38:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  204f3c:	00000000 	andeq	r0, r0, r0

00204f40 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
  204f40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204f44:	e24dd00c 	sub	sp, sp, #12
  204f48:	e58d0004 	str	r0, [sp, #4]

  chSysLock();
  204f4c:	ebffff5f 	bl	204cd0 <chSysLock.lto_priv.116>
  chThdExitS(msg);
  204f50:	e59d0004 	ldr	r0, [sp, #4]
  204f54:	eb000001 	bl	204f60 <chThdExitS>
  /* The thread never returns here.*/
}
  204f58:	e28dd00c 	add	sp, sp, #12
  204f5c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00204f60 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  204f60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  204f64:	e24dd014 	sub	sp, sp, #20
  204f68:	e58d0004 	str	r0, [sp, #4]
  thread_t *tp = currp;
  204f6c:	e3003950 	movw	r3, #2384	; 0x950
  204f70:	e3403021 	movt	r3, #33	; 0x21
  204f74:	e5933018 	ldr	r3, [r3, #24]
  204f78:	e58d300c 	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
  204f7c:	e59d300c 	ldr	r3, [sp, #12]
  204f80:	e59d2004 	ldr	r2, [sp, #4]
  204f84:	e5832028 	str	r2, [r3, #40]	; 0x28
  204f88:	ea000006 	b	204fa8 <chThdExitS+0x48>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
  204f8c:	e59d300c 	ldr	r3, [sp, #12]
  204f90:	e283302c 	add	r3, r3, #44	; 0x2c
  204f94:	e1a00003 	mov	r0, r3
  204f98:	ebffff14 	bl	204bf0 <list_remove>
  204f9c:	e1a03000 	mov	r3, r0
  204fa0:	e1a00003 	mov	r0, r3
  204fa4:	ebfffdcd 	bl	2046e0 <chSchReadyI>
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
  204fa8:	e59d300c 	ldr	r3, [sp, #12]
  204fac:	e283302c 	add	r3, r3, #44	; 0x2c
  204fb0:	e1a00003 	mov	r0, r3
  204fb4:	ebfffee9 	bl	204b60 <list_notempty>
  204fb8:	e1a03000 	mov	r3, r0
  204fbc:	e3530000 	cmp	r3, #0
  204fc0:	1afffff1 	bne	204f8c <chThdExitS+0x2c>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
  204fc4:	e59d300c 	ldr	r3, [sp, #12]
  204fc8:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
  204fcc:	e3530000 	cmp	r3, #0
  204fd0:	1a00000e 	bne	205010 <chThdExitS+0xb0>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
  204fd4:	e59d300c 	ldr	r3, [sp, #12]
  204fd8:	e5d33021 	ldrb	r3, [r3, #33]	; 0x21
  204fdc:	e2033003 	and	r3, r3, #3

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
  204fe0:	e3530000 	cmp	r3, #0
  204fe4:	1a000009 	bne	205010 <chThdExitS+0xb0>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
  204fe8:	e59d300c 	ldr	r3, [sp, #12]
  204fec:	e5933014 	ldr	r3, [r3, #20]
  204ff0:	e59d200c 	ldr	r2, [sp, #12]
  204ff4:	e5922010 	ldr	r2, [r2, #16]
  204ff8:	e5832010 	str	r2, [r3, #16]
  204ffc:	e59d300c 	ldr	r3, [sp, #12]
  205000:	e5933010 	ldr	r3, [r3, #16]
  205004:	e59d200c 	ldr	r2, [sp, #12]
  205008:	e5922014 	ldr	r2, [r2, #20]
  20500c:	e5832014 	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
  205010:	e3a0000f 	mov	r0, #15
  205014:	ebfffdf9 	bl	204800 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
  205018:	e28dd014 	add	sp, sp, #20
  20501c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00205020 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
  205020:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205024:	e24dd00c 	sub	sp, sp, #12
  205028:	e58d0004 	str	r0, [sp, #4]

  chSysLock();
  20502c:	ebffff27 	bl	204cd0 <chSysLock.lto_priv.116>
  chThdSleepS(time);
  205030:	e59d0004 	ldr	r0, [sp, #4]
  205034:	ebffff2d 	bl	204cf0 <chThdSleepS>
  chSysUnlock();
  205038:	ebffff28 	bl	204ce0 <chSysUnlock.lto_priv.110>
}
  20503c:	e28dd00c 	add	sp, sp, #12
  205040:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

00205050 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
  205050:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205054:	e24dd00c 	sub	sp, sp, #12
  205058:	e58d0004 	str	r0, [sp, #4]
  20505c:	e58d1000 	str	r1, [sp]

  if (TIME_IMMEDIATE == timeout) {
  205060:	e59d3000 	ldr	r3, [sp]
  205064:	e3530000 	cmp	r3, #0
  205068:	1a000001 	bne	205074 <chThdEnqueueTimeoutS+0x24>
    return MSG_TIMEOUT;
  20506c:	e3e03000 	mvn	r3, #0
  205070:	ea000009 	b	20509c <chThdEnqueueTimeoutS+0x4c>
  }

  queue_insert(currp, tqp);
  205074:	e3003950 	movw	r3, #2384	; 0x950
  205078:	e3403021 	movt	r3, #33	; 0x21
  20507c:	e5933018 	ldr	r3, [r3, #24]
  205080:	e59d1004 	ldr	r1, [sp, #4]
  205084:	e1a00003 	mov	r0, r3
  205088:	ebfffee8 	bl	204c30 <queue_insert.lto_priv.138>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  20508c:	e59d1000 	ldr	r1, [sp]
  205090:	e3a00004 	mov	r0, #4
  205094:	ebfffe21 	bl	204920 <chSchGoSleepTimeoutS>
  205098:	e1a03000 	mov	r3, r0
}
  20509c:	e1a00003 	mov	r0, r3
  2050a0:	e28dd00c 	add	sp, sp, #12
  2050a4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002050b0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  2050b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  2050b4:	e24dd00c 	sub	sp, sp, #12
  2050b8:	e58d0004 	str	r0, [sp, #4]
  2050bc:	e58d1000 	str	r1, [sp]

  if (queue_notempty(tqp)) {
  2050c0:	e59d0004 	ldr	r0, [sp, #4]
  2050c4:	ebfffebd 	bl	204bc0 <queue_notempty.lto_priv.128>
  2050c8:	e1a03000 	mov	r3, r0
  2050cc:	e3530000 	cmp	r3, #0
  2050d0:	0a000002 	beq	2050e0 <chThdDequeueNextI+0x30>
    chThdDoDequeueNextI(tqp, msg);
  2050d4:	e59d1000 	ldr	r1, [sp]
  2050d8:	e59d0004 	ldr	r0, [sp, #4]
  2050dc:	ebffff0b 	bl	204d10 <chThdDoDequeueNextI>
  }
}
  2050e0:	e28dd00c 	add	sp, sp, #12
  2050e4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	...

002050f0 <queue_init.lto_priv.134>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
  2050f0:	e24dd008 	sub	sp, sp, #8
  2050f4:	e58d0004 	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
  2050f8:	e59d3004 	ldr	r3, [sp, #4]
  2050fc:	e59d2004 	ldr	r2, [sp, #4]
  205100:	e5832000 	str	r2, [r3]
  tqp->prev = (thread_t *)tqp;
  205104:	e59d3004 	ldr	r3, [sp, #4]
  205108:	e59d2004 	ldr	r2, [sp, #4]
  20510c:	e5832004 	str	r2, [r3, #4]
}
  205110:	e28dd008 	add	sp, sp, #8
  205114:	e12fff1e 	bx	lr
	...

00205120 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
  205120:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205124:	e24dd00c 	sub	sp, sp, #12
  205128:	e58d0004 	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  20512c:	e59d3004 	ldr	r3, [sp, #4]
  205130:	e1a00003 	mov	r0, r3
  205134:	ebffffed 	bl	2050f0 <queue_init.lto_priv.134>
  mp->owner = NULL;
  205138:	e59d3004 	ldr	r3, [sp, #4]
  20513c:	e3a02000 	mov	r2, #0
  205140:	e5832008 	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
  205144:	e28dd00c 	add	sp, sp, #12
  205148:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  20514c:	00000000 	andeq	r0, r0, r0

00205150 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  205150:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  205154:	e24dd014 	sub	sp, sp, #20
  205158:	e58d0004 	str	r0, [sp, #4]
  20515c:	e58d1000 	str	r1, [sp]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  205160:	e59d3004 	ldr	r3, [sp, #4]
  205164:	e5933000 	ldr	r3, [r3]
  205168:	e58d300c 	str	r3, [sp, #12]
  20516c:	ea000019 	b	2051d8 <chEvtBroadcastFlagsI+0x88>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
  205170:	e59d300c 	ldr	r3, [sp, #12]
  205174:	e593200c 	ldr	r2, [r3, #12]
  205178:	e59d3000 	ldr	r3, [sp]
  20517c:	e1822003 	orr	r2, r2, r3
  205180:	e59d300c 	ldr	r3, [sp, #12]
  205184:	e583200c 	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
  205188:	e59d3000 	ldr	r3, [sp]
  20518c:	e3530000 	cmp	r3, #0
  205190:	0a000006 	beq	2051b0 <chEvtBroadcastFlagsI+0x60>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
  205194:	e59d300c 	ldr	r3, [sp, #12]
  205198:	e593200c 	ldr	r2, [r3, #12]
  20519c:	e59d300c 	ldr	r3, [sp, #12]
  2051a0:	e5933010 	ldr	r3, [r3, #16]
  2051a4:	e0033002 	and	r3, r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
  2051a8:	e3530000 	cmp	r3, #0
  2051ac:	0a000006 	beq	2051cc <chEvtBroadcastFlagsI+0x7c>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
  2051b0:	e59d300c 	ldr	r3, [sp, #12]
  2051b4:	e5932004 	ldr	r2, [r3, #4]
  2051b8:	e59d300c 	ldr	r3, [sp, #12]
  2051bc:	e5933008 	ldr	r3, [r3, #8]
  2051c0:	e1a01003 	mov	r1, r3
  2051c4:	e1a00002 	mov	r0, r2
  2051c8:	ebfffb1c 	bl	203e40 <chEvtSignalI>
    }
    elp = elp->next;
  2051cc:	e59d300c 	ldr	r3, [sp, #12]
  2051d0:	e5933000 	ldr	r3, [r3]
  2051d4:	e58d300c 	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  2051d8:	e59d200c 	ldr	r2, [sp, #12]
  2051dc:	e59d3004 	ldr	r3, [sp, #4]
  2051e0:	e1520003 	cmp	r2, r3
  2051e4:	1affffe1 	bne	205170 <chEvtBroadcastFlagsI+0x20>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
  2051e8:	e28dd014 	add	sp, sp, #20
  2051ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  2051f0:	656c6469 	.word	0x656c6469
  2051f4:	00000000 	.word	0x00000000
  2051f8:	20414d44 	.word	0x20414d44
  2051fc:	6c696166 	.word	0x6c696166
  205200:	00657275 	.word	0x00657275
	...

00205210 <idle_descriptor.7911.lto_priv.150>:
  205210:	002051f0 00210880 00210950 00000001     .Q ...!.P.!.....
  205220:	00204260 00000000 00000000 00000000     `B .............

00205230 <ch_debug>:
  205230:	6e69616d 28001600 08480404 1814100c     main...(..H.....
  205240:	2221201c 00002400 00000000 00000000     . !".$..........

00205250 <vmt.lto_priv.37>:
  205250:	002026d0 00202710 00202750 00202790     .& ..' .P' ..' .
  205260:	002027c0 00202800 00202840 00202880     .' ..( .@( ..( .
  205270:	002028c0 00000000 00000000 00000000     .( .............

00205280 <default_config>:
  205280:	00009600 00000000 00000800 00000000     ................

00205290 <sama_inits>:
  205290:	00000001 00000061 00030100 00000001     ....a...........
  2052a0:	00000001 00000200 00008200 00000001     ................
  2052b0:	ffffffff 00000000 00000000 00000000     ................

002052c0 <message>:
  2052c0:	44434241 00000045                                ABCDE.
