ARM GAS  /tmp/cc4MCD3v.s 			page 1


   1              	# 1 "../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S"
   1              	/*
   1              	...
   0              	
   0              	
   2              	    ChibiOS - Copyright (C) 2006..2016 Giovanni Di Sirio.
   3              	
   4              	    This file is part of ChibiOS.
   5              	
   6              	    ChibiOS is free software; you can redistribute it and/or modify
   7              	    it under the terms of the GNU General Public License as published by
   8              	    the Free Software Foundation; either version 3 of the License, or
   9              	    (at your option) any later version.
  10              	
  11              	    ChibiOS is distributed in the hope that it will be useful,
  12              	    but WITHOUT ANY WARRANTY; without even the implied warranty of
  13              	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14              	    GNU General Public License for more details.
  15              	
  16              	    You should have received a copy of the GNU General Public License
  17              	    along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18              	*/
  19              	
  20              	/**
  21              	 * @file    ARMCMAx-TZ/compilers/GCC/chcoreasm.S
  22              	 * @brief   ARMCMAx-TZ architecture port low level code.
  23              	 *
  24              	 * @addtogroup ARMCMAx-TZ_CORE
  25              	 * @{
  26              	 */
  27              	
  28              	#define _FROM_ASM_
  29              	#include "chlicense.h"
   1              	/*
   2              	    ChibiOS - Copyright (C) 2006..2016 Giovanni Di Sirio.
   3              	
   4              	    This file is part of ChibiOS.
   5              	
   6              	    ChibiOS is free software; you can redistribute it and/or modify
   7              	    it under the terms of the GNU General Public License as published by
   8              	    the Free Software Foundation; either version 3 of the License, or
   9              	    (at your option) any later version.
  10              	
  11              	    ChibiOS is distributed in the hope that it will be useful,
  12              	    but WITHOUT ANY WARRANTY; without even the implied warranty of
  13              	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14              	    GNU General Public License for more details.
  15              	
  16              	    You should have received a copy of the GNU General Public License
  17              	    along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18              	*/
  19              	
  20              	/**
  21              	 * @file    chlicense.h
  22              	 * @brief   License Module macros and structures.
  23              	 *
  24              	 * @addtogroup license
ARM GAS  /tmp/cc4MCD3v.s 			page 2


  25              	 * @{
  26              	 */
  27              	
  28              	#ifndef CHLICENSE_H
  29              	#define CHLICENSE_H
  30              	
  31              	/*===========================================================================*/
  32              	/* Module constants.                                                         */
  33              	/*===========================================================================*/
  34              	
  35              	/**
  36              	 * @name   Allowed Features Levels
  37              	 * @{
  38              	 */
  39              	#define CH_FEATURES_BASIC                   0
  40              	#define CH_FEATURES_INTERMEDIATE            1
  41              	#define CH_FEATURES_FULL                    2
  42              	/** @} */
  43              	
  44              	/**
  45              	 * @name    Deployment Options
  46              	 */
  47              	#define CH_DEPLOY_UNLIMITED                -1
  48              	#define CH_DEPLOY_NONE                      0
  49              	/** @} */
  50              	
  51              	/**
  52              	 * @name    Licensing Options
  53              	 * @{
  54              	 */
  55              	#define CH_LICENSE_GPL                      0
  56              	#define CH_LICENSE_GPL_EXCEPTION            1
  57              	#define CH_LICENSE_COMMERCIAL_FREE          2
  58              	#define CH_LICENSE_COMMERCIAL_DEV_1000      3
  59              	#define CH_LICENSE_COMMERCIAL_DEV_5000      4
  60              	#define CH_LICENSE_COMMERCIAL_FULL          5
  61              	#define CH_LICENSE_COMMERCIAL_RUNTIME       6
  62              	#define CH_LICENSE_PARTNER                  7
  63              	/** @} */
  64              	
  65              	#include "chcustomer.h"
   1              	/*
  66              	#if CH_LICENSE == CH_LICENSE_PARTNER
  30              	#include "chconf.h"
   1              	/*
  31              	#include "armparams.h"
   1              	/*
  32              	
  33              	#define FALSE 0
  34              	#define TRUE 1
  35              	
  36              	#if !defined(__DOXYGEN__)
  37              	
  38              	/*
  39              	 * RTOS-specific context offset.
  40              	 */
  41              	#if defined(_CHIBIOS_RT_CONF_)
ARM GAS  /tmp/cc4MCD3v.s 			page 3


  42              	#define CONTEXT_OFFSET  12
  43              	#elif defined(_CHIBIOS_NIL_CONF_)
  44              	#define CONTEXT_OFFSET  0
  45              	#else
  46              	#error "invalid chconf.h"
  47              	#endif
  48              	
  49              	                .set    MODE_USR, 0x10
  50              	                .set    MODE_FIQ, 0x11
  51              	                .set    MODE_IRQ, 0x12
  52              	                .set    MODE_SVC, 0x13
  53              	                .set    MODE_MON, 0x16
  54              	                .set    MODE_ABT, 0x17
  55              	                .set    MODE_UND, 0x1B
  56              	                .set    MODE_SYS, 0x1F
  57              	
  58              	                .equ    I_BIT,      0x80
  59              	                .equ    F_BIT,      0x40
  60              	                .equ    SCR_NS,     0x01
  61              	                .equ    SCR_IRQ,    0x02
  62              	                .equ    SCR_FIQ,    0x04
  63              	                .equ    SCR_EA,     0x08
  64              	                .equ    SCR_FW,     0x10
  65              	                .equ    SCR_AW,     0x20
  66              	
  67              	                .equ    MON_S_SCR,  SCR_IRQ
  68              	                .equ    MON_NS_SCR, SCR_FIQ|SCR_NS
  69              	
  70              	                .text
  71              	
  72              	                .balign 16
  73              	
  74              	                .code   32
  75              	                .global _port_switch_arm
  76              	_port_switch_arm:
  77 0000 F04F2DE9 	                stmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  78 0004 0CD081E5 	                str     sp, [r1, #12]
  79 0008 0CD090E5 	                ldr     sp, [r0, #12]
  80 000c F08FBDE8 	                ldmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  81              	
  82              	/*
  83              	 * Common IRQ code. It expects a macro ARM_IRQ_VECTOR_REG with the address
  84              	 * of a register holding the address of the ISR to be invoked, the ISR
  85              	 * then returns in the common epilogue code where the context switch will
  86              	 * be performed, if required.
  87              	 * System stack frame structure after a context switch in the
  88              	 * interrupt handler:
  89              	 *
  90              	 * High +------------+
  91              	 *      |   LR_USR   | -+
  92              	 *      |     r12    |  |
  93              	 *      |     r3     |  |
  94              	 *      |     r2     |  | External context: IRQ handler frame
  95              	 *      |     r1     |  |
  96              	 *      |     r0     |  |
  97              	 *      |   LR_IRQ   |  |   (user code return address)(could be in non-secure space)
  98              	 *      |   PSR_USR  | -+   (user code status)
ARM GAS  /tmp/cc4MCD3v.s 			page 4


  99              	 *      |    ....    | <- chSchDoReschedule() stack frame, optimize it for space
 100              	 *      |     LR     | -+   (system code return address)(always in secure space)
 101              	 *      |     r11    |  |
 102              	 *      |     r10    |  |
 103              	 *      |     r9     |  |
 104              	 *      |     r8     |  | Internal context: chSysSwitch() frame
 105              	 *      |     r7     |  |
 106              	 *      |     r6     |  |
 107              	 *      |     r5     |  |
 108              	 * SP-> |     r4     | -+
 109              	 * Low  +------------+
 110              	 *
 111              	 */
 112              	
 113              	/*
 114              	 * We are facing an architecure with security extension exploited.
 115              	 * The following two monitor execution paths are taken by the execution units
 116              	 * running in secure state when an irq is fired (Mon_Irq_Handler), and in non-secure
 117              	 * state when a fiq interrupt is fired (Mon_Fiq_Handler).
 118              	 * They originate by the monitor irq/fiq vector and run in monitor mode,
 119              	 * ie in secure state.
 120              	 * It assumes the following, set at boot time, or wherever it needs:
 121              	 *   SCR.FW  == 0 and SCR.FIQ == 1 and SCR.IRQ == 0 in non-secure state,
 122              	 *      ie FIQs are taken to monitor mode, IRQs are taken locally
 123              	 *   SCR.FW  == 0 and SCR.FIQ == 0 and SCR.IRQ == 1 in secure state,
 124              	 *      ie FIQs are taken locally, IRQs are taken to monitor mode
 125              	 *   MVBAR holds the address of the monitor vectors base.
 126              	 *   The code and the stacks memory reside both in secure memory.
 127              	 */
 128              	                .balign 16
 129              	                .code   32
 130              	                .global Mon_Fiq_Handler
 131              	                .global Mon_Irq_Handler
 132              	                .global Fiq_Handler
 133              	Mon_Irq_Handler:
 134              	                // Here the IRQ is taken from secure state,
 135              	                // current mode is monitor (so current state is secure),
 136              	                // the previous mode and status is in mon.spsr and
 137              	                // the return address+4 is in mon.lr.
 138              	                //
 139              	                // This procedure is challenging, because the irq must be
 140              	                // executed in the non secure context and must return in this
 141              	                // secure context. The non secure IRQ handler has
 142              	                // the responsibility to return into secure state via a smc.
 143              	                //
 144              	                // The thread is interrupted in the same way that local FIQ.
 145              	                // The frame is created in the system stack of the current thread
 146 0010 DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 147 0014 0F502DE9 	                stmfd   sp!, {r0-r3, r12, lr}
 148 0018 D6F021E3 	                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
 149 001c 00004FE1 	                mrs     r0, SPSR
 150 0020 0E10A0E1 	                mov     r1, lr
 151 0024 DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 152 0028 03002DE9 	                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
 153              	
 154              	                /* Save the s_ctx e recover the ns_ctx */
 155              	
ARM GAS  /tmp/cc4MCD3v.s 			page 5


 156              	                // Re-establish the original conditions
 157 002c 0300BDE8 	                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
 158 0030 D6F021E3 	                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
 159 0034 00F06FE1 	                msr     SPSR_fsxc, r0
 160 0038 01E0A0E1 	                mov     lr, r1
 161 003c DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 162 0040 0F50BDE8 	                ldmfd   sp!, {r0-r3, r12, lr}
 163 0044 D6F021E3 	                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
 164 0048 00402DE9 	                stmfd   sp!, {lr}               // save lr into monitor stack
 165 004c 05E0A0E3 	                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
 166 0050 11EF11EE 	                mrc     p15, 0, lr, c1, c1, 0
 167 0054 0040BDE8 	                ldmfd   sp!, {lr}
 168 0058 04F05EE2 	                subs    pc, lr, #4              // return into non-secure world
 169              	                                                // and serve the IRQ
 170              	/*
 171              	 *
 172              	 */
 173              	Mon_Fiq_Handler:
 174              	                // Here the fiq is taken from non-secure state, via the FIQ vector
 175              	                // that is in the mon vector table.
 176              	                // Current mode is monitor (so current state is secure).
 177              	                // Note also that we never leave secure state while sec FIQ was disabled,
 178              	                // then it's always safe to process the FIQ here.
 179 005c 00402DE9 	                stmfd   sp!, {lr}               // save lr into monitor stack
 180 0060 02E0A0E3 	                ldr     lr, =MON_S_SCR          // set secure SCR before to switch to FIQ mode
 181 0064 11EF11EE 	                mrc     p15, 0, lr, c1, c1, 0
 182 0068 D1000EF1 	                cpsid   if, #MODE_FIQ           // secure FIQ mode
 183 006c 0F102DE9 	                stmfd   sp!, {r0-r3, r12}       // IRQ frame, save scratch registers
 184 0070 04019FE5 	                ldr     r0, =ARM_IRQ_VECTOR_REG
 185 0074 000090E5 	                ldr     r0, [r0]
 186 0078 00E19FE5 	                ldr     lr, =_mon_fiq_ret_arm   // ISR return point.
 187 007c 10FF2FE1 	                bx      r0                      // Calling the ISR.
 188              	_mon_fiq_ret_arm:
 189 0080 000050E3 	                cmp     r0, #0
 190 0084 0F10BDE8 	                ldmfd   sp!, {r0-r3, r12}
 191 0088 D6000EF1 	                cpsid   if, #MODE_MON
 192 008c 05E0A0E3 	                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
 193 0090 11EF110E 	                mrceq   p15, 0, lr, c1, c1, 0   // only if it will return
 194 0094 0040BDE8 	                ldmfd   sp!, {lr}
 195 0098 04F05E02 	                subeqs  pc, lr, #4              // No reschedule, returns.
 196              	
 197              	                // Now the frame is created in the system stack
 198              	                // relative to non secure context,
 199              	                // the IRQ and monitor stacks are empty,
 200              	                // the state is secure.
 201 009c DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 202 00a0 0F502DE9 	                stmfd   sp!, {r0-r3, r12, lr}
 203 00a4 0D00A0E1 	                mov		r0, sp
 204 00a8 D6F021E3 	                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
 205 00ac 01002DE9 	                stmfd	sp!, {r0}				// address of ns_ctx in mon stack
 206 00b0 00004FE1 	                mrs     r0, SPSR
 207 00b4 0E10A0E1 	                mov     r1, lr
 208 00b8 DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 209 00bc 03002DE9 	                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
 210 00c0 0D00A0E1 	                mov		r0, sp
 211              	
 212              	                // Context switch.
ARM GAS  /tmp/cc4MCD3v.s 			page 6


 213              	#if CH_DBG_SYSTEM_STATE_CHECK
 214              	                bl      _dbg_check_lock
 215              	#endif
 216 00c4 FEFFFFEB 	                bl      chSchDoReschedule
 217              	#if CH_DBG_SYSTEM_STATE_CHECK
 218              	                bl      _dbg_check_unlock
 219              	#endif
 220              	
 221              	                // Re-establish the IRQ conditions again.
 222 00c8 0300BDE8 	                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
 223 00cc D6F021E3 	                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
 224 00d0 00F06FE1 	                msr     SPSR_fsxc, r0
 225 00d4 01E0A0E1 	                mov     lr, r1
 226 00d8 0100BDE8 	                ldmfd	sp!, {r0}				// ns_ctx no longer exists, cleanup mon stack
 227 00dc DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 228 00e0 0F50BDE8 	                ldmfd   sp!, {r0-r3, r12, lr}
 229 00e4 D6F021E3 	                msr     CPSR_c, #MODE_MON | I_BIT | F_BIT
 230 00e8 00402DE9 	                stmfd   sp!, {lr}               // save lr into mon stack
 231 00ec 05E0A0E3 	                ldr     lr, =MON_NS_SCR         // set non-secure SCR before return
 232 00f0 11EF11EE 	                mrc     p15, 0, lr, c1, c1, 0
 233 00f4 0040BDE8 	                ldmfd   sp!, {lr}
 234 00f8 04F05EE2 	                subs    pc, lr, #4              // return into non-secure world
 235              	/*
 236              	 *
 237              	 */
 238              	Fiq_Handler:
 239              	                // the fiq is taken locally from secure state
 240              	                // current mode is fiq
 241 00fc 0F502DE9 	                stmfd   sp!, {r0-r3, r12, lr}   // save scratch registers and lr
 242 0100 74009FE5 	                ldr     r0, =ARM_IRQ_VECTOR_REG
 243 0104 000090E5 	                ldr     r0, [r0]
 244 0108 74E09FE5 	                ldr     lr, =_fiq_ret_arm       // ISR return point.
 245 010c 10FF2FE1 	                bx      r0                      // Calling the ISR.
 246              	_fiq_ret_arm:
 247 0110 000050E3 	                cmp     r0, #0
 248 0114 0F50BDE8 	                ldmfd   sp!, {r0-r3, r12, lr}
 249 0118 04F05E02 	                subeqs  pc, lr, #4              // No reschedule, returns.
 250              	
 251              	                // Now the frame is created in the system stack of the current
 252              	                // thread, the IRQ stack is empty.
 253 011c DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 254 0120 0F502DE9 	                stmfd   sp!, {r0-r3, r12, lr}
 255 0124 D1F021E3 	                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
 256 0128 00004FE1 	                mrs     r0, SPSR
 257 012c 0E10A0E1 	                mov     r1, lr
 258 0130 DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 259 0134 03002DE9 	                stmfd   sp!, {r0, r1}           // Push R0=SPSR, R1=LR_IRQ.
 260              	
 261              	                // Context switch.
 262              	#if CH_DBG_SYSTEM_STATE_CHECK
 263              	                bl      _dbg_check_lock
 264              	#endif
 265 0138 FEFFFFEB 	                bl      chSchDoReschedule
 266              	#if CH_DBG_SYSTEM_STATE_CHECK
 267              	                bl      _dbg_check_unlock
 268              	#endif
 269              	
ARM GAS  /tmp/cc4MCD3v.s 			page 7


 270              	                // Re-establish the IRQ conditions again.
 271 013c 0300BDE8 	                ldmfd   sp!, {r0, r1}           // Pop R0=SPSR, R1=LR_IRQ.
 272 0140 D1F021E3 	                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
 273 0144 00F06FE1 	                msr     SPSR_fsxc, r0
 274 0148 01E0A0E1 	                mov     lr, r1
 275 014c DFF021E3 	                msr     CPSR_c, #MODE_SYS | I_BIT | F_BIT
 276 0150 0F50BDE8 	                ldmfd   sp!, {r0-r3, r12, lr}
 277 0154 D1F021E3 	                msr     CPSR_c, #MODE_FIQ | I_BIT | F_BIT
 278 0158 04F05EE2 	                subs    pc, lr, #4
 279              	
 280              	/*
 281              	 * Threads trampoline code.
 282              	 * NOTE: The threads always start in ARM mode.
 283              	 */
 284 015c 00F020E3 	                .balign 16
 285              	                .code   32
 286              	                .globl  _port_thread_start
 287              	_port_thread_start:
 288              	#if CH_DBG_SYSTEM_STATE_CHECK
 289              	                bl      _dbg_check_unlock
 290              	#endif
 291 0160 9FF021E3 					msr     CPSR_c, #MODE_SYS | I_BIT
 292 0164 0500A0E1 	                mov     r0, r5
 293 0168 0FE0A0E1 	                mov     lr, pc
 294 016c 14FF2FE1 	                bx      r4
 295              	#if defined(_CHIBIOS_RT_CONF_)
 296 0170 0000A0E3 	                mov     r0, #0              /* MSG_OK */
 297 0174 FEFFFFEB 	                bl      chThdExit
 298 0178 FEFFFFEA 	_zombies:       b       _zombies
 298      10C003F8 
 298      80000000 
 298      10010000 
ARM GAS  /tmp/cc4MCD3v.s 			page 8


DEFINED SYMBOLS
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:49     *ABS*:0000000000000010 MODE_USR
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:50     *ABS*:0000000000000011 MODE_FIQ
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:51     *ABS*:0000000000000012 MODE_IRQ
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:52     *ABS*:0000000000000013 MODE_SVC
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:53     *ABS*:0000000000000016 MODE_MON
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:54     *ABS*:0000000000000017 MODE_ABT
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:55     *ABS*:000000000000001b MODE_UND
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:56     *ABS*:000000000000001f MODE_SYS
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:58     *ABS*:0000000000000080 I_BIT
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:59     *ABS*:0000000000000040 F_BIT
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:60     *ABS*:0000000000000001 SCR_NS
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:61     *ABS*:0000000000000002 SCR_IRQ
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:62     *ABS*:0000000000000004 SCR_FIQ
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:63     *ABS*:0000000000000008 SCR_EA
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:64     *ABS*:0000000000000010 SCR_FW
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:65     *ABS*:0000000000000020 SCR_AW
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:67     *ABS*:0000000000000002 MON_S_SCR
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:68     *ABS*:0000000000000005 MON_NS_SCR
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:72     .text:0000000000000000 $a
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:76     .text:0000000000000000 _port_switch_arm
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:173    .text:000000000000005c Mon_Fiq_Handler
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:133    .text:0000000000000010 Mon_Irq_Handler
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:238    .text:00000000000000fc Fiq_Handler
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:188    .text:0000000000000080 _mon_fiq_ret_arm
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:246    .text:0000000000000110 _fiq_ret_arm
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:287    .text:0000000000000160 _port_thread_start
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:298    .text:0000000000000178 _zombies
../../../os/common/ports/ARMCAx-TZ/compilers/GCC/chcoreasm.S:298    .text:000000000000017c $d

UNDEFINED SYMBOLS
chSchDoReschedule
chThdExit
